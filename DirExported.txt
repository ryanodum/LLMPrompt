#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Media;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
using System.Xml.Linq;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Core;
using NinjaTrader.Custom;
using NinjaTrader.Data;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.NinjaScript.AtmStrategy;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX;
using SharpDX.Direct2D1;
#endregion

namespace NinjaTrader.NinjaScript.Indicators
{
    public class MarketMaestro : Indicator
    {
        NinjaTrader.Gui.Tools.SimpleFont title =
        new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 20, Bold = true };
        NinjaTrader.Gui.Tools.SimpleFont title2 =
        new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 15, Bold = true };
        NinjaTrader.Gui.Tools.SimpleFont TextFont =
        new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 15, Bold = false };

        double realizedPnL = 0;
        double TriggerBar1 = 0;
        double BarsSince1 = 0;
        double TriggerBar2 = 0;
        double BarsSince2 = 0;
        bool sigLock1 = false;
        bool sigLock2 = false;
        bool playOnce = false;
        bool isReversed = false;
        string version = "V8";

        private SimpleFont textFont = new SimpleFont("Arial", 10)
        {
            Bold = true
        };

        #region Box Vars
        private Border moveB;
        private Border hideB;
        private Border tileHolder;
        private Grid grid;
        private Thickness margin;
        private bool subscribedToSize;
        private System.Windows.Point startPoint;
        private Button ARMLONGbtn;
        private Button ARMSHORTbtn;
        private Button ARMOPTIONbtn;
        private Button Closebtn;
        private Button AUTOArmbtn;
        private Button resetQuantVal;
        private Button increaseQuant;
        private Button decreaseQuant;
        private Label ATMLabel;
        private Label ACCOUNTLabel;
        private Label selectedATMStrat;
        private Label accountSelected;
        private Label quantityLabel;
        private TextBox quantityLabelVal;
        private ComboBox combo;
        private bool armLongBtnToggle;
        private bool armShortBtnToggle;
        private bool armOptionBtnToggle;
        private bool autoArmBtnToggle;
        private int quantityValue = 1;
        private int quantityATM = 1;
        private bool closeRunning;
        private bool handlerSet;
        private Chart chartWindow;
        private Grid chartTraderGrid;
        private Grid chartTraderButtonsGrid;
        private Grid lowerButtonsGrid;
        private Grid upperButtonsGrid;
        private AtmStrategySelector atmSelector;
        private AccountSelector accountSelector;
        private bool connected;
        private Instrument inst;
        private bool onceTriggered;
        private bool inPosition;
        private int posDirection;
        private Account chartTraderAccount;
        private Position positions;
        private Timer _posTimer;
        private Timer _acctTimer;
        private FrameworkElement addedGrid;
        #endregion

        // FisherVolatilityRegimeIndicator reference
        private FisherVolatilityRegimeIndicator fisher;

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Description = "";
                Name = "MarketMaestro";
                Calculate = Calculate.OnEachTick;
                BarsRequiredToPlot = 100;
                IsOverlay = true;
                DisplayInDataBox = false;
                ShowTransparentPlotsInDataBox = true;
                DrawOnPricePanel = true;
                PaintPriceMarkers = false;
                IsSuspendedWhileInactive = false;
                this.SelectedTypes = new XElement("SelectedTypes");
                ArePlotsConfigurable = false;
                AreLinesConfigurable = false;
                this.Left = 5.0;
                this.Top = -1.0;
                this.NumberOfRows = 5;
                realizedProfit = 0;
                realizedLoss = 0;
                startTime = 73000;
                endTime = 120000;
                econNumber1 = 74500;
                econNumber2 = 80000;
                openTime = 0;

                // Default params for Fisher
                FisherLength = 9;
                ATRPeriod = 14;
                MomentumPeriod = 10;
                ATRThresholdMultiplier = 1.5;
                FisherSmoothingFactor = 0.2;
                FisherShowArrows = true;    // Enable arrows from the Fisher Indicator
                FisherBarThreshold = 15;
            }
            else if (State == State.Configure)
            {
                // Nothing special here
            }
            else if (State == State.DataLoaded)
            {
                // Initialize the FisherVolatilityRegimeIndicator
                fisher = FisherVolatilityRegimeIndicator(Input, FisherLength, ATRPeriod, MomentumPeriod, FisherSmoothingFactor, FisherShowArrows, FisherBarThreshold);

                // Keyboard hot key listener
                ChartControl.Dispatcher.InvokeAsync(() =>
                {
                    ChartControl.KeyDown += new System.Windows.Input.KeyEventHandler(ChartControl_KeyDown);
                });
            }

            if (State != State.DataLoaded)
            {
                if (State == State.Historical)
                {
                    Draw.TextFixed(this, "hftName", "Market Maestro", TextPosition.TopRight, Brushes.Magenta, title, Brushes.Black, Brushes.Black, 50);

                    #region Control Panel
                    try
                    {
                        Dispatcher.InvokeAsync(delegate ()
                        {
                            QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
                            this.quantityATM = quantityUpDown.Value;
                        });
                    }
                    catch (Exception)
                    {
                    }
                    try
                    {
                        if (ChartControl != null)
                        {
                            if (this.Top < 0.0)
                            {
                                this.Top = 25.0;
                            }
                            Dispatcher.Invoke(delegate ()
                            {
                                this.addedGrid = this.CreateControl();
                                UserControlCollection.Add(this.addedGrid);
                            });
                        }
                        return;
                    }
                    catch (Exception)
                    {
                        return;
                    }
                    #endregion
                }
                if (State == State.Terminated)
                {
                    if (ChartControl != null)
                    {
                        ChartControl.Dispatcher.InvokeAsync(() =>
                        {
                            ChartControl.KeyDown -= ChartControl_KeyDown;
                        });
                    }
                    #region Control Panel Cleanup
                    this.grid = null;
                    this.tileHolder = null;
                    this.moveB = null;
                    this.hideB = null;
                    Dispatcher.Invoke(delegate ()
                    {
                        UserControlCollection.Remove(this.addedGrid);
                        this.addedGrid = null;
                    });
                    try
                    {
                        if (this._posTimer != null)
                        {
                            this._posTimer.Change(-1, 0);
                            this._posTimer.Dispose();
                        }
                        if (this._acctTimer != null)
                        {
                            this._acctTimer.Change(-1, 0);
                            this._acctTimer.Dispose();
                        }
                        if (this.addedGrid != null)
                        {
                            UserControlCollection.Remove(this.addedGrid);
                            this.addedGrid = null;
                        }
                        if (this.moveB != null)
                        {
                            this.moveB = null;
                        }
                        if (this.hideB != null)
                        {
                            this.hideB = null;
                        }
                        if (this.grid != null)
                        {
                            this.grid = null;
                        }
                        if (this.tileHolder != null)
                        {
                            this.tileHolder = null;
                        }
                        if (this.ARMLONGbtn != null)
                        {
                            this.ARMLONGbtn.Click -= this.ARMLONGbtn_Click;
                            this.ARMLONGbtn = null;
                        }
                        if (this.ARMSHORTbtn != null)
                        {
                            this.ARMSHORTbtn.Click -= this.ARMSHORTbtn_Click;
                            this.ARMSHORTbtn = null;
                        }
                        if (this.ARMOPTIONbtn != null)
                        {
                            this.ARMOPTIONbtn.Click -= this.ARMOPTIONbtn_Click;
                            this.ARMOPTIONbtn = null;
                        }
                        if (this.Closebtn != null)
                        {
                            this.Closebtn.Click -= this.Closebtn_Click;
                            this.Closebtn = null;
                        }
                        if (this.AUTOArmbtn != null)
                        {
                            this.AUTOArmbtn.Click -= this.AUTOArmbtn_Click;
                            this.AUTOArmbtn = null;
                        }
                        if (this.resetQuantVal != null)
                        {
                            this.resetQuantVal.Click -= new RoutedEventHandler(this.resetQuantVal_Click);
                            this.resetQuantVal = null;
                        }
                        if (this.increaseQuant != null)
                        {
                            this.increaseQuant.Click -= new RoutedEventHandler(this.increaseQuant_Click);
                            this.increaseQuant = null;
                        }
                        if (this.decreaseQuant != null)
                        {
                            this.decreaseQuant.Click -= new RoutedEventHandler(this.decreaseQuant_Click);
                            this.decreaseQuant = null;
                        }
                        if (this.atmSelector != null)
                        {
                            this.atmSelector.SelectionChanged -= new SelectionChangedEventHandler(this.ATMSelection_Changed);
                            this.atmSelector = null;
                        }
                        if (this.quantityLabelVal != null)
                        {
                            this.quantityLabelVal.PreviewKeyDown -= this.TextBox_PreviewKeyDown;
                            this.quantityLabelVal = null;
                        }
                        if (this.accountSelector != null)
                        {
                            this.accountSelector.SelectionChanged -= new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
                            this.accountSelector = null;
                        }
                    }
                    catch (Exception)
                    {
                    }
                    #endregion
                }
                return;
            }
        }

        protected override void OnBarUpdate()
{
    try
    {
        if (!this.subscribedToSize && ChartPanel != null)
        {
            this.subscribedToSize = true;
            ChartPanel.SizeChanged += delegate (object sender, SizeChangedEventArgs e)
            {
                if (this.grid != null && ChartPanel != null)
                {
                    if (this.grid.Margin.Left + this.grid.ActualWidth > ChartPanel.ActualWidth || this.grid.Margin.Top + this.grid.ActualHeight > ChartPanel.ActualHeight)
                    {
                        double left = Math.Max(0.0, Math.Min(this.grid.Margin.Left, ChartPanel.ActualWidth - this.grid.ActualWidth));
                        double top = Math.Max(0.0, Math.Min(this.grid.Margin.Top, ChartPanel.ActualHeight - this.grid.ActualHeight));
                        this.grid.Margin = new Thickness(left, top, 0.0, 0.0);
                        this.Left = left;
                        this.Top = top;
                    }
                    return;
                }
            };
        }

        try
        {
            if (AccountName != null)
            {
                try
                {
                    Account myPnL = null;
                    lock (Account.All)
                    {
                        myPnL = Account.All.FirstOrDefault(a => a.Name == AccountName);
                    }
                    realizedPnL = myPnL.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar);
                }
                catch (Exception)
                {
                }
            }
            Draw.TextFixed(this, "pnlstat", "\n\n" + "ACC PNL $" + realizedPnL.ToString("F2"), TextPosition.TopRight);
            if (realizedProfit != 0 && realizedPnL >= realizedProfit)
            {
                Draw.TextFixed(this, "PT STAT", "Stopped - Profit Target Reached" + "   Realized P&L: " + realizedPnL.ToString("F2"), TextPosition.Center, Brushes.LimeGreen, title, Brushes.Black, Brushes.Black, 50);
                return;
            }
            if (realizedLoss != 0 && realizedPnL <= realizedLoss)
            {
                Draw.TextFixed(this, "SL STAT", "Stopped - Total Stop Loss Reached" + "   Realized P&L: " + realizedPnL.ToString("F2"), TextPosition.Center, Brushes.Red, title, Brushes.Black, Brushes.Black, 50);
                return;
            }
            if (isReversed == false)
            {
                Draw.TextFixed(this, "Rev", "Normal" + "\n", TextPosition.BottomLeft, Brushes.LimeGreen, title2, Brushes.Transparent, Brushes.Black, 0);
                Draw.TextFixed(this, "v", version.ToString(), TextPosition.BottomLeft);
            }
            else
            {
                Draw.TextFixed(this, "Rev", "Reversed" + "\n", TextPosition.BottomLeft, Brushes.LimeGreen, title2, Brushes.Transparent, Brushes.Black, 0);
                Draw.TextFixed(this, "v", version.ToString(), TextPosition.BottomLeft);
            }

            // Econ Avoid
            if (econNumber1 != 0 || econNumber2 != 0)
            {
                DateTime ecNumber = Time[0];
                ecNumber.AddMinutes(5);

                if ((ToTime(Time[0]) >= econNumber1 - (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0])) && ToTime(Time[0]) < econNumber1 + (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0]))))
                {
                    Draw.TextFixed(this, "Econ", "\n\n\n\n" + "No Trades Econ Data Release +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent, Brushes.Black, 0);
                    return;
                }
                else if ((ToTime(Time[0]) >= econNumber2 - (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0])) && ToTime(Time[0]) < econNumber2 + (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0]))))
                {
                    Draw.TextFixed(this, "Econ", "\n\n\n\n" + "No Trades Econ Data Release +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent, Brushes.Black, 0);
                    return;
                }
                else if ((ToTime(Time[0]) >= openTime - (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0])) && ToTime(Time[0]) < openTime + (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0]))))
                {
                    Draw.TextFixed(this, "Econ", "\n\n\n\n" + "No Trades During Market Open +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent, Brushes.Black, 0);
                    return;
                }
                else
                {
                    Draw.TextFixed(this, "Econ", "\n\n\n\n" + "Skipping Econ @ " + econNumber1.ToString() + " and " + econNumber2.ToString(), TextPosition.TopRight, Brushes.LimeGreen, title2, Brushes.Transparent, Brushes.Black, 0);
                }
            }

            // Trade Time
            if ((ToTime(Time[0]) >= startTime && ToTime(Time[0]) < endTime))
            {
                Draw.TextFixed(this, "timeStat", "\n\n\n" + "Trade Time: Trading " + startTime.ToString() + " to " + endTime.ToString(), TextPosition.TopRight);
            }
            else if (startTime == 0 && endTime == 0)
            {
                Draw.TextFixed(this, "timeStat", "\n\n\n" + "Trade Time: Trading All Day", TextPosition.TopRight);
            }
            else
            {
                Draw.TextFixed(this, "timeStat", "\n\n\n" + "Trade Time: Not Trading", TextPosition.TopRight);
                return;
            }

        }
        catch
        {
        }

        try
        {
            if (CurrentBars[0] < 20)
                return;

            if (State == State.Realtime && inPosition == false)
            {
                Draw.TextFixed(this, "pos", "\n\n\n\n\n" + "No Position", TextPosition.TopRight);
            }
            if (State == State.Realtime && inPosition == true)
            {
                Draw.TextFixed(this, "pos", "\n\n\n\n\n" + "In Position", TextPosition.TopRight);
            }

            if (CurrentBar > TriggerBar1)
            {
                BarsSince1 = CurrentBar - TriggerBar1;
                if (BarsSince1 >= 1 && IsFirstTickOfBar)
                {
                    TriggerBar1 = 0;
                    sigLock1 = false;
                    playOnce = false;
                }
            }
            if (CurrentBar > TriggerBar2)
            {
                BarsSince2 = CurrentBar - TriggerBar2;
                if (BarsSince2 >= 1 && IsFirstTickOfBar)
                {
                    TriggerBar2 = 0;
                    sigLock2 = false;
                    playOnce = false;
                }
            }

            // Fisher signals: 1 = Buy signal, -1 = Sell signal, 0 = No signal
            double fisherSignal = fisher.BuySellSignalLine[0];

            // Draw arrows
            if (fisherSignal == 1)
            {
                Draw.ArrowUp(this, "BuySignal" + CurrentBar, false, 0, Low[0] - TickSize, Brushes.Green);
            }
            else if (fisherSignal == -1)
            {
                Draw.ArrowDown(this, "SellSignal" + CurrentBar, false, 0, High[0] + TickSize, Brushes.Red);
            }

            // Updated conditions to ignore sigLock if inPosition == true
            if (fisherSignal == 1 && (inPosition || (!inPosition)))
            {
                if (!playOnce)
                {
                    try
                    {
                        PlaySound(NinjaTrader.Core.Globals.InstallDir + @"\sounds\HFTNQ.wav");
                    }
                    catch { }
                    playOnce = true;
                }

                // If not reversed -> buy, if reversed -> sell
                if (!isReversed)
                    takeTrade(1); // BUY
                else
                    takeTrade(-1); // SELL if reversed

                // Only set sigLock if we were not already in position
                if (!inPosition)
                {
                    //sigLock1 = true;
                    TriggerBar1 = CurrentBar;
                }
            }

            if (fisherSignal == -1 && (inPosition || (!inPosition)))
            {
                if (!playOnce)
                {
                    try
                    {
                        PlaySound(NinjaTrader.Core.Globals.InstallDir + @"\sounds\HFTNQ.wav");
                    }
                    catch { }
                    playOnce = true;
                }

                // If not reversed -> sell short, if reversed -> buy
                if (!isReversed)
                    takeTrade(-1); // SELL
                else
                    takeTrade(1); // BUY if reversed

                // Only set sigLock if we were not already in position
                if (!inPosition)
                {
                    //sigLock2 = true;
                    TriggerBar2 = CurrentBar;
                }
            }

        }
        catch (Exception)
        {
        }

    }
    catch (Exception)
    {
    }
}


        private void ChartControl_KeyDown(object sender, KeyEventArgs e)
        {
            if (((Keyboard.Modifiers & ModifierKeys.Control) != 0) && Keyboard.IsKeyDown(Key.NumPad0))
            {
                if (isReversed == false)
                {
                    isReversed = true;
                    Print("Reversed");
                    return;
                }
                if (isReversed == true)
                {
                    isReversed = false;
                    Print("Normal");
                    return;
                }
            }
        }

        #region Control Panel Methods
        private FrameworkElement CreateControl()
        {
            try
            {
                this.chartWindow = (Window.GetWindow(ChartControl.Parent) as Chart);
                this.chartTraderGrid = ((Extensions.FindFirst(this.chartWindow, "ChartWindowChartTraderControl") as ChartTrader).Content as Grid);
                if (this.chartTraderGrid != null)
                {
                    try
                    {
                        this.chartTraderButtonsGrid = (this.chartTraderGrid.Children[0] as Grid);
                        if (this.chartTraderButtonsGrid != null)
                        {
                            Grid grid = (Grid)this.chartTraderGrid.Children[2];
                            if (grid != null)
                            {
                                this.atmSelector = (AtmStrategySelector)grid.Children[1];
                                this.atmSelector.SelectionChanged += new SelectionChangedEventHandler(this.ATMSelection_Changed);
                            }
                            Grid grid2 = (Grid)this.chartTraderGrid.Children[1];
                            if (grid2 != null)
                            {
                                ChartControl.Dispatcher.Invoke(delegate ()
                                {
                                    AccountSelector accountSelector = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlAccountSelector") as AccountSelector;
                                    this.chartTraderAccount = ((accountSelector != null) ? accountSelector.SelectedAccount : null);
                                    this.accountSelector = ((accountSelector != null) ? accountSelector : null);
                                });
                                if (this.accountSelector != null && !this.handlerSet)
                                {
                                    this.handlerSet = true;
                                    this.accountSelector.SelectionChanged += new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
                                }
                                this.combo = (ComboBox)grid2.Children[4];
                                foreach (Instrument instrument in Instrument.All)
                                {
                                    if (instrument.FullName == this.combo.SelectedValue.ToString())
                                    {
                                        this.inst = instrument;
                                    }
                                }
                            }
                        }

                    }
                    catch (Exception)
                    {
                    }
                }
                this._posTimer = new Timer(new TimerCallback(this.posCallback), null, 0, 200);
                this._acctTimer = new Timer(new TimerCallback(this.acctCallback), null, 0, 200);
                if (this.grid != null)
                {
                    return this.grid;
                }
                this.grid = new Grid
                {
                    VerticalAlignment = VerticalAlignment.Top,
                    HorizontalAlignment = HorizontalAlignment.Left,
                    Margin = new Thickness(this.Left, this.Top, 0.0, 0.0),
                };
                this.grid.ColumnDefinitions.Add(new ColumnDefinition
                {
                    Width = default(GridLength)
                });
                this.grid.ColumnDefinitions.Add(new ColumnDefinition
                {
                    Width = default(GridLength)
                });
                this.grid.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                System.Windows.Media.Brush background = (Application.Current.FindResource("BackgroundMainWindow") as System.Windows.Media.Brush) ?? Brushes.White;
                System.Windows.Media.Brush borderBrush = (Application.Current.FindResource("BorderThinBrush") as System.Windows.Media.Brush) ?? Brushes.Black;
                Grid grid3 = new Grid();
                grid3.RowDefinitions.Add(new RowDefinition
                {
                    Height = new GridLength(2.0, GridUnitType.Star)
                });
                grid3.RowDefinitions.Add(new RowDefinition
                {
                    Height = new GridLength(1.0, GridUnitType.Star)
                });
                grid3.RowDefinitions.Add(new RowDefinition
                {
                    Height = new GridLength(2.0, GridUnitType.Star)
                });
                Grid grid4 = new Grid();
                grid4.RowDefinitions.Add(new RowDefinition
                {
                    Height = new GridLength(3.0, GridUnitType.Star)
                });
                for (int i = 0; i < grid3.RowDefinitions.Count; i++)
                {
                    System.Windows.Shapes.Ellipse element = new System.Windows.Shapes.Ellipse
                    {
                        Width = 4.0,
                        Height = 4.0,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        VerticalAlignment = VerticalAlignment.Center,
                        Fill = Brushes.White
                    };
                    Grid.SetRow(element, i);
                    grid3.Children.Add(element);
                }
                System.Windows.Shapes.Polygon element2 = new System.Windows.Shapes.Polygon
                {
                    Width = 12.0,
                    Height = 12.0,
                    HorizontalAlignment = HorizontalAlignment.Center,
                    VerticalAlignment = VerticalAlignment.Center,
                    Fill = Brushes.Crimson,
                    Points = new PointCollection
                    {
                        new System.Windows.Point(1.0, 5.0),
                        new System.Windows.Point(8.0, 10.0),
                        new System.Windows.Point(8.0, 0.0)
                    }
                };
                Grid.SetRow(element2, 0);
                grid4.Children.Add(element2);
                this.moveB = new Border
                {
                    VerticalAlignment = VerticalAlignment.Top,
                    BorderThickness = new Thickness(0.0, 1.0, 1.0, 1.0),
                    BorderBrush = borderBrush,
                    Background = background,
                    Width = 12.0,
                    Height = 24.0,
                    Cursor = Cursors.Hand,
                    Child = grid3
                };
                this.hideB = new Border
                {
                    VerticalAlignment = VerticalAlignment.Bottom,
                    BorderThickness = new Thickness(0.0, 1.0, 1.0, 1.0),
                    BorderBrush = borderBrush,
                    Background = background,
                    Width = 14.0,
                    Height = 24.0,
                    Cursor = Cursors.Hand,
                    Child = grid4
                };
                this.moveB.MouseDown += (MouseButtonEventHandler)((sender, e) =>
                {
                    this.startPoint = e.GetPosition((IInputElement)this.ChartPanel);
                    this.margin = this.grid.Margin;
                    if (e.ClickCount > 1)
                    {
                        this.moveB.ReleaseMouseCapture();
                        this.ChartControl.OnIndicatorsHotKey((object)this, (KeyEventArgs)null);
                    }
                    else
                        this.moveB.CaptureMouse();
                });
                this.moveB.MouseUp += delegate (object sender, MouseButtonEventArgs e)
                {
                    this.moveB.ReleaseMouseCapture();
                };
                this.moveB.MouseMove += delegate (object sender, MouseEventArgs e)
                {
                    if (this.moveB.IsMouseCaptured && this.grid != null && ChartPanel != null)
                    {
                        System.Windows.Point position = e.GetPosition(ChartPanel);
                        this.grid.Margin = new Thickness
                        {
                            Left = Math.Max(0.0, Math.Min(this.margin.Left + (position.X - this.startPoint.X), ChartPanel.ActualWidth - this.grid.ActualWidth)),
                            Top = Math.Max(0.0, Math.Min(this.margin.Top + (position.Y - this.startPoint.Y), ChartPanel.ActualHeight - this.grid.ActualHeight))
                        };
                        this.Left = this.grid.Margin.Left;
                        this.Top = this.grid.Margin.Top;
                        return;
                    }
                };
                Grid.SetColumn(this.moveB, 1);
                Grid.SetColumn(this.hideB, 2);
                this.grid.Children.Add(this.moveB);
                Grid grid5 = new Grid();
                grid5.Background = Brushes.Black; /// main
                grid5.ColumnDefinitions.Add(new ColumnDefinition
                {
                    Width = default(GridLength)
                });
                grid5.ColumnDefinitions.Add(new ColumnDefinition
                {
                    Width = default(GridLength)
                });
                grid5.ColumnDefinitions.Add(new ColumnDefinition
                {
                    Width = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                Style style = Application.Current.FindResource("BasicEntryButton") as Style;
                Border border = new Border
                {
                    Background = Brushes.Black,
                    VerticalAlignment = VerticalAlignment.Stretch,
                    HorizontalAlignment = HorizontalAlignment.Stretch
                };
                Label label = new Label
                {
                    Content = string.Format("Market Maestro", 0),
                    Height = 20.0,
                    Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
                    HorizontalAlignment = HorizontalAlignment.Center,
                    FontSize = 14.0
                };
                label.Foreground = Brushes.Magenta;
                label.Background = Brushes.Black;
                label.BorderBrush = Brushes.Transparent;
                label.HorizontalAlignment = HorizontalAlignment.Center;
                Grid.SetColumnSpan(label, 3);
                border.Child = label;
                Grid.SetRow(border, 0);
                Grid.SetColumnSpan(border, 3);
                grid5.Children.Add(border);
                this.ATMLabel = new Label
                {
                    Content = string.Format("ATM Strategy: ", 0),
                    Height = 20.0,
                    Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
                    HorizontalAlignment = HorizontalAlignment.Center
                };
                this.ATMLabel.Foreground = Brushes.White;
                this.ATMLabel.Background = Brushes.Transparent;
                this.ATMLabel.BorderBrush = Brushes.Transparent;
                this.ATMLabel.HorizontalAlignment = HorizontalAlignment.Center;
                Grid.SetColumnSpan(this.ATMLabel, 1);
                Grid.SetRow(this.ATMLabel, 1);
                grid5.Children.Add(this.ATMLabel);
                string format = string.Empty;
                if (this.atmSelector != null)
                {
                    try
                    {
                        format = this.atmSelector.SelectedAtmStrategy.DisplayName;
                    }
                    catch (Exception)
                    {
                        format = "None";
                    }
                }
                this.selectedATMStrat = new Label
                {
                    Content = string.Format(format, 0),
                    Height = 20.0,
                    Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
                    HorizontalAlignment = HorizontalAlignment.Center
                };
                this.selectedATMStrat.Foreground = Brushes.White;
                this.selectedATMStrat.Background = Brushes.Transparent;
                this.selectedATMStrat.BorderBrush = Brushes.Transparent;
                this.selectedATMStrat.HorizontalAlignment = HorizontalAlignment.Center;
                Grid.SetColumnSpan(this.selectedATMStrat, 2);
                Grid.SetColumn(this.selectedATMStrat, 1);
                Grid.SetRow(this.selectedATMStrat, 1);
                grid5.Children.Add(this.selectedATMStrat);
                this.ACCOUNTLabel = new Label
                {
                    Content = string.Format("Acc: ", 0),
                    Height = 20.0,
                    Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
                    HorizontalAlignment = HorizontalAlignment.Center
                };
                this.ACCOUNTLabel.Foreground = Brushes.White;
                this.ACCOUNTLabel.Background = Brushes.Transparent;
                this.ACCOUNTLabel.BorderBrush = Brushes.Transparent;
                this.ACCOUNTLabel.HorizontalAlignment = HorizontalAlignment.Center;
                Grid.SetColumnSpan(this.ACCOUNTLabel, 1);
                Grid.SetRow(this.ACCOUNTLabel, 2);
                grid5.Children.Add(this.ACCOUNTLabel);
                string format2 = string.Empty;
                lock (Connection.Connections)
                {
                    foreach (Connection connection in Connection.Connections)
                    {
                        if (connection.Status == ConnectionStatus.Connected)
                        {
                            this.connected = true;
                            break;
                        }
                    }
                }
                if (!this.connected)
                {
                    format2 = "Disconnected";
                }
                else
                {
                    try
                    {
                        if (this.accountSelector == null || this.accountSelector.SelectedIndex.ToString() == string.Empty || this.accountSelector.SelectedAccount == null || string.IsNullOrEmpty(this.accountSelector.SelectedAccount.Name))
                        {
                            format2 = "Select Account";
                        }
                        else
                            format2 = CensorString(this.accountSelector.SelectedAccount.DisplayName);
                    }
                    catch (Exception)
                    {
                        format2 = "Select Account";
                    }
                }
                this.accountSelected = new Label
                {
                    Content = string.Format(format2, 0),
                    Height = 20.0,
                    Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
                    HorizontalAlignment = HorizontalAlignment.Center
                };
                this.accountSelected.Foreground = Brushes.White;
                this.accountSelected.Background = Brushes.Transparent;
                this.accountSelected.BorderBrush = Brushes.Transparent;
                this.accountSelected.HorizontalAlignment = HorizontalAlignment.Center;
                Grid.SetColumnSpan(this.accountSelected, 2);
                Grid.SetColumn(this.accountSelected, 1);
                Grid.SetRow(this.accountSelected, 2);
                grid5.Children.Add(this.accountSelected);

                // ARM LONG Button
                this.ARMLONGbtn = new Button
                {
                    Content = "Arm Long",
                    Name = "LongArmButton",
                    Height = 30.0,
                    Width = 125.0,
                    Margin = new Thickness(4.0, 4.0, 0.0, 0.0),
                    Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Style = style
                };
                this.ARMLONGbtn.Background = Brushes.Gray;
                this.ARMLONGbtn.BorderBrush = Brushes.DimGray;
                this.ARMLONGbtn.Foreground = Brushes.White;
                this.ARMLONGbtn.Click += this.ARMLONGbtn_Click;
                Grid.SetColumn(this.ARMLONGbtn, 0);
                Grid.SetRow(this.ARMLONGbtn, 3);
                grid5.Children.Add(this.ARMLONGbtn);

                // ARM SHORT Button
                this.ARMSHORTbtn = new Button
                {
                    Content = "Arm Short",
                    Name = "ShortArmButton",
                    Height = 30.0,
                    Width = 125.0,
                    Margin = new Thickness(0.0, 4.0, 4.0, 0.0),
                    Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Style = style
                };
                this.ARMSHORTbtn.Background = Brushes.Gray;
                this.ARMSHORTbtn.BorderBrush = Brushes.DimGray;
                this.ARMSHORTbtn.Foreground = Brushes.White;
                this.ARMSHORTbtn.Click += this.ARMSHORTbtn_Click;
                Grid.SetColumn(this.ARMSHORTbtn, 2);
                Grid.SetRow(this.ARMSHORTbtn, 3);
                grid5.Children.Add(this.ARMSHORTbtn);

                // ARM OPTION Button
                this.ARMOPTIONbtn = new Button
                {
                    Content = "Semi Auto",
                    Name = "ARMOptionButton",
                    Height = 30.0,
                    Width = 125.0,
                    Margin = new Thickness(4.0, 4.0, 0.0, 0.0),
                    Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Style = style
                };
                this.ARMOPTIONbtn.Background = Brushes.Gray;
                this.ARMOPTIONbtn.BorderBrush = Brushes.DimGray;
                this.ARMOPTIONbtn.Foreground = Brushes.White;
                this.ARMOPTIONbtn.Click += this.ARMOPTIONbtn_Click;
                Grid.SetColumn(this.ARMOPTIONbtn, 0);
                Grid.SetRow(this.ARMOPTIONbtn, 4);
                grid5.Children.Add(this.ARMOPTIONbtn);

                // AUTO ARM Button
                this.AUTOArmbtn = new Button
                {
                    Content = "Full Auto",
                    Name = "Continuous",
                    Height = 30.0,
                    Width = 125.0,
                    Margin = new Thickness(0.0, 4.0, 4.0, 0.0),
                    Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Style = style
                };
                this.AUTOArmbtn.Background = Brushes.Gray;
                this.AUTOArmbtn.BorderBrush = Brushes.DimGray;
                this.AUTOArmbtn.Foreground = Brushes.White;
                this.AUTOArmbtn.Click += this.AUTOArmbtn_Click;
                Grid.SetColumn(this.AUTOArmbtn, 2);
                Grid.SetRow(this.AUTOArmbtn, 4);
                grid5.Children.Add(this.AUTOArmbtn);

                // CLOSE Button
                this.Closebtn = new Button
                {
                    Content = "Flatten",
                    Name = "Flatten",
                    Height = 30.0,
                    Margin = new Thickness(4.0, 4.0, 4.0, 0.0),
                    Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Style = style
                };
                this.Closebtn.Background = Brushes.Red;
                this.Closebtn.BorderBrush = Brushes.DimGray;
                this.Closebtn.Foreground = Brushes.White;
                this.Closebtn.Click += this.Closebtn_Click;
                this.Closebtn.PreviewMouseDown += new MouseButtonEventHandler(this.Closebtn_MouseDown);
                this.Closebtn.PreviewMouseUp += new MouseButtonEventHandler(this.Closebtn_MouseUp);
                this.Closebtn.MouseLeave += new MouseEventHandler(this.Closebtn_MouseLeave);
                Grid.SetColumnSpan(this.Closebtn, 3);
                Grid.SetRow(this.Closebtn, 5);
                grid5.Children.Add(this.Closebtn);

                this.tileHolder = new Border
                {
                    Cursor = Cursors.Arrow,
                    Background = (Application.Current.FindResource("BackgroundMainWindow") as System.Windows.Media.Brush),
                    BorderThickness = new Thickness((double)(Application.Current.FindResource("BorderThinThickness") ?? 1)),
                    BorderBrush = (Application.Current.FindResource("BorderThinBrush") as System.Windows.Media.Brush),
                    Child = grid5
                };
                this.grid.Children.Add(this.tileHolder);
                this.hideB.MouseUp += delegate (object sender, MouseButtonEventArgs e)
                {
                    // Toggle visibility of UI elements
                    this.ARMOPTIONbtn.Visibility = this.ARMOPTIONbtn.Visibility == Visibility.Visible ? Visibility.Collapsed : Visibility.Visible;
                    this.ARMSHORTbtn.Visibility = this.ARMSHORTbtn.Visibility == Visibility.Visible ? Visibility.Collapsed : Visibility.Visible;
                    this.ARMLONGbtn.Visibility = this.ARMLONGbtn.Visibility == Visibility.Visible ? Visibility.Collapsed : Visibility.Visible;
                    this.Closebtn.Visibility = this.Closebtn.Visibility == Visibility.Visible ? Visibility.Collapsed : Visibility.Visible;
                    this.AUTOArmbtn.Visibility = this.AUTOArmbtn.Visibility == Visibility.Visible ? Visibility.Collapsed : Visibility.Visible;
                    this.selectedATMStrat.Visibility = this.selectedATMStrat.Visibility == Visibility.Visible ? Visibility.Collapsed : Visibility.Visible;
                    this.ATMLabel.Visibility = this.ATMLabel.Visibility == Visibility.Visible ? Visibility.Collapsed : Visibility.Visible;
                    this.accountSelected.Visibility = this.accountSelected.Visibility == Visibility.Visible ? Visibility.Collapsed : Visibility.Visible;
                    this.ACCOUNTLabel.Visibility = this.ACCOUNTLabel.Visibility == Visibility.Visible ? Visibility.Collapsed : Visibility.Visible;
                    this.moveB.Visibility = this.moveB.Visibility == Visibility.Visible ? Visibility.Collapsed : Visibility.Visible;
                };
                this.grid.Children.Add(this.hideB);
                if (this.IsVisibleOnlyFocused)
                {
                    Binding binding = new Binding("IsActive")
                    {
                        Source = ChartControl.OwnerChart,
                        Converter = (Application.Current.FindResource("BoolToVisConverter") as IValueConverter)
                    };
                    this.grid.SetBinding(UIElement.VisibilityProperty, binding);
                    return this.grid;
                }
            }
            catch (Exception)
            {
            }
            return this.grid;
        }

        private static string CensorString(string input)
        {
            if (input != null && input.Length >= 3)
            {
                if (input.Length > 10)
                {
                    input = input.Substring(0, Math.Min(input.Length, 10));
                }
                else
                {
                    input = input.PadRight(10);
                }
                int count = input.Length - 2;
                string str = new string('*', count);
                return input.Substring(0, 2) + str;
            }
            return input;
        }

        private void resetQuantVal_Click(object sender, EventArgs e)
        {
            int num = 1;
            this.quantityLabelVal.Text = num.ToString();
            this.quantityValue = num;
            this.armOptionBtnToggle = false;
            this.ARMOPTIONbtn.Background = Brushes.Gray;
            this.ARMOPTIONbtn.Foreground = Brushes.White;
            this.ARMOPTIONbtn.Content = "Semi Auto";
            this.autoArmBtnToggle = false;
            this.AUTOArmbtn.Background = Brushes.Gray;
            this.AUTOArmbtn.Foreground = Brushes.White;
            this.AUTOArmbtn.Content = "Full Auto";
            this.armShortBtnToggle = false;
            this.ARMSHORTbtn.Background = Brushes.Gray;
            this.ARMSHORTbtn.Foreground = Brushes.White;
            this.armLongBtnToggle = false;
            this.ARMLONGbtn.Background = Brushes.Gray;
            this.ARMLONGbtn.Foreground = Brushes.White;
        }

        private void increaseQuant_Click(object sender, EventArgs e)
        {
            int num;
            if ((num = this.quantityValue + 1) < 1)
            {
                num = 1;
            }
            else if (num > 50)
            {
                num = 50;
            }
            this.quantityLabelVal.Text = num.ToString();
            this.quantityValue = num;
        }

        private void decreaseQuant_Click(object sender, EventArgs e)
        {
            int num;
            if ((num = this.quantityValue - 1) < 1)
            {
                num = 1;
            }
            else if (num > 50)
            {
                num = 50;
            }
            this.quantityLabelVal.Text = num.ToString();
            this.quantityValue = num;
        }

        private void ACCOUNTSelection_Changed(object sender, EventArgs e)
        {
            bool flag = false;
            lock (Connection.Connections)
            {
                foreach (Connection connection in Connection.Connections)
                {
                    if (connection.Status == ConnectionStatus.Connected)
                    {
                        flag = true;
                        break;
                    }
                }
            }
            if (!flag)
            {
                this.accountSelected.Content = "Disconnected";
                return;
            }
            if (this.accountSelector != null)
            {
                if (this.accountSelector.SelectedIndex.ToString() == string.Empty || this.accountSelector.SelectedAccount == null || string.IsNullOrEmpty(this.accountSelector.SelectedAccount.Name))
                {
                    this.accountSelected.Content = "Select Account";
                }
                else
                    this.accountSelected.Content = CensorString(this.accountSelector.SelectedAccount.DisplayName);
            }
        }

        private void TextBox_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            TextBox textBox = sender as TextBox;
            if (textBox != null)
            {
                if ((e.Key >= Key.D0 && e.Key <= Key.D9) || (e.Key >= Key.NumPad0 && e.Key <= Key.NumPad9))
                {
                    int num = (e.Key >= Key.NumPad0) ? (e.Key - Key.NumPad0) : (e.Key - Key.D0);
                    textBox.Text += num.ToString();
                    e.Handled = true;
                    return;
                }
                if (e.Key != Key.Back && e.Key != Key.Delete)
                {
                    if (e.Key != Key.Tab)
                    {
                        if (e.Key == Key.Return)
                        {
                            textBox.Text = textBox.Text;
                            this.quantityValue = int.Parse(textBox.Text);
                            e.Handled = false;
                            return;
                        }
                        e.Handled = true;
                        return;
                    }
                }
                e.Handled = false;
                return;
            }
        }

        private void TextBox_LostFocus(object sender, EventArgs e)
        {
            TextBox textBox = sender as TextBox;
            if (textBox != null)
            {
                textBox.Text = textBox.Text;
                this.quantityValue = int.Parse(textBox.Text);
            }
        }

        private void ATMSelection_Changed(object sender, EventArgs e)
        {
            if (this.selectedATMStrat == null || this.atmSelector.SelectedAtmStrategy == null)
            {
                this.selectedATMStrat.Content = "None";
                return;
            }
            if (!(this.atmSelector.SelectedItem.ToString() != "None"))
            {
                this.selectedATMStrat.Content = "None";
                return;
            }
            Dispatcher.InvokeAsync(delegate ()
            {
                QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
                this.quantityATM = quantityUpDown.Value;
            });
            if (this.atmSelector.SelectedAtmStrategy.DisplayName.Contains("-"))
            {
                this.selectedATMStrat.Content = this.atmSelector.SelectedAtmStrategy.DisplayName;
                return;
            }
            this.selectedATMStrat.Content = this.atmSelector.SelectedAtmStrategy.DisplayName;
        }
        #endregion

        #region Trade Execution Methods
        private void ARMLONGbtn_Click(object sender, RoutedEventArgs e)
        {
            if (!this.armLongBtnToggle)
            {
                this.armLongBtnToggle = true;
                this.onceTriggered = false;
                this.ARMLONGbtn.Background = Brushes.LimeGreen;
                this.ARMLONGbtn.Foreground = Brushes.Black;
                return;
            }
            this.armLongBtnToggle = false;
            this.ARMLONGbtn.Background = Brushes.Gray;
            this.ARMLONGbtn.Foreground = Brushes.White;
        }

        private void onceTriggeredARMLONGbtn()
        {
            this.armLongBtnToggle = false;
            this.ARMLONGbtn.Background = Brushes.Gray;
            this.ARMLONGbtn.Foreground = Brushes.White;
        }

        private void ARMSHORTbtn_Click(object sender, RoutedEventArgs e)
        {
            if (!this.armShortBtnToggle)
            {
                this.armShortBtnToggle = true;
                this.onceTriggered = false;
                this.ARMSHORTbtn.Background = Brushes.LimeGreen;
                this.ARMSHORTbtn.Foreground = Brushes.Black;
                return;
            }
            this.armShortBtnToggle = false;
            this.ARMSHORTbtn.Background = Brushes.Gray;
            this.ARMSHORTbtn.Foreground = Brushes.White;
        }

        private void onceTriggeredARMSHORTbtn()
        {
            this.armShortBtnToggle = false;
            this.ARMSHORTbtn.Background = Brushes.Gray;
            this.ARMSHORTbtn.Foreground = Brushes.White;
        }

        private void ARMOPTIONbtn_Click(object sender, RoutedEventArgs e)
        {
            if (!this.armOptionBtnToggle)
            {
                this.armOptionBtnToggle = true;
                this.ARMOPTIONbtn.Background = Brushes.DodgerBlue;
                this.ARMOPTIONbtn.Foreground = Brushes.White;
                this.ARMOPTIONbtn.Content = "Semi Auto - On";
                this.autoArmBtnToggle = false;
                this.AUTOArmbtn.Background = Brushes.Gray;
                this.AUTOArmbtn.Foreground = Brushes.White;
                this.AUTOArmbtn.Content = "Full Auto";
                return;
            }
            this.armOptionBtnToggle = false;
            this.ARMOPTIONbtn.Background = Brushes.Gray;
            this.ARMOPTIONbtn.Foreground = Brushes.White;
            this.ARMOPTIONbtn.Content = "Semi Auto";
        }

        private void AUTOArmbtn_Click(object sender, RoutedEventArgs e)
        {
            if (!this.autoArmBtnToggle)
            {
                this.autoArmBtnToggle = true;
                this.AUTOArmbtn.Background = Brushes.DodgerBlue;
                this.AUTOArmbtn.Foreground = Brushes.White;
                this.AUTOArmbtn.Content = "Full Auto - On";
                this.armOptionBtnToggle = false;
                this.ARMOPTIONbtn.Background = Brushes.Gray;
                this.ARMOPTIONbtn.Foreground = Brushes.White;
                this.ARMOPTIONbtn.Content = "Semi Auto";
                return;
            }
            this.autoArmBtnToggle = false;
            this.AUTOArmbtn.Background = Brushes.Gray;
            this.AUTOArmbtn.Foreground = Brushes.White;
            this.AUTOArmbtn.Content = "Full Auto";
        }

        private void Closebtn_Click(object sender, RoutedEventArgs e)
        {
            this.CloseTrades(true);
            this.autoArmBtnToggle = false;
            this.AUTOArmbtn.Background = Brushes.Gray;
            this.AUTOArmbtn.Foreground = Brushes.White;
            this.AUTOArmbtn.Content = "Full Auto";
            this.armOptionBtnToggle = false;
            this.ARMOPTIONbtn.Background = Brushes.Gray;
            this.ARMOPTIONbtn.Foreground = Brushes.White;
            this.ARMOPTIONbtn.Content = "Semi Auto";
            this.armShortBtnToggle = false;
            this.ARMSHORTbtn.Background = Brushes.Gray;
            this.ARMSHORTbtn.Foreground = Brushes.White;
            this.armLongBtnToggle = false;
            this.ARMLONGbtn.Background = Brushes.Gray;
            this.ARMLONGbtn.Foreground = Brushes.White;
        }

        private void Closebtn_MouseDown(object sender, RoutedEventArgs e)
        {
            if (this.Closebtn.IsMouseOver)
            {
                this.Closebtn.Background = Brushes.Maroon;
            }
            this.Closebtn.Background = Brushes.Maroon;
            this.Closebtn.FontStyle = FontStyles.Oblique;
        }

        private void Closebtn_MouseUp(object sender, RoutedEventArgs e)
        {
            this.Closebtn.Background = Brushes.Red;
            this.Closebtn.FontStyle = FontStyles.Normal;
        }

        private void Closebtn_MouseLeave(object sender, RoutedEventArgs e)
        {
            this.Closebtn.Background = Brushes.Red;
        }

		private void takeTrade(int direction)
{
    if (State != State.Realtime || !connected)
        return;

    // If not in position, must have at least one arm toggle on to take the initial trade.
    if (!inPosition && !armLongBtnToggle && !armShortBtnToggle)
        return;

    AtmStrategy atmStrategy = null;
    object atmSelChoice = null;

    ChartControl.Dispatcher.Invoke(delegate()
    {
        AtmStrategySelector atmStrategySelector = Extensions.FindFirst(Window.GetWindow(this.ChartControl.Parent), "ChartTraderControlATMStrategySelector") as AtmStrategySelector;
        atmSelChoice = ((atmStrategySelector != null) ? atmStrategySelector.SelectedItem : null);
    });

    ChartControl.Dispatcher.Invoke(delegate()
    {
        QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
        this.quantityATM = quantityUpDown.Value;
    });

    int quantity = this.quantityValue;
    this.Dispatcher.InvokeAsync((Action)(() => quantity = this.quantityValue));

    if (this.chartTraderAccount == null || atmSelChoice == null)
        return;

    if (atmSelChoice.ToString() != "None")
        atmStrategy = (NinjaTrader.NinjaScript.AtmStrategy)atmSelChoice;

    // ---------------------------------
    // Flatten-before-reverse logic
    if (inPosition && ((direction > 0 && posDirection < 0) || (direction < 0 && posDirection > 0)))
    {
        CloseTrades(false);
    }
    // ---------------------------------

    // Full auto mode logic
    if (!this.armOptionBtnToggle && this.autoArmBtnToggle && (this.armLongBtnToggle || this.armShortBtnToggle))
    {
        // Full auto mode
        if (!this.inPosition)
        {
            // Initial entry conditions
            if (direction > 0 && this.armLongBtnToggle)
            {
                if (atmStrategy != null && atmSelChoice.ToString() != "None")
                {
                    for (int index = 0; index < quantity; ++index)
                    {
                        try
                        {
                            Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                            NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                        }
                        catch (Exception) { }
                    }
                    return;
                }

                if (atmSelChoice.ToString() == "None" && atmStrategy == null)
                {
                    this.chartTraderAccount.Submit(new Order[1]
                    {
                        this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                    });
                    return;
                }
            }
            else if (direction < 0 && this.armShortBtnToggle)
            {
                if (atmStrategy != null && atmSelChoice.ToString() != "None")
                {
                    for (int index = 0; index < quantity; ++index)
                    {
                        try
                        {
                            Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                            NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                        }
                        catch (Exception) { }
                    }
                    return;
                }

                if (atmSelChoice.ToString() == "None" && atmStrategy == null)
                {
                    this.chartTraderAccount.Submit(new Order[1]
                    {
                        this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                    });
                    return;
                }
            }
        }

        // If already in position and posDirection == -1 (short) and direction > 0 -> reversing from short to long
        if (this.inPosition && this.posDirection == -1)
        {
            if (direction > 0 && this.armLongBtnToggle)
            {
                if (atmStrategy != null && atmSelChoice.ToString() != "None")
                {
                    for (int index = 0; index < quantity; ++index)
                    {
                        try
                        {
                            Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                            NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                        }
                        catch (Exception) { }
                    }
                    return;
                }

                if (atmSelChoice.ToString() == "None" && atmStrategy == null)
                {
                    this.chartTraderAccount.Submit(new Order[1]
                    {
                        this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                    });
                    return;
                }
            }
            else if (this.armShortBtnToggle && direction < 0)
            {
                if (atmStrategy != null && atmSelChoice.ToString() != "None")
                {
                    for (int index = 0; index < quantity; ++index)
                    {
                        Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                        NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                    }
                    return;
                }

                if (atmSelChoice.ToString() == "None" && atmStrategy == null)
                {
                    this.chartTraderAccount.Submit(new Order[1]
                    {
                        this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                    });
                    return;
                }
            }
        }

        if (!this.inPosition || this.posDirection != 1)
            return;

        // If currently long and direction < 0
        if (direction < 0 && this.armShortBtnToggle)
        {
            if (atmStrategy != null && atmSelChoice.ToString() != "None")
            {
                for (int index = 0; index < quantity; ++index)
                {
                    try
                    {
                        Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                        NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                    }
                    catch (Exception) { }
                }
            }
            else
            {
                if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
                    return;

                this.chartTraderAccount.Submit(new Order[1]
                {
                    this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                });
            }
        }
        else
        {
            if (!this.armLongBtnToggle || direction <= 0)
                return;

            if (atmStrategy != null && atmSelChoice.ToString() != "None")
            {
                for (int index = 0; index < quantity; ++index)
                {
                    Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                }
            }
            else
            {
                if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
                    return;

                this.chartTraderAccount.Submit(new Order[1]
                {
                    this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                });
            }
        }
    }
    else
    {
        // Semi-auto / onceTriggered logic
        if (this.autoArmBtnToggle || !this.armOptionBtnToggle || this.onceTriggered || (!this.armLongBtnToggle && !this.armShortBtnToggle))
            return;

        if (!this.inPosition)
        {
            if (direction > 0 && this.armLongBtnToggle)
            {
                if (atmStrategy != null && atmSelChoice.ToString() != "None")
                {
                    for (int index = 0; index < quantity; ++index)
                    {
                        try
                        {
                            Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                            NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                        }
                        catch (Exception) { }
                    }

                    ChartControl.Dispatcher.InvokeAsync(delegate()
                    {
                        this.onceTriggeredARMLONGbtn();
                        this.onceTriggeredARMSHORTbtn();
                        this.onceTriggered = true;
                    });
                    return;
                }

                if (atmSelChoice.ToString() == "None" && atmStrategy == null)
                {
                    this.chartTraderAccount.Submit(new Order[1]
                    {
                        this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                    });

                    ChartControl.Dispatcher.InvokeAsync(delegate()
                    {
                        this.onceTriggeredARMLONGbtn();
                        this.onceTriggeredARMSHORTbtn();
                        this.onceTriggered = true;
                    });
                    return;
                }
            }
            else if (direction < 0 && this.armShortBtnToggle)
            {
                if (atmStrategy != null && atmSelChoice.ToString() != "None")
                {
                    for (int index = 0; index < quantity; ++index)
                    {
                        try
                        {
                            Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                            NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                        }
                        catch (Exception) { }
                    }

                    ChartControl.Dispatcher.InvokeAsync(delegate()
                    {
                        this.onceTriggeredARMLONGbtn();
                        this.onceTriggeredARMSHORTbtn();
                        this.onceTriggered = true;
                    });
                    return;
                }

                if (atmSelChoice.ToString() == "None" && atmStrategy == null)
                {
                    this.chartTraderAccount.Submit(new Order[1]
                    {
                        this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                    });

                    ChartControl.Dispatcher.InvokeAsync(delegate()
                    {
                        this.onceTriggeredARMLONGbtn();
                        this.onceTriggeredARMSHORTbtn();
                        this.onceTriggered = true;
                    });
                    return;
                }
            }
        }

        if (this.inPosition && this.posDirection == -1)
        {
            if (direction > 0 && this.armLongBtnToggle)
            {
                // If reversing direction:
                if (direction > 0 && posDirection < 0)
                    CloseTrades(false);

                if (atmStrategy != null && atmSelChoice.ToString() != "None")
                {
                    for (int index = 0; index < quantity; ++index)
                    {
                        try
                        {
                            Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                            NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                        }
                        catch (Exception) { }
                    }

                    ChartControl.Dispatcher.InvokeAsync(delegate()
                    {
                        this.onceTriggeredARMLONGbtn();
                        this.onceTriggeredARMSHORTbtn();
                        this.onceTriggered = true;
                    });
                    return;
                }

                if (atmSelChoice.ToString() == "None" && atmStrategy == null)
                {
                    this.chartTraderAccount.Submit(new Order[1]
                    {
                        this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                    });

                    ChartControl.Dispatcher.InvokeAsync(delegate()
                    {
                        this.onceTriggeredARMLONGbtn();
                        this.onceTriggeredARMSHORTbtn();
                        this.onceTriggered = true;
                    });
                    return;
                }
            }
            else if (this.armShortBtnToggle && direction < 0)
            {
                // Continuing short position
                if (atmStrategy != null && atmSelChoice.ToString() != "None")
                {
                    for (int index = 0; index < quantity; ++index)
                    {
                        Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                        NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                    }

                    ChartControl.Dispatcher.InvokeAsync(delegate()
                    {
                        this.onceTriggeredARMLONGbtn();
                        this.onceTriggeredARMSHORTbtn();
                        this.onceTriggered = true;
                    });
                    return;
                }

                if (atmSelChoice.ToString() == "None" && atmStrategy == null)
                {
                    this.chartTraderAccount.Submit(new Order[1]
                    {
                        this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                    });

                    ChartControl.Dispatcher.InvokeAsync(delegate()
                    {
                        this.onceTriggeredARMLONGbtn();
                        this.onceTriggeredARMSHORTbtn();
                        this.onceTriggered = true;
                    });
                    return;
                }
            }
        }

        if (!this.inPosition || this.posDirection != 1)
            return;

        if (direction < 0 && this.armShortBtnToggle)
        {
            // Reversing from long to short
            if (direction < 0 && posDirection > 0)
                CloseTrades(false);

            if (atmStrategy != null && atmSelChoice.ToString() != "None")
            {
                for (int index = 0; index < quantity; ++index)
                {
                    try
                    {
                        Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                        NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                    }
                    catch (Exception) { }
                }

                ChartControl.Dispatcher.InvokeAsync(delegate()
                {
                    this.onceTriggeredARMLONGbtn();
                    this.onceTriggeredARMSHORTbtn();
                    this.onceTriggered = true;
                });
            }
            else
            {
                if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
                    return;

                this.chartTraderAccount.Submit(new Order[1]
                {
                    this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                });

                ChartControl.Dispatcher.InvokeAsync(delegate()
                {
                    this.onceTriggeredARMLONGbtn();
                    this.onceTriggeredARMSHORTbtn();
                    this.onceTriggered = true;
                });
            }
        }
        else
        {
            if (!this.armLongBtnToggle || direction <= 0)
                return;

            if (atmStrategy != null && atmSelChoice.ToString() != "None")
            {
                for (int index = 0; index < quantity; ++index)
                {
                    Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                }

                ChartControl.Dispatcher.InvokeAsync(delegate()
                {
                    this.onceTriggeredARMLONGbtn();
                    this.onceTriggeredARMSHORTbtn();
                    this.onceTriggered = true;
                });
            }
            else
            {
                if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
                    return;

                this.chartTraderAccount.Submit(new Order[1]
                {
                    this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Manual, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                });

                ChartControl.Dispatcher.InvokeAsync(delegate()
                {
                    this.onceTriggeredARMLONGbtn();
                    this.onceTriggeredARMSHORTbtn();
                    this.onceTriggered = true;
                });
            }
        }
    }
}

/*
        private void SubmitTrade(int direction, AtmStrategy atmStrategy, string atmSelChoice, int quantity, bool closeFirst = false)
        {
            if (closeFirst)
            {
                CloseTrades(false);
            }

            if (direction > 0 && this.armLongBtnToggle)
            {
                if (atmStrategy != null && atmSelChoice != "None")
                {
                    for (int i = 0; i < quantity; i++)
                    {
                        try
                        {
                            Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Signal, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                            NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                        }
                        catch { }
                    }
                }
                else
                {
                    this.chartTraderAccount.Submit(new Order[1]
                    {
                        this.chartTraderAccount.CreateOrder(this.inst, OrderAction.Buy, OrderType.Market, OrderEntry.Signal, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                    });
                }
            }
            else if (direction < 0 && this.armShortBtnToggle)
            {
                if (atmStrategy != null && atmSelChoice != "None")
                {
                    for (int i = 0; i < quantity; i++)
                    {
                        try
                        {
                            Order order = this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Signal, TimeInForce.Day, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, null);
                            NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
                        }
                        catch { }
                    }
                }
                else
                {
                    this.chartTraderAccount.Submit(new Order[1]
                    {
                        this.chartTraderAccount.CreateOrder(this.inst, OrderAction.SellShort, OrderType.Market, OrderEntry.Signal, TimeInForce.Day, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, null)
                    });
                }
            }
        }
*/
        private void CloseTrades(bool yn)
	    {
	     if (yn)
			{
				List<Instrument> instrumentNames = new List<Instrument>();
				Dispatcher.BeginInvoke(new Action(delegate()
	        {
	          try
	          {
	            if (this.chartTraderAccount.Positions.Count == 0)
	              return;
	            foreach (Position position in this.chartTraderAccount.Positions)
	            {
	              Instrument instrument = position.Instrument;
	              if (!instrumentNames.Contains(instrument))
	                instrumentNames.Add(instrument);
	            }
	            this.chartTraderAccount.Flatten((ICollection<Instrument>) instrumentNames);
	            Thread.Sleep(250);
	          }
	          catch (Exception ex)
	          {
	          }
	        }));
	      }
	      else
	      {
	        if (this.inPosition && this.posDirection == -1)
	        {
	          int quantity = this.positions.Quantity;
	          int num = 0;
	          this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	          {
	            this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 1, (OrderType) 1, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "Entry", (CustomOrder) null)
	          });
	          foreach (Order order in this.chartTraderAccount.Orders)
	          {
	            if (order.Instrument == this.inst && order.OrderType == null && order.OrderState == (OrderState)10 && num < quantity)
	            {
	              ++num;
	              this.chartTraderAccount.Cancel((IEnumerable<Order>) new Order[1]
	              {
	                order
	              });
	            }
	          }
	        }
	        if (!this.inPosition || this.posDirection != 1)
	          return;
	        int quantity1 = this.positions.Quantity;
	        int num1 = 0;
	        this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	        {
	          this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (TimeInForce) 1, quantity1, 0.0, 0.0, string.Empty, "Entry", (CustomOrder) null)
	        });
	        foreach (Order order in this.chartTraderAccount.Orders)
	        {
	          if (order.Instrument == this.inst && order.OrderType == null && order.OrderState == (OrderState)10 && num1 < quantity1)
	          {
	            ++num1;
	            this.chartTraderAccount.Cancel((IEnumerable<Order>) new Order[1]
	            {
	              order
	            });
	          }
	        }
	      }
	    }

        private Position getInstrumentPosition()
        {
            long instrumentId = this.inst == null ? -1 : this.inst.Id;
            if (instrumentId == -1) return null;
            Position pos = null;
            Account myAccount = null;
            try
            {
                ChartControl.Dispatcher.Invoke(delegate ()
                {
                    lock (Account.All)
                    {
                        myAccount = Account.All.FirstOrDefault((Account a) => a.Name == this.accountSelector?.SelectedAccount?.DisplayName);
                    }
                    if (myAccount != null)
                    {
                        pos = myAccount.GetPosition(instrumentId);
                        realizedPnL = myAccount.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar);
                    }
                });
                if (pos == null)
                {
                    inPosition = false;
                    posDirection = 0;
                    positions = null;
                    return null;
                }
                if (pos != null)
                {
                    inPosition = true;
                    positions = pos;
                    if (pos.MarketPosition == MarketPosition.Short)
                        posDirection = -1;
                    else if (pos.MarketPosition == MarketPosition.Long)
                        posDirection = 1;
                    else
                        posDirection = 0;
                    return pos;
                }
            }
            catch (Exception)
            {
            }
            return pos;
        }

        private void acctCallback(object o)
        {
            try
            {
                ChartControl.Dispatcher.Invoke(delegate ()
                {
                    AccountSelector accountSelector = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlAccountSelector") as AccountSelector;
                    this.chartTraderAccount = ((accountSelector != null) ? accountSelector.SelectedAccount : null);
                    this.accountSelector = ((accountSelector != null) ? accountSelector : null);
                });
                if (this.chartTraderAccount != null && !this.handlerSet)
                {
                    this.handlerSet = true;
                    this.accountSelector.SelectionChanged += new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
                }
            }
            catch (Exception)
            {
            }
        }

        private void posCallback(object o)
        {
            long id = this.inst == null ? -1 : this.inst.Id;
            if (id == -1) return;
            Position position = null;
            Account account = null;
            try
            {
                lock (Account.All)
                {
                    account = Account.All.FirstOrDefault((Account a) => a.Name == this.chartTraderAccount?.DisplayName);
                }
                if (account != null)
                {
                    position = account.GetPosition(id);
                    realizedPnL = account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar);
                }
            }
            catch (Exception)
            {
            }
            if (account == null || position == null)
            {
                inPosition = false;
                posDirection = 0;
                positions = null;
            }
            else
            {
                inPosition = true;
                positions = position;
                if (position.MarketPosition == MarketPosition.Short)
                    posDirection = -1;
                else if (position.MarketPosition == MarketPosition.Long)
                    posDirection = 1;
                else
                    posDirection = 0;
            }
        }
        #endregion

        protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
        {
        }

        public override void OnRenderTargetChanged()
        {
        }

        #region Properties

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Resource), Name = "NinjaScriptIsVisibleOnlyFocused", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 499)]
        [Browsable(false)]
        public bool IsVisibleOnlyFocused { get; set; }

        [Browsable(false)]
        public double Top { get; set; }

        [Browsable(false)]
        public double Left { get; set; }

        [Browsable(false)]
        public XElement SelectedTypes { get; set; }

        [Display(ResourceType = typeof(Resource), Name = "NinjaScriptNumberOfRows", GroupName = "NinjaScriptParameters", Order = 0)]
        [Range(1, 2147483647)]
        [Browsable(false)]
        public int NumberOfRows { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Profit Target", GroupName = "Total Strategy Profit Target / StopLoss", Order = 0)]
        public int realizedProfit { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "StopLoss (Negative Number)", GroupName = "Total Strategy Profit Target / StopLoss", Order = 0)]
        public int realizedLoss { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Start Time", GroupName = "Time Settings HHMMSS Format", Order = 2)]
        public int startTime { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "End Time", GroupName = "Time Settings HHMMSS Format", Order = 3)]
        public int endTime { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Econ1 Time", GroupName = "Time Settings HHMMSS Format", Order = 6)]
        public int econNumber1 { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Econ2 Time", GroupName = "Time Settings HHMMSS Format", Order = 7)]
        public int econNumber2 { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Market Open Time", GroupName = "Time Settings HHMMSS Format", Order = 1)]
        public int openTime { get; set; }

        [Display(Name = "Set Account For PNL Tracking", GroupName = "Performance", Order = 1)]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.AccountNameConverter))]
        public string AccountName { get; set; }

        // Fisher parameters
        [NinjaScriptProperty]
        [Range(2, int.MaxValue)]
        [Display(Name="FisherLength", Order=1, GroupName="Fisher Parameters")]
        public int FisherLength { get; set; }

        [NinjaScriptProperty]
        [Range(2, int.MaxValue)]
        [Display(Name="ATRPeriod", Order=2, GroupName="Fisher Parameters")]
        public int ATRPeriod { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name="MomentumPeriod", Order=3, GroupName="Fisher Parameters")]
        public int MomentumPeriod { get; set; }

        [NinjaScriptProperty]
        [Display(Name="ATRThresholdMultiplier", Order=4, GroupName="Fisher Parameters")]
        public double ATRThresholdMultiplier { get; set; }

        [NinjaScriptProperty]
        [Range(0.0, double.MaxValue)]
        [Display(Name="SmoothingFactor", Order=5, GroupName="Fisher Parameters")]
        public double FisherSmoothingFactor { get; set; }

        [NinjaScriptProperty]
        [Display(Name="ShowArrows", Order=6, GroupName="Fisher Parameters")]
        public bool FisherShowArrows { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name="BarThreshold", Order=7, GroupName="Fisher Parameters")]
        public int FisherBarThreshold { get; set; }

        #endregion
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MarketMaestro[] cacheMarketMaestro;
		public MarketMaestro MarketMaestro(bool isVisibleOnlyFocused, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int fisherLength, int aTRPeriod, int momentumPeriod, double aTRThresholdMultiplier, double fisherSmoothingFactor, bool fisherShowArrows, int fisherBarThreshold)
		{
			return MarketMaestro(Input, isVisibleOnlyFocused, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, fisherLength, aTRPeriod, momentumPeriod, aTRThresholdMultiplier, fisherSmoothingFactor, fisherShowArrows, fisherBarThreshold);
		}

		public MarketMaestro MarketMaestro(ISeries<double> input, bool isVisibleOnlyFocused, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int fisherLength, int aTRPeriod, int momentumPeriod, double aTRThresholdMultiplier, double fisherSmoothingFactor, bool fisherShowArrows, int fisherBarThreshold)
		{
			if (cacheMarketMaestro != null)
				for (int idx = 0; idx < cacheMarketMaestro.Length; idx++)
					if (cacheMarketMaestro[idx] != null && cacheMarketMaestro[idx].IsVisibleOnlyFocused == isVisibleOnlyFocused && cacheMarketMaestro[idx].realizedProfit == realizedProfit && cacheMarketMaestro[idx].realizedLoss == realizedLoss && cacheMarketMaestro[idx].startTime == startTime && cacheMarketMaestro[idx].endTime == endTime && cacheMarketMaestro[idx].econNumber1 == econNumber1 && cacheMarketMaestro[idx].econNumber2 == econNumber2 && cacheMarketMaestro[idx].openTime == openTime && cacheMarketMaestro[idx].FisherLength == fisherLength && cacheMarketMaestro[idx].ATRPeriod == aTRPeriod && cacheMarketMaestro[idx].MomentumPeriod == momentumPeriod && cacheMarketMaestro[idx].ATRThresholdMultiplier == aTRThresholdMultiplier && cacheMarketMaestro[idx].FisherSmoothingFactor == fisherSmoothingFactor && cacheMarketMaestro[idx].FisherShowArrows == fisherShowArrows && cacheMarketMaestro[idx].FisherBarThreshold == fisherBarThreshold && cacheMarketMaestro[idx].EqualsInput(input))
						return cacheMarketMaestro[idx];
			return CacheIndicator<MarketMaestro>(new MarketMaestro(){ IsVisibleOnlyFocused = isVisibleOnlyFocused, realizedProfit = realizedProfit, realizedLoss = realizedLoss, startTime = startTime, endTime = endTime, econNumber1 = econNumber1, econNumber2 = econNumber2, openTime = openTime, FisherLength = fisherLength, ATRPeriod = aTRPeriod, MomentumPeriod = momentumPeriod, ATRThresholdMultiplier = aTRThresholdMultiplier, FisherSmoothingFactor = fisherSmoothingFactor, FisherShowArrows = fisherShowArrows, FisherBarThreshold = fisherBarThreshold }, input, ref cacheMarketMaestro);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MarketMaestro MarketMaestro(bool isVisibleOnlyFocused, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int fisherLength, int aTRPeriod, int momentumPeriod, double aTRThresholdMultiplier, double fisherSmoothingFactor, bool fisherShowArrows, int fisherBarThreshold)
		{
			return indicator.MarketMaestro(Input, isVisibleOnlyFocused, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, fisherLength, aTRPeriod, momentumPeriod, aTRThresholdMultiplier, fisherSmoothingFactor, fisherShowArrows, fisherBarThreshold);
		}

		public Indicators.MarketMaestro MarketMaestro(ISeries<double> input , bool isVisibleOnlyFocused, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int fisherLength, int aTRPeriod, int momentumPeriod, double aTRThresholdMultiplier, double fisherSmoothingFactor, bool fisherShowArrows, int fisherBarThreshold)
		{
			return indicator.MarketMaestro(input, isVisibleOnlyFocused, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, fisherLength, aTRPeriod, momentumPeriod, aTRThresholdMultiplier, fisherSmoothingFactor, fisherShowArrows, fisherBarThreshold);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MarketMaestro MarketMaestro(bool isVisibleOnlyFocused, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int fisherLength, int aTRPeriod, int momentumPeriod, double aTRThresholdMultiplier, double fisherSmoothingFactor, bool fisherShowArrows, int fisherBarThreshold)
		{
			return indicator.MarketMaestro(Input, isVisibleOnlyFocused, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, fisherLength, aTRPeriod, momentumPeriod, aTRThresholdMultiplier, fisherSmoothingFactor, fisherShowArrows, fisherBarThreshold);
		}

		public Indicators.MarketMaestro MarketMaestro(ISeries<double> input , bool isVisibleOnlyFocused, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int fisherLength, int aTRPeriod, int momentumPeriod, double aTRThresholdMultiplier, double fisherSmoothingFactor, bool fisherShowArrows, int fisherBarThreshold)
		{
			return indicator.MarketMaestro(input, isVisibleOnlyFocused, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, fisherLength, aTRPeriod, momentumPeriod, aTRThresholdMultiplier, fisherSmoothingFactor, fisherShowArrows, fisherBarThreshold);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Accumulation/Distribution (AD) study attempts to quantify the amount of volume flowing into or
	/// out of an instrument by identifying the position of the close of the period in relation to that period's high/low range.
	/// </summary>
	public class ADL : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= Custom.Resource.NinjaScriptIndicatorDescriptionADL;
				Name						= Custom.Resource.NinjaScriptIndicatorNameADL;
				IsSuspendedWhileInactive	= true;
				DrawOnPricePanel			= false;
				AddPlot(Brushes.DarkCyan, Custom.Resource.ADLAD);
			}
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}
		protected override void OnBarUpdate()
		{
			double high0	= High[0];
			double low0		= Low[0];
			double close0	= Close[0];
			double volume0  = Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0];

			AD[0] = ((CurrentBar == 0 ? 0 : AD[1]) + (high0.ApproxCompare(low0) != 0 ? (((close0 - low0) - (high0 - close0)) / (high0 - low0)) * volume0 : 0));
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> AD
		{
			get { return Values[0]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ADL[] cacheADL;
		public ADL ADL()
		{
			return ADL(Input);
		}

		public ADL ADL(ISeries<double> input)
		{
			if (cacheADL != null)
				for (int idx = 0; idx < cacheADL.Length; idx++)
					if (cacheADL[idx] != null &&  cacheADL[idx].EqualsInput(input))
						return cacheADL[idx];
			return CacheIndicator<ADL>(new ADL(), input, ref cacheADL);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ADL ADL()
		{
			return indicator.ADL(Input);
		}

		public Indicators.ADL ADL(ISeries<double> input )
		{
			return indicator.ADL(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ADL ADL()
		{
			return indicator.ADL(Input);
		}

		public Indicators.ADL ADL(ISeries<double> input )
		{
			return indicator.ADL(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Average Directional Index measures the strength of a prevailing trend as well as whether movement
	/// exists in the market. The ADX is measured on a scale of 0  100. A low ADX value (generally less than 20)
	/// can indicate a non-trending market with low volumes whereas a cross above 20 may indicate the start of
	///  a trend (either up or down). If the ADX is over 40 and begins to fall, it can indicate the slowdown of a current trend.
	/// </summary>
	public class ADX : Indicator
	{
		private Series<double>		dmPlus;
		private Series<double>		dmMinus;
		private Series<double>		sumDmPlus;
		private Series<double>		sumDmMinus;
		private Series<double>		sumTr;
		private Series<double>		tr;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionADX;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameADX;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.DarkCyan,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameADX);
				AddLine(Brushes.SlateBlue,	25,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.Goldenrod,	75,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
			else if (State == State.DataLoaded)
			{
				dmPlus		= new Series<double>(this);
				dmMinus		= new Series<double>(this);
				sumDmPlus	= new Series<double>(this);
				sumDmMinus	= new Series<double>(this);
				sumTr		= new Series<double>(this);
				tr			= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			double high0	= High[0];
			double low0		= Low[0];

			if (CurrentBar == 0)
			{
				tr[0]				= high0 - low0;
				dmPlus[0]			= 0;
				dmMinus[0]			= 0;
				sumTr[0]			= tr[0];
				sumDmPlus[0]		= dmPlus[0];
				sumDmMinus[0]		= dmMinus[0];
				Value[0]			= 50;
			}
			else
			{
				double high1		= High[1];
				double low1			= Low[1];
				double close1		= Close[1];

				tr[0]				= Math.Max(Math.Abs(low0 - close1), Math.Max(high0 - low0, Math.Abs(high0 - close1)));
				dmPlus[0]			= high0 - high1 > low1 - low0 ? Math.Max(high0 - high1, 0) : 0;
				dmMinus[0]			= low1 - low0 > high0 - high1 ? Math.Max(low1 - low0, 0) : 0;

				if (CurrentBar < Period)
				{
					sumTr[0]		= sumTr[1] + tr[0];
					sumDmPlus[0]	= sumDmPlus[1] + dmPlus[0];
					sumDmMinus[0]	= sumDmMinus[1] + dmMinus[0];
				}
				else
				{
					double sumTr1		= sumTr[1];
					double sumDmPlus1	= sumDmPlus[1];
					double sumDmMinus1	= sumDmMinus[1];

					sumTr[0]			= sumTr1 - sumTr1 / Period + tr[0];
					sumDmPlus[0]		= sumDmPlus1 - sumDmPlus1 / Period + dmPlus[0];
					sumDmMinus[0]		= sumDmMinus1 - sumDmMinus1 / Period + dmMinus[0];
				}

				double sumTr0		= sumTr[0];
				double diPlus		= 100 * (sumTr0.ApproxCompare(0) == 0 ? 0 : sumDmPlus[0] / sumTr[0]);
				double diMinus		= 100 * (sumTr0.ApproxCompare(0) == 0 ? 0 : sumDmMinus[0] / sumTr[0]);
				double diff			= Math.Abs(diPlus - diMinus);
				double sum			= diPlus + diMinus;

				Value[0]			= sum.ApproxCompare(0) == 0 ? 50 : ((Period - 1) * Value[1] + 100 * diff / sum) / Period;
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ADX[] cacheADX;
		public ADX ADX(int period)
		{
			return ADX(Input, period);
		}

		public ADX ADX(ISeries<double> input, int period)
		{
			if (cacheADX != null)
				for (int idx = 0; idx < cacheADX.Length; idx++)
					if (cacheADX[idx] != null && cacheADX[idx].Period == period && cacheADX[idx].EqualsInput(input))
						return cacheADX[idx];
			return CacheIndicator<ADX>(new ADX(){ Period = period }, input, ref cacheADX);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ADX ADX(int period)
		{
			return indicator.ADX(Input, period);
		}

		public Indicators.ADX ADX(ISeries<double> input , int period)
		{
			return indicator.ADX(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ADX ADX(int period)
		{
			return indicator.ADX(Input, period);
		}

		public Indicators.ADX ADX(ISeries<double> input , int period)
		{
			return indicator.ADX(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Average Directional Movement Rating quantifies momentum change in the ADX.
	/// It is calculated by adding two values of ADX (the current value and a value n periods back),
	/// then dividing by two. This additional smoothing makes the ADXR slightly less responsive than ADX.
	/// The interpretation is the same as the ADX; the higher the value, the stronger the trend.
	/// </summary>
	public class ADXR : Indicator
	{
		private ADX adx;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionADXR;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameADXR;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				Interval					= 10;

				AddPlot(Brushes.DarkCyan,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameADXR);
				AddLine(Brushes.SlateBlue,	25,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.Goldenrod,	75,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
			else if (State == State.DataLoaded)
				adx = ADX(Period);
		}

		protected override void OnBarUpdate()
		{
			Value[0] = CurrentBar < Interval ? ((adx[0] + adx[CurrentBar]) / 2) : ((adx[0] + adx[Interval]) / 2);
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Interval", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Interval
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ADXR[] cacheADXR;
		public ADXR ADXR(int interval, int period)
		{
			return ADXR(Input, interval, period);
		}

		public ADXR ADXR(ISeries<double> input, int interval, int period)
		{
			if (cacheADXR != null)
				for (int idx = 0; idx < cacheADXR.Length; idx++)
					if (cacheADXR[idx] != null && cacheADXR[idx].Interval == interval && cacheADXR[idx].Period == period && cacheADXR[idx].EqualsInput(input))
						return cacheADXR[idx];
			return CacheIndicator<ADXR>(new ADXR(){ Interval = interval, Period = period }, input, ref cacheADXR);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ADXR ADXR(int interval, int period)
		{
			return indicator.ADXR(Input, interval, period);
		}

		public Indicators.ADXR ADXR(ISeries<double> input , int interval, int period)
		{
			return indicator.ADXR(input, interval, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ADXR ADXR(int interval, int period)
		{
			return indicator.ADXR(Input, interval, period);
		}

		public Indicators.ADXR ADXR(ISeries<double> input , int interval, int period)
		{
			return indicator.ADXR(input, interval, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
// Reference to "Trading with Adaptive Price Zone" article in S&C, September 2006, p. 28 by Lee Leibfarth.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The APZ (Adaptive Prize Zone) forms a steady channel based on double smoothed
	/// exponential moving averages around the average price. See S/C, September 2006, p.28.
	/// </summary>
	public class APZ : Indicator
	{
		private EMA		emaEMA;
		private EMA		emaRange;
		private int		newPeriod;
		private int		period;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionAPZ;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameAPZ;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				BandPct						= 2;
				Period						= 20;

				AddPlot(Brushes.Crimson, NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddPlot(Brushes.Crimson, NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
			else if (State == State.DataLoaded)
			{
				emaEMA		= EMA(EMA(newPeriod), newPeriod);
				emaRange	= EMA(Range(), Period);
				newPeriod	= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < Period)
			{
				Lower[0] = Input[0];
				Upper[0] = Input[0];
				return;
			}

			double rangeOffset	= BandPct * emaRange[0];
			double emaEMA0		= emaEMA[0];

			Lower[0] = emaEMA0 - rangeOffset;
			Upper[0] = emaEMA0 + rangeOffset;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "BandPct", GroupName = "NinjaScriptParameters", Order = 0)]
		public double BandPct
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Lower
		{
			get { return Values[0]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Period
		{
			get { return period; }
			set
			{
				period = value;
				newPeriod = Convert.ToInt32(Math.Sqrt(Convert.ToDouble(value)));
			}
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Upper
		{
			get { return Values[1]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private APZ[] cacheAPZ;
		public APZ APZ(double bandPct, int period)
		{
			return APZ(Input, bandPct, period);
		}

		public APZ APZ(ISeries<double> input, double bandPct, int period)
		{
			if (cacheAPZ != null)
				for (int idx = 0; idx < cacheAPZ.Length; idx++)
					if (cacheAPZ[idx] != null && cacheAPZ[idx].BandPct == bandPct && cacheAPZ[idx].Period == period && cacheAPZ[idx].EqualsInput(input))
						return cacheAPZ[idx];
			return CacheIndicator<APZ>(new APZ(){ BandPct = bandPct, Period = period }, input, ref cacheAPZ);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.APZ APZ(double bandPct, int period)
		{
			return indicator.APZ(Input, bandPct, period);
		}

		public Indicators.APZ APZ(ISeries<double> input , double bandPct, int period)
		{
			return indicator.APZ(input, bandPct, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.APZ APZ(double bandPct, int period)
		{
			return indicator.APZ(Input, bandPct, period);
		}

		public Indicators.APZ APZ(ISeries<double> input , double bandPct, int period)
		{
			return indicator.APZ(input, bandPct, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Aroon Indicator was developed by Tushar Chande. Its comprised of two plots one
	/// measuring the number of periods since the most recent x-period high (Aroon Up) and the
	/// other measuring the number of periods since the most recent x-period low (Aroon Down).
	/// </summary>
	public class Aroon : Indicator
	{
		private double		runningMax;
		private int			runningMaxBar;
		private double		runningMin;
		private int			runningMinBar;
		private int			saveCurrentBar;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionAroon;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameAroon;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.DarkCyan,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorUp);
				AddPlot(Brushes.SlateBlue,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorDown);
				AddLine(Brushes.DarkGray,	30,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.DarkGray,	70,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
			else if (State == State.Configure)
			{
				runningMax		= 0;
				runningMaxBar	= 0;
				runningMin		= 0;
				runningMinBar	= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			double high0	= High[0];
			double low0		= Low[0];

			if (CurrentBar == 0)
			{
				Down[0]			= 0;
				Up[0]			= 0;
				runningMax		= high0;
				runningMin		= low0;
				runningMaxBar	= 0;
				runningMinBar	= 0;
				return;
			}

			int back = Math.Min(Period, CurrentBar);
			if (CurrentBar - runningMaxBar >= Period || CurrentBar < saveCurrentBar)
			{
				runningMax = double.MinValue;
				for (int barsBack = back; barsBack > 0; barsBack--)
					if (High[barsBack] >= runningMax)
					{
						runningMax		= High[barsBack];
						runningMaxBar	= CurrentBar - barsBack;
					}
			}

			if (CurrentBar - runningMinBar >= Period || CurrentBar < saveCurrentBar)
			{
				runningMin = double.MaxValue;
				for (int barsBack = back; barsBack > 0; barsBack--)
					if (Low[barsBack] <= runningMin)
					{
						runningMin		= Low[barsBack];
						runningMinBar	= CurrentBar - barsBack;
					}
			}

			if (high0 >= runningMax)
			{
				runningMax		= high0;
				runningMaxBar	= CurrentBar;
			}

			if (low0 <= runningMin)
			{
				runningMin		= low0;
				runningMinBar	= CurrentBar;
			}

			saveCurrentBar = CurrentBar;

			Up[0] = 100 * ((double)(back - (CurrentBar - runningMaxBar)) / back);
			Down[0] = 100 * ((double)(back - (CurrentBar - runningMinBar)) / back);
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Down
		{
			get { return Values[1]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Up
		{
			get { return Values[0]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Aroon[] cacheAroon;
		public Aroon Aroon(int period)
		{
			return Aroon(Input, period);
		}

		public Aroon Aroon(ISeries<double> input, int period)
		{
			if (cacheAroon != null)
				for (int idx = 0; idx < cacheAroon.Length; idx++)
					if (cacheAroon[idx] != null && cacheAroon[idx].Period == period && cacheAroon[idx].EqualsInput(input))
						return cacheAroon[idx];
			return CacheIndicator<Aroon>(new Aroon(){ Period = period }, input, ref cacheAroon);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Aroon Aroon(int period)
		{
			return indicator.Aroon(Input, period);
		}

		public Indicators.Aroon Aroon(ISeries<double> input , int period)
		{
			return indicator.Aroon(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Aroon Aroon(int period)
		{
			return indicator.Aroon(Input, period);
		}

		public Indicators.Aroon Aroon(ISeries<double> input , int period)
		{
			return indicator.Aroon(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//

#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Aroon Oscillator is based upon his Aroon Indicator. Much like the Aroon Indicator,
	///  the Aroon Oscillator measures the strength of a trend.
	/// </summary>
	public class AroonOscillator : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionAroonOscillator;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameAroonOscillator;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddLine(Brushes.DarkGray,	0,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
				AddPlot(Brushes.Goldenrod,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorUp);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
				Value[0] = 0;
			else
			{
				int back = Math.Min(Period, CurrentBar);
				int idxMax = -1;
				int idxMin = -1;
				double max = double.MinValue;
				double min = double.MaxValue;

				for (int idx = back; idx >= 0; idx--)
				{
					if (High[back - idx].ApproxCompare(max) >= 0)
					{
						max = High[back - idx];
						idxMax = CurrentBar - back + idx;
					}

					if (Low[back - idx].ApproxCompare(min) <= 0)
					{
						min = Low[back - idx];
						idxMin = CurrentBar - back + idx;
					}
				}

				Value[0] = 100 * ((double)(back - (CurrentBar - idxMax)) / back) - 100 * ((double)(back - (CurrentBar - idxMin)) / back);
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private AroonOscillator[] cacheAroonOscillator;
		public AroonOscillator AroonOscillator(int period)
		{
			return AroonOscillator(Input, period);
		}

		public AroonOscillator AroonOscillator(ISeries<double> input, int period)
		{
			if (cacheAroonOscillator != null)
				for (int idx = 0; idx < cacheAroonOscillator.Length; idx++)
					if (cacheAroonOscillator[idx] != null && cacheAroonOscillator[idx].Period == period && cacheAroonOscillator[idx].EqualsInput(input))
						return cacheAroonOscillator[idx];
			return CacheIndicator<AroonOscillator>(new AroonOscillator(){ Period = period }, input, ref cacheAroonOscillator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.AroonOscillator AroonOscillator(int period)
		{
			return indicator.AroonOscillator(Input, period);
		}

		public Indicators.AroonOscillator AroonOscillator(ISeries<double> input , int period)
		{
			return indicator.AroonOscillator(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.AroonOscillator AroonOscillator(int period)
		{
			return indicator.AroonOscillator(Input, period);
		}

		public Indicators.AroonOscillator AroonOscillator(ISeries<double> input , int period)
		{
			return indicator.AroonOscillator(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Average True Range (ATR) is a measure of volatility. It was introduced by Welles Wilder
	/// in his book 'New Concepts in Technical Trading Systems' and has since been used as a component
	/// of many indicators and trading systems.
	/// </summary>
	public class ATR : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionATR;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameATR;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.DarkCyan, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameATR);
			}
		}

		protected override void OnBarUpdate()
		{
			double high0	= High[0];
			double low0		= Low[0];

			if (CurrentBar == 0)
				Value[0] = high0 - low0;
			else
			{
				double close1		= Close[1];
				double trueRange	= Math.Max(Math.Abs(low0 - close1), Math.Max(high0 - low0, Math.Abs(high0 - close1)));
				Value[0]			= ((Math.Min(CurrentBar + 1, Period) - 1 ) * Value[1] + trueRange) / Math.Min(CurrentBar + 1, Period);
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ATR[] cacheATR;
		public ATR ATR(int period)
		{
			return ATR(Input, period);
		}

		public ATR ATR(ISeries<double> input, int period)
		{
			if (cacheATR != null)
				for (int idx = 0; idx < cacheATR.Length; idx++)
					if (cacheATR[idx] != null && cacheATR[idx].Period == period && cacheATR[idx].EqualsInput(input))
						return cacheATR[idx];
			return CacheIndicator<ATR>(new ATR(){ Period = period }, input, ref cacheATR);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ATR ATR(int period)
		{
			return indicator.ATR(Input, period);
		}

		public Indicators.ATR ATR(ISeries<double> input , int period)
		{
			return indicator.ATR(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ATR ATR(int period)
		{
			return indicator.ATR(Input, period);
		}

		public Indicators.ATR ATR(ISeries<double> input , int period)
		{
			return indicator.ATR(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX;
using SharpDX.Direct2D1;
using SharpDX.DirectWrite;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable")]
	public class BarTimer : Indicator
	{
		private string			timeLeft	= string.Empty;
		private DateTime		now		 	= Core.Globals.Now;
		private bool			connected,
								hasRealtimeData;
		private SessionIterator sessionIterator;

		private System.Windows.Threading.DispatcherTimer timer;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description 		= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionBarTimer;
				Name 				= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameBarTimer;
				Calculate			= Calculate.OnEachTick;
				DrawOnPricePanel	= false;
				IsChartOnly			= true;
				IsOverlay			= true;
				DisplayInDataBox	= false;
			}
			else if (State == State.Realtime)
			{
				if (timer == null && IsVisible)
				{
					if (Bars.BarsType.IsTimeBased && Bars.BarsType.IsIntraday)
					{
						lock (Connection.Connections)
						{
							if (Connection.Connections.ToList().FirstOrDefault(c => c.Status == ConnectionStatus.Connected && c.InstrumentTypes.Contains(Instrument.MasterInstrument.InstrumentType)) == null)
								Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.BarTimerDisconnectedError, TextPosition.BottomRight, ChartControl.Properties.ChartText, ChartControl.Properties.LabelFont, Brushes.Transparent, Brushes.Transparent, 0);
							else
							{
								if (!SessionIterator.IsInSession(Now, false, true))
									Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.BarTimerSessionTimeError, TextPosition.BottomRight, ChartControl.Properties.ChartText, ChartControl.Properties.LabelFont, Brushes.Transparent, Brushes.Transparent, 0);
								else
									Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.BarTimerWaitingOnDataError, TextPosition.BottomRight, ChartControl.Properties.ChartText, ChartControl.Properties.LabelFont, Brushes.Transparent, Brushes.Transparent, 0);
							}
						}
					}
					else
						Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.BarTimerTimeBasedError, TextPosition.BottomRight, ChartControl.Properties.ChartText, ChartControl.Properties.LabelFont, Brushes.Transparent, Brushes.Transparent, 0);
				}
			}
			else if (State == State.Terminated)
			{
				if (timer == null)
					return;

				timer.IsEnabled = false;
				timer = null;
			}
		}

		protected override void OnBarUpdate()
		{
			if (State == State.Realtime)
			{
				hasRealtimeData = true;
				connected = true;
			}
		}

		protected override void OnConnectionStatusUpdate(ConnectionStatusEventArgs connectionStatusUpdate)
		{
			if (connectionStatusUpdate.PriceStatus == ConnectionStatus.Connected
				&& connectionStatusUpdate.Connection.InstrumentTypes.Contains(Instrument.MasterInstrument.InstrumentType)
				&& Bars.BarsType.IsTimeBased
				&& Bars.BarsType.IsIntraday)
			{
				connected = true;

				if (DisplayTime() && timer == null)
				{
					ChartControl.Dispatcher.InvokeAsync(() =>
					{
						timer			= new System.Windows.Threading.DispatcherTimer { Interval = new TimeSpan(0, 0, 1), IsEnabled = true };
						timer.Tick		+= OnTimerTick;
					});
				}
			}
			else if (connectionStatusUpdate.PriceStatus == ConnectionStatus.Disconnected)
				connected = false;
		}

		private bool DisplayTime()
		{
			return ChartControl != null
					&& Bars != null
					&& Bars.Instrument.MarketData != null
					&& IsVisible;
		}

		private void OnTimerTick(object sender, EventArgs e)
		{
			ForceRefresh();

			if (DisplayTime())
			{
				if (timer != null && !timer.IsEnabled)
					timer.IsEnabled = true;

				if (connected)
				{
					if (SessionIterator.IsInSession(Now, false, true))
					{
						if (hasRealtimeData)
						{
							TimeSpan barTimeLeft = Bars.GetTime(Bars.Count - 1).Subtract(Now);

							timeLeft = (barTimeLeft.Ticks < 0
								? "00:00:00"
								: barTimeLeft.Hours.ToString("00") + ":" + barTimeLeft.Minutes.ToString("00") + ":" + barTimeLeft.Seconds.ToString("00"));

							Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.BarTimerTimeRemaining + timeLeft, TextPosition.BottomRight, ChartControl.Properties.ChartText, ChartControl.Properties.LabelFont, Brushes.Transparent, Brushes.Transparent, 0);
						}
						else
							Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.BarTimerWaitingOnDataError, TextPosition.BottomRight, ChartControl.Properties.ChartText, ChartControl.Properties.LabelFont, Brushes.Transparent, Brushes.Transparent, 0);
					}
					else
						Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.BarTimerSessionTimeError, TextPosition.BottomRight, ChartControl.Properties.ChartText, ChartControl.Properties.LabelFont, Brushes.Transparent, Brushes.Transparent, 0);
				}
				else
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.BarTimerDisconnectedError, TextPosition.BottomRight, ChartControl.Properties.ChartText, ChartControl.Properties.LabelFont, Brushes.Transparent, Brushes.Transparent, 0);

					if (timer != null)
						timer.IsEnabled = false;
				}
			}
		}

		private SessionIterator SessionIterator
		{
			get
			{
				if (sessionIterator == null)
					sessionIterator = new SessionIterator(Bars);
				return sessionIterator;
			}
		}

		private DateTime Now
		{
			get
			{
				now = (Cbi.Connection.PlaybackConnection != null ? Cbi.Connection.PlaybackConnection.Now : Core.Globals.Now);

				if (now.Millisecond > 0)
					now = Core.Globals.MinDate.AddSeconds((long)Math.Floor(now.Subtract(Core.Globals.MinDate).TotalSeconds));

				return now;
			}
		}
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private BarTimer[] cacheBarTimer;
		public BarTimer BarTimer()
		{
			return BarTimer(Input);
		}

		public BarTimer BarTimer(ISeries<double> input)
		{
			if (cacheBarTimer != null)
				for (int idx = 0; idx < cacheBarTimer.Length; idx++)
					if (cacheBarTimer[idx] != null &&  cacheBarTimer[idx].EqualsInput(input))
						return cacheBarTimer[idx];
			return CacheIndicator<BarTimer>(new BarTimer(), input, ref cacheBarTimer);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.BarTimer BarTimer()
		{
			return indicator.BarTimer(Input);
		}

		public Indicators.BarTimer BarTimer(ISeries<double> input )
		{
			return indicator.BarTimer(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.BarTimer BarTimer()
		{
			return indicator.BarTimer(Input);
		}

		public Indicators.BarTimer BarTimer(ISeries<double> input )
		{
			return indicator.BarTimer(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class BlockVolume : Indicator
	{
		private double 	blockValue;
		private int 	lastCurrentBar;
		private bool 	hasCarriedOverTransitionTick;
		
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description	= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionBlockVolume;
				Name		= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameBlockVolume;
				Calculate	= Calculate.OnBarClose;
				IsOverlay	= false;
				CountType	= CountType.Volume;
				BlockSize	= 80;

				AddPlot(new Stroke(Brushes.DarkRed, 2), PlotStyle.Bar, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameBlockVolume);
			}
            else if (State == State.Configure)
                AddDataSeries(BarsPeriodType.Tick, 1);
		}

		private void CalculateBlockVolume(bool forceCurrentBar)
		{
			bool inTransition 	= State == State.Realtime && BarsArray[1].Count - 1 - CurrentBars[1] > 1;
			int whatBar 		= State == State.Historical || inTransition || Calculate != Calculate.OnBarClose || forceCurrentBar ? CurrentBars[1] : Math.Min(CurrentBars[1] + 1, BarsArray[1].Count - 1);
			
			if ((Instrument.MasterInstrument.InstrumentType == Cbi.InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)BarsArray[1].GetVolume(whatBar)) : BarsArray[1].GetVolume(whatBar)) >= BlockSize)
			{
				if (!inTransition && hasCarriedOverTransitionTick && !forceCurrentBar && Calculate == Calculate.OnBarClose)
					CalculateBlockVolume(true);
				
				hasCarriedOverTransitionTick 	= inTransition;
				blockValue 						+= CountType == CountType.Volume ? (Instrument.MasterInstrument.InstrumentType == Cbi.InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)BarsArray[1].GetVolume(whatBar)) : BarsArray[1].GetVolume(whatBar)) : 1;
			}
		}
		
		protected override void OnBarUpdate()
		{			
            if (BarsInProgress == 0)
            {
                if (lastCurrentBar <= CurrentBars[0])
                { 
                    int indexOffset = BarsArray[1].Count - 1 - CurrentBars[1];

                    if (lastCurrentBar < CurrentBars[0] && Calculate != Calculate.OnBarClose && (State == State.Realtime || BarsArray[0].IsTickReplay))
                    {
                        if (CurrentBars[0] > 0)
                            Value[1] = blockValue;

                        if (BarsArray[0].IsTickReplay || State == State.Realtime && indexOffset == 0)
                            blockValue = 0;
                    }

                    Value[0] = blockValue;

                    if (Calculate == Calculate.OnBarClose || lastCurrentBar < CurrentBars[0] && BarsArray[0].BarsType.IsIntraday && (State == State.Historical && BarsArray[0].Count - 1 - CurrentBars[0] > 0 || State == State.Realtime && indexOffset > 0))
                        blockValue = 0;
                }

				lastCurrentBar = lastCurrentBar < CurrentBars[0] ? CurrentBars[0] : lastCurrentBar;
			}
			else
			{
				if (BarsArray[1].IsFirstBarOfSession && (Calculate != Calculate.OnBarClose || BarsArray[0].BarsType.IsIntraday))
					blockValue = 0;
				
				CalculateBlockVolume(false);
			}
		}

		#region Properties
		[Range(0.00000001, double.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "BlockTradeSize", GroupName = "NinjaScriptParameters", Order = 0)]
		public double BlockSize { get; set; }


		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "NinjaScriptIndicatorCount", GroupName = "NinjaScriptParameters", Order = 0)]
		public CountType CountType
		{ get; set; }
		#endregion
	}
}

public enum CountType
{
	Trades,
	Volume
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private BlockVolume[] cacheBlockVolume;
		public BlockVolume BlockVolume(double blockSize, CountType countType)
		{
			return BlockVolume(Input, blockSize, countType);
		}

		public BlockVolume BlockVolume(ISeries<double> input, double blockSize, CountType countType)
		{
			if (cacheBlockVolume != null)
				for (int idx = 0; idx < cacheBlockVolume.Length; idx++)
					if (cacheBlockVolume[idx] != null && cacheBlockVolume[idx].BlockSize == blockSize && cacheBlockVolume[idx].CountType == countType && cacheBlockVolume[idx].EqualsInput(input))
						return cacheBlockVolume[idx];
			return CacheIndicator<BlockVolume>(new BlockVolume(){ BlockSize = blockSize, CountType = countType }, input, ref cacheBlockVolume);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.BlockVolume BlockVolume(double blockSize, CountType countType)
		{
			return indicator.BlockVolume(Input, blockSize, countType);
		}

		public Indicators.BlockVolume BlockVolume(ISeries<double> input , double blockSize, CountType countType)
		{
			return indicator.BlockVolume(input, blockSize, countType);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.BlockVolume BlockVolume(double blockSize, CountType countType)
		{
			return indicator.BlockVolume(Input, blockSize, countType);
		}

		public Indicators.BlockVolume BlockVolume(ISeries<double> input , double blockSize, CountType countType)
		{
			return indicator.BlockVolume(input, blockSize, countType);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Bollinger Bands are plotted at standard deviation levels above and below a moving average.
	/// Since standard deviation is a measure of volatility, the bands are self-adjusting:
	/// widening during volatile markets and contracting during calmer periods.
	/// </summary>
	public class Bollinger : Indicator
	{
		private SMA		sma;
		private StdDev	stdDev;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionBollinger;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameBollinger;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				NumStdDev					= 2;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.BollingerUpperBand);
				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.BollingerMiddleBand);
				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.BollingerLowerBand);
			}
			else if (State == State.DataLoaded)
			{
				sma		= SMA(Period);
				stdDev	= StdDev(Period);
			}
		}

		protected override void OnBarUpdate()
		{
			double sma0		= sma[0];
			double stdDev0	= stdDev[0];

			Upper[0]		= sma0 + NumStdDev * stdDev0;
			Middle[0]		= sma0;
			Lower[0]		= sma0 - NumStdDev * stdDev0;
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Lower
		{
			get { return Values[2]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Middle
		{
			get { return Values[1]; }
		}

		[Range(0, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "NumStdDev", GroupName = "NinjaScriptParameters", Order = 0)]
		public double NumStdDev
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Period
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Upper
		{
			get { return Values[0]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Bollinger[] cacheBollinger;
		public Bollinger Bollinger(double numStdDev, int period)
		{
			return Bollinger(Input, numStdDev, period);
		}

		public Bollinger Bollinger(ISeries<double> input, double numStdDev, int period)
		{
			if (cacheBollinger != null)
				for (int idx = 0; idx < cacheBollinger.Length; idx++)
					if (cacheBollinger[idx] != null && cacheBollinger[idx].NumStdDev == numStdDev && cacheBollinger[idx].Period == period && cacheBollinger[idx].EqualsInput(input))
						return cacheBollinger[idx];
			return CacheIndicator<Bollinger>(new Bollinger(){ NumStdDev = numStdDev, Period = period }, input, ref cacheBollinger);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Bollinger Bollinger(double numStdDev, int period)
		{
			return indicator.Bollinger(Input, numStdDev, period);
		}

		public Indicators.Bollinger Bollinger(ISeries<double> input , double numStdDev, int period)
		{
			return indicator.Bollinger(input, numStdDev, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Bollinger Bollinger(double numStdDev, int period)
		{
			return indicator.Bollinger(Input, numStdDev, period);
		}

		public Indicators.Bollinger Bollinger(ISeries<double> input , double numStdDev, int period)
		{
			return indicator.Bollinger(input, numStdDev, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The balance of power indicator measures the strength of the bulls vs. bears by
	///  assessing the ability of each to push price to an extreme level.
	/// </summary>
	public class BOP : Indicator
	{
		private Series<double>	bop;
		private SMA				sma;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= Custom.Resource.NinjaScriptIndicatorDescriptionBOP;
				Name						= Custom.Resource.NinjaScriptIndicatorNameBOP;
				IsSuspendedWhileInactive	= true;
				Smooth 						= 14;
				IsOverlay					= false;

				AddPlot(new Stroke(Brushes.DodgerBlue, 2), PlotStyle.Bar, Custom.Resource.NinjaScriptIndicatorNameBOP);
				AddLine(Brushes.DarkGray, 0, Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.DataLoaded)
			{
				bop = new Series<double>(this);
				sma	= SMA(bop, Smooth);
			}
		}

		protected override void OnBarUpdate()
		{
			double high0	= High[0];
			double low0		= Low[0];

			if ((high0 - low0).ApproxCompare(0) == 0)
				bop[0] = 0;
			else
				bop[0] = (Close[0] - Open[0]) / (high0 - low0);

			Value[0] = sma[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private BOP[] cacheBOP;
		public BOP BOP(int smooth)
		{
			return BOP(Input, smooth);
		}

		public BOP BOP(ISeries<double> input, int smooth)
		{
			if (cacheBOP != null)
				for (int idx = 0; idx < cacheBOP.Length; idx++)
					if (cacheBOP[idx] != null && cacheBOP[idx].Smooth == smooth && cacheBOP[idx].EqualsInput(input))
						return cacheBOP[idx];
			return CacheIndicator<BOP>(new BOP(){ Smooth = smooth }, input, ref cacheBOP);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.BOP BOP(int smooth)
		{
			return indicator.BOP(Input, smooth);
		}

		public Indicators.BOP BOP(ISeries<double> input , int smooth)
		{
			return indicator.BOP(input, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.BOP BOP(int smooth)
		{
			return indicator.BOP(Input, smooth);
		}

		public Indicators.BOP BOP(ISeries<double> input , int smooth)
		{
			return indicator.BOP(input, smooth);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Indicates the current buying or selling pressure as a perecentage.
	/// This is a tick by tick indicator. If 'Calculate on bar close' is true, the indicator values will always be 100.
	/// </summary>
	public class BuySellPressure : Indicator
	{
		private double		buys;
		private double 		sells;
		private int 		activeBar = -1;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description			= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionBuySellPressure;
				Name				= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameBuySellPressure;
				BarsRequiredToPlot	= 1;
				Calculate			= Calculate.OnEachTick;
				DrawOnPricePanel	= false;
				IsOverlay			= false;

				AddPlot(Brushes.DarkCyan,			NinjaTrader.Custom.Resource.BuySellPressureBuyPressure);
				AddPlot(Brushes.Crimson,			NinjaTrader.Custom.Resource.BuySellPressureSellPressure);

				AddLine(Brushes.DimGray,	75,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
				AddLine(Brushes.DimGray,	25,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
			}
			else if (State == State.Historical)
			{
				if (Calculate != Calculate.OnEachTick)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnBarCloseError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnBarCloseError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnMarketData(MarketDataEventArgs e)
		{
			if(e.MarketDataType == MarketDataType.Last)
			{
				if (e.Price >= e.Ask)
					buys += (Instrument.MasterInstrument.InstrumentType == Cbi.InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume(e.Volume) : e.Volume);
				else if (e.Price <= e.Bid)
					sells += (Instrument.MasterInstrument.InstrumentType == Cbi.InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume(e.Volume) : e.Volume);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < activeBar || CurrentBar <= BarsRequiredToPlot)
				return;

			// New Bar has been formed
			// - Assign last volume counted to the prior bar
			// - Reset volume count for new bar
			if (CurrentBar != activeBar)
			{
				BuyPressure[1] = (buys / (buys + sells)) * 100;
				SellPressure[1] = (sells / (buys + sells)) * 100;
				buys = 1;
				sells = 1;
				activeBar = CurrentBar;
			}

			BuyPressure[0] = (buys / (buys + sells)) * 100;
			SellPressure[0] = (sells / (buys + sells)) * 100;
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> BuyPressure
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> SellPressure
		{
			get { return Values[1]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private BuySellPressure[] cacheBuySellPressure;
		public BuySellPressure BuySellPressure()
		{
			return BuySellPressure(Input);
		}

		public BuySellPressure BuySellPressure(ISeries<double> input)
		{
			if (cacheBuySellPressure != null)
				for (int idx = 0; idx < cacheBuySellPressure.Length; idx++)
					if (cacheBuySellPressure[idx] != null &&  cacheBuySellPressure[idx].EqualsInput(input))
						return cacheBuySellPressure[idx];
			return CacheIndicator<BuySellPressure>(new BuySellPressure(), input, ref cacheBuySellPressure);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.BuySellPressure BuySellPressure()
		{
			return indicator.BuySellPressure(Input);
		}

		public Indicators.BuySellPressure BuySellPressure(ISeries<double> input )
		{
			return indicator.BuySellPressure(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.BuySellPressure BuySellPressure()
		{
			return indicator.BuySellPressure(Input);
		}

		public Indicators.BuySellPressure BuySellPressure(ISeries<double> input )
		{
			return indicator.BuySellPressure(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class BuySellVolume : Indicator
	{
		private double	buys;
		private double	sells;
		private int activeBar = 0;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description				= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionBuySellVolume;
				Name					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameBuySellVolume;
				BarsRequiredToPlot		= 1;
				Calculate				= Calculate.OnEachTick;
				DrawOnPricePanel		= false;
				IsOverlay				= false;
				DisplayInDataBox		= true;

				// Plots will overlap each other no matter which one of these comes first
				// in NT8, we would add the Sells first in code and then Buys, and the "Sells" was always in front of the buys.
				AddPlot(new Stroke(Brushes.DarkCyan,	2), PlotStyle.Bar, NinjaTrader.Custom.Resource.BuySellVolumeBuys);
				AddPlot(new Stroke(Brushes.Crimson,		2), PlotStyle.Bar, NinjaTrader.Custom.Resource.BuySellVolumeSells);
			}
			else if (State == State.Historical)
			{
				if (Calculate != Calculate.OnEachTick)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnBarCloseError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnBarCloseError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnMarketData(MarketDataEventArgs e)
		{
			if(e.MarketDataType == MarketDataType.Last)
			{
				if(e.Price >= e.Ask)
					buys += (Instrument.MasterInstrument.InstrumentType == Cbi.InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume(e.Volume) : e.Volume);
				else if (e.Price <= e.Bid)
					sells += (Instrument.MasterInstrument.InstrumentType == Cbi.InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume(e.Volume) : e.Volume);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < activeBar || CurrentBar <= BarsRequiredToPlot)
				return;

			// New Bar has been formed
			// - Assign last volume counted to the prior bar
			// - Reset volume count for new bar
			if (CurrentBar != activeBar)
			{
				Sells[1] = sells;
				Buys[1] = buys + sells;
				buys = 0;
				sells = 0;
				activeBar = CurrentBar;
			}

			Sells[0] = sells;
			Buys[0] = buys + sells;
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Sells
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Buys
		{
			get { return Values[0]; }
		}
		#endregion

	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private BuySellVolume[] cacheBuySellVolume;
		public BuySellVolume BuySellVolume()
		{
			return BuySellVolume(Input);
		}

		public BuySellVolume BuySellVolume(ISeries<double> input)
		{
			if (cacheBuySellVolume != null)
				for (int idx = 0; idx < cacheBuySellVolume.Length; idx++)
					if (cacheBuySellVolume[idx] != null &&  cacheBuySellVolume[idx].EqualsInput(input))
						return cacheBuySellVolume[idx];
			return CacheIndicator<BuySellVolume>(new BuySellVolume(), input, ref cacheBuySellVolume);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.BuySellVolume BuySellVolume()
		{
			return indicator.BuySellVolume(Input);
		}

		public Indicators.BuySellVolume BuySellVolume(ISeries<double> input )
		{
			return indicator.BuySellVolume(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.BuySellVolume BuySellVolume()
		{
			return indicator.BuySellVolume(Input);
		}

		public Indicators.BuySellVolume BuySellVolume(ISeries<double> input )
		{
			return indicator.BuySellVolume(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Core;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX.DirectWrite;

#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	[TypeConverter("NinjaTrader.NinjaScript.Indicators.CamarillaPivotsTypeConverter")]
	public class CamarillaPivots : Indicator
	{
		private DateTime				cacheMonthlyEndDate		= Globals.MinDate;
		private DateTime				cacheSessionDate		= Globals.MinDate;
		private DateTime				cacheSessionEnd			= Globals.MinDate;
		private DateTime				cacheTime;
		private DateTime				cacheWeeklyEndDate		= Globals.MinDate;
		private DateTime				currentDate				= Globals.MinDate;
		private DateTime				currentMonth			= Globals.MinDate;
		private DateTime				currentWeek				= Globals.MinDate;
		private DateTime				sessionDateTmp			= Globals.MinDate;
		private HLCCalculationMode		priorDayHlc;
		private PivotRange				pivotRangeType;
		private SessionIterator			storedSession;
		private double					currentClose;
		private double					currentHigh				= double.MinValue;
		private double					currentLow				= double.MaxValue;
		private double					dailyBarClose			= double.MinValue;
		private double					dailyBarHigh			= double.MinValue;
		private double					dailyBarLow				= double.MinValue;
		private double					r1;
		private double					r2;
		private double					r3;
		private double					r4;
		private double					s1;
		private double					s2;
		private double					s3;
		private double					s4;
		private double					userDefinedClose;
		private double					userDefinedHigh;
		private double					userDefinedLow;
		private int						cacheBar;
		private int						width					= 20;
		private readonly List<int>		newSessionBarIdxArr		= new List<int>();

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description				= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionCamarillaPivots;
				Name					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameCamarillaPivots;
				Calculate				= Calculate.OnBarClose;
				DisplayInDataBox		= true;
				DrawOnPricePanel		= false;
				IsAutoScale				= false;
				IsOverlay				= true;
				PaintPriceMarkers		= true;
				ScaleJustification		= ScaleJustification.Right;

				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.PivotsR1);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.PivotsR2);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.PivotsR3);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.PivotsR4);
				AddPlot(Brushes.Crimson,	NinjaTrader.Custom.Resource.PivotsS1);
				AddPlot(Brushes.Crimson,	NinjaTrader.Custom.Resource.PivotsS2);
				AddPlot(Brushes.Crimson,	NinjaTrader.Custom.Resource.PivotsS3);
				AddPlot(Brushes.Crimson,	NinjaTrader.Custom.Resource.PivotsS4);
			}
			else if (State == State.Configure)
			{
				if (priorDayHlc == HLCCalculationMode.DailyBars)
					AddDataSeries(BarsPeriodType.Day, 1);
			}
			else if (State == State.DataLoaded)
			{
				storedSession = new SessionIterator(Bars);
			}
			else if (State == State.Historical)
			{
				if (priorDayHlc == HLCCalculationMode.DailyBars && BarsArray[1].DayCount <= 0)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsDailyDataError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsDailyDataError, LogLevel.Error);
					return;
				}

				if (!Bars.BarsType.IsIntraday && BarsPeriod.BarsPeriodType != BarsPeriodType.Day && (BarsPeriod.BarsPeriodType != BarsPeriodType.HeikenAshi && BarsPeriod.BarsPeriodType != BarsPeriodType.Volumetric || BarsPeriod.BaseBarsPeriodType != BarsPeriodType.Day))
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsDailyBarsError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsDailyBarsError, LogLevel.Error);
				}
				if ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && pivotRangeType == PivotRange.Daily)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsWeeklyBarsError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsWeeklyBarsError, LogLevel.Error);
				}
				if ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && BarsPeriod.Value > 1)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsPeriodTypeError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsPeriodTypeError, LogLevel.Error);
				}
				if ((priorDayHlc == HLCCalculationMode.DailyBars &&
					(pivotRangeType == PivotRange.Monthly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddMonths(-1)
					|| pivotRangeType == PivotRange.Weekly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-7)
					|| pivotRangeType == PivotRange.Daily && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-1)))
					|| pivotRangeType == PivotRange.Monthly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddMonths(-1)
					|| pivotRangeType == PivotRange.Weekly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-7)
					|| pivotRangeType == PivotRange.Daily && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-1)
					)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsInsufficentDataError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsInsufficentDataError, LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsInProgress != 0)
				return;

			if ((priorDayHlc == HLCCalculationMode.DailyBars && BarsArray[1].DayCount <= 0)
				|| (!Bars.BarsType.IsIntraday && BarsPeriod.BarsPeriodType != BarsPeriodType.Day && (BarsPeriod.BarsPeriodType != BarsPeriodType.HeikenAshi && BarsPeriod.BarsPeriodType != BarsPeriodType.Volumetric || BarsPeriod.BaseBarsPeriodType != BarsPeriodType.Day))
				|| ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && pivotRangeType == PivotRange.Daily)
				|| ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && BarsPeriod.Value > 1)
				|| ((priorDayHlc == HLCCalculationMode.DailyBars && (pivotRangeType == PivotRange.Monthly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddMonths(-1)
				|| pivotRangeType == PivotRange.Weekly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-7)
				|| pivotRangeType == PivotRange.Daily && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-1)))
				|| pivotRangeType == PivotRange.Monthly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddMonths(-1)
				|| pivotRangeType == PivotRange.Weekly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-7)
				|| pivotRangeType == PivotRange.Daily && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-1)))
				return;

			RemoveDrawObject("NinjaScriptInfo");

			if (PriorDayHlc == HLCCalculationMode.DailyBars && CurrentBars[1] >= 0)
			{
				// Get daily bars like this to avoid situation where primary series moves to next session before previous day OHLC are added
				if (cacheTime != Times[0][0])
				{
					cacheTime	= Times[0][0];
					cacheBar	= BarsArray[1].GetBar(Times[0][0]);
				}
				dailyBarHigh	= BarsArray[1].GetHigh(cacheBar);
				dailyBarLow		= BarsArray[1].GetLow(cacheBar);
				dailyBarClose	= BarsArray[1].GetClose(cacheBar);
			}
			else
			{
				dailyBarHigh	= double.MinValue;
				dailyBarLow		= double.MinValue;
				dailyBarClose	= double.MinValue;
			}

			double high		= (dailyBarHigh == double.MinValue)		? Highs[0][0]	: dailyBarHigh;
			double low		= (dailyBarLow == double.MinValue)		? Lows[0][0]	: dailyBarLow;
			double close	= (dailyBarClose == double.MinValue)	? Closes[0][0]	: dailyBarClose;

			DateTime lastBarTimeStamp = GetLastBarSessionDate(Times[0][0], pivotRangeType);

			if ((currentDate != Globals.MinDate && pivotRangeType == PivotRange.Daily && lastBarTimeStamp != currentDate)
				|| (currentWeek != Globals.MinDate && pivotRangeType == PivotRange.Weekly && lastBarTimeStamp != currentWeek)
				|| (currentMonth != Globals.MinDate && pivotRangeType == PivotRange.Monthly && lastBarTimeStamp != currentMonth))
			{
				s1				= currentClose - (currentHigh - currentLow) * 1.1 / 12;
				r1				= currentClose + (currentHigh - currentLow) * 1.1 / 12;
				s2				= currentClose - (currentHigh - currentLow) * 1.1 / 6;
				r2				= currentClose + (currentHigh - currentLow) * 1.1 / 6;
				s3				= currentClose - (currentHigh - currentLow) * 1.1 / 4;
				r3				= currentClose + (currentHigh - currentLow) * 1.1 / 4;
				s4				= currentClose - (currentHigh - currentLow) * 1.1 / 2;
				r4				= currentClose + (currentHigh - currentLow) * 1.1 / 2;
				currentClose	= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedClose	: close;
				currentHigh		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedHigh	: high;
				currentLow		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedLow	: low;
			}
			else
			{
				currentClose	= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedClose	: close;
				currentHigh		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedHigh	: Math.Max(currentHigh, high);
				currentLow		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedLow	: Math.Min(currentLow, low);
			}


			if (pivotRangeType == PivotRange.Daily)
				currentDate = lastBarTimeStamp;
			if (pivotRangeType == PivotRange.Weekly)
				currentWeek = lastBarTimeStamp;
			if (pivotRangeType == PivotRange.Monthly)
				currentMonth = lastBarTimeStamp;

			if ((pivotRangeType == PivotRange.Daily && currentDate != Globals.MinDate)
				|| (pivotRangeType == PivotRange.Weekly && currentWeek != Globals.MinDate)
				|| (pivotRangeType == PivotRange.Monthly && currentMonth != Globals.MinDate))
			{
				R1[0] = r1;
				R2[0] = r2;
				R3[0] = r3;
				R4[0] = r4;
				S1[0] = s1;
				S2[0] = s2;
				S3[0] = s3;
				S4[0] = s4;
			}
		}

		#region Misc
		private DateTime GetLastBarSessionDate(DateTime time, PivotRange pivotRange)
		{
			// Check the time[0] against the previous session end
			if (time > cacheSessionEnd)
			{
				if (Bars.BarsType.IsIntraday)
				{
					// Make use of the stored session iterator to find the next session...
					storedSession.GetNextSession(time, true);
					// Store the actual session's end datetime as the session
					cacheSessionEnd = storedSession.ActualSessionEnd;
					// We need to convert that time from the session to the users time zone settings
					sessionDateTmp = TimeZoneInfo.ConvertTime(cacheSessionEnd.AddSeconds(-1), Globals.GeneralOptions.TimeZoneInfo, Bars.TradingHours.TimeZoneInfo).Date;
				}
				else
					sessionDateTmp = time.Date;
			}

			if (pivotRange == PivotRange.Daily)
			{
				if (sessionDateTmp != cacheSessionDate)
				{
					if (newSessionBarIdxArr.Count == 0 || newSessionBarIdxArr.Count > 0 && CurrentBar > newSessionBarIdxArr[newSessionBarIdxArr.Count - 1])
						newSessionBarIdxArr.Add(CurrentBar);
					cacheSessionDate = sessionDateTmp;
				}
				return sessionDateTmp;
			}

			DateTime tmpWeeklyEndDate = RoundUpTimeToPeriodTime(sessionDateTmp, PivotRange.Weekly);
			if (pivotRange == PivotRange.Weekly)
			{
				if (tmpWeeklyEndDate != cacheWeeklyEndDate)
				{
					if (newSessionBarIdxArr.Count == 0 || newSessionBarIdxArr.Count > 0 && CurrentBar > newSessionBarIdxArr[newSessionBarIdxArr.Count - 1])
						newSessionBarIdxArr.Add(CurrentBar);
					cacheWeeklyEndDate = tmpWeeklyEndDate;
				}
				return tmpWeeklyEndDate;
			}

			DateTime tmpMonthlyEndDate = RoundUpTimeToPeriodTime(sessionDateTmp, PivotRange.Monthly);
			if (tmpMonthlyEndDate != cacheMonthlyEndDate)
			{
				if (newSessionBarIdxArr.Count == 0 || newSessionBarIdxArr.Count > 0 && CurrentBar > newSessionBarIdxArr[newSessionBarIdxArr.Count - 1])
					newSessionBarIdxArr.Add(CurrentBar);
				cacheMonthlyEndDate = tmpMonthlyEndDate;
			}
			return tmpMonthlyEndDate;
		}

		private DateTime RoundUpTimeToPeriodTime(DateTime time, PivotRange pivotRange)
		{
			if (pivotRange == PivotRange.Weekly)
				return Gui.Tools.Extensions.GetEndOfWeekTime(time);
			if (pivotRange == PivotRange.Monthly)
				return Gui.Tools.Extensions.GetEndOfMonthTime(time);
			return time;
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
		{
			// Set text to chart label color and font
			TextFormat	textFormat			= chartControl.Properties.LabelFont.ToDirectWriteTextFormat();

			// Loop through each Plot Values on the chart
			for (int seriesCount = 0; seriesCount < Values.Length; seriesCount++)
			{
				double	y					= -1;
				double	startX				= -1;
				double	endX				= -1;
				int		firstBarIdxToPaint	= -1;
				int		firstBarPainted		= ChartBars.FromIndex;
				int		lastBarPainted		= ChartBars.ToIndex;
				Plot	plot				= Plots[seriesCount];

				for (int i = newSessionBarIdxArr.Count - 1; i >= 0; i--)
				{
					int prevSessionBreakIdx = newSessionBarIdxArr[i];
					if (prevSessionBreakIdx <= lastBarPainted)
					{
						firstBarIdxToPaint = prevSessionBreakIdx;
						break;
					}
				}

				// Loop through visble bars to render plot values
				for (int idx = lastBarPainted; idx >= Math.Max(firstBarPainted, lastBarPainted - width); idx--)
				{
					if (idx < firstBarIdxToPaint)
						break;

					startX		= chartControl.GetXByBarIndex(ChartBars, idx);
					endX		= chartControl.GetXByBarIndex(ChartBars, lastBarPainted);
					double val	= Values[seriesCount].GetValueAt(idx);
					y			= chartScale.GetYByValue(val);
				}

				// Draw pivot lines
				Point startPoint	= new Point(startX, y);
				Point endPoint		= new Point(endX, y);
				RenderTarget.DrawLine(startPoint.ToVector2(), endPoint.ToVector2(), plot.BrushDX, plot.Width, plot.StrokeStyle);

				// Draw pivot text
				TextLayout textLayout = new TextLayout(Globals.DirectWriteFactory, plot.Name, textFormat, ChartPanel.W, textFormat.FontSize);
				RenderTarget.DrawTextLayout(startPoint.ToVector2(), textLayout, plot.BrushDX);
				textLayout.Dispose();
			}
			textFormat.Dispose();
		}
		#endregion

		#region Properties

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "PivotRange", GroupName = "NinjaScriptParameters", Order = 0)]
		public PivotRange PivotRangeType
		{
			get { return pivotRangeType; }
			set { pivotRangeType = value; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "HLCCalculationMode", GroupName = "NinjaScriptParameters", Order = 1)]
		[RefreshProperties(RefreshProperties.All)] // Update UI when value is changed
		public HLCCalculationMode PriorDayHlc
		{
			get { return priorDayHlc; }
			set { priorDayHlc = value; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> R1
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> R2
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> R3
		{
			get { return Values[2]; }
		}
		
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> R4
		{
			get { return Values[3]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> S1
		{
			get { return Values[4]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> S2
		{
			get { return Values[5]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> S3
		{
			get { return Values[6]; }
		}
		
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> S4
		{
			get { return Values[7]; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UserDefinedClose", GroupName = "NinjaScriptParameters", Order = 2)]
		public double UserDefinedClose
		{
			get { return userDefinedClose; }
			set { userDefinedClose = value; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UserDefinedHigh", GroupName = "NinjaScriptParameters", Order = 3)]
		public double UserDefinedHigh
		{
			get { return userDefinedHigh; }
			set { userDefinedHigh = value; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UserDefinedLow", GroupName = "NinjaScriptParameters", Order = 4)]
		public double UserDefinedLow
		{
			get { return userDefinedLow; }
			set { userDefinedLow = value; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Width", GroupName = "NinjaScriptParameters", Order = 5)]
		public int Width
		{
			get { return width; }
			set { width = value; }
		}

		#endregion
	}

	// Hide UserDefinedValues properties when not in use by the HLCCalculationMode.UserDefinedValues
	// When creating a custom type converter for indicators it must inherit from NinjaTrader.NinjaScript.IndicatorBaseConverter to work correctly with indicators
	public class CamarillaPivotsTypeConverter : NinjaTrader.NinjaScript.IndicatorBaseConverter
	{
		public override bool GetPropertiesSupported(ITypeDescriptorContext context) { return true; }

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection propertyDescriptorCollection = base.GetPropertiesSupported(context) ? base.GetProperties(context, value, attributes) : TypeDescriptor.GetProperties(value, attributes);

			CamarillaPivots		thisPivotsInstance			= (CamarillaPivots) value;
			HLCCalculationMode	selectedHLCCalculationMode	= thisPivotsInstance.PriorDayHlc;
			if (selectedHLCCalculationMode == HLCCalculationMode.UserDefinedValues)
				return propertyDescriptorCollection;

			PropertyDescriptorCollection adjusted = new PropertyDescriptorCollection(null);
			foreach (PropertyDescriptor thisDescriptor in propertyDescriptorCollection)
			{
				if (thisDescriptor.Name == "UserDefinedClose" || thisDescriptor.Name == "UserDefinedHigh" || thisDescriptor.Name == "UserDefinedLow")
					adjusted.Add(new PropertyDescriptorExtended(thisDescriptor, o => value, null, new Attribute[] {new BrowsableAttribute(false), }));
				else
					adjusted.Add(thisDescriptor);
			}
			return adjusted;
		}
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private CamarillaPivots[] cacheCamarillaPivots;
		public CamarillaPivots CamarillaPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return CamarillaPivots(Input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}

		public CamarillaPivots CamarillaPivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			if (cacheCamarillaPivots != null)
				for (int idx = 0; idx < cacheCamarillaPivots.Length; idx++)
					if (cacheCamarillaPivots[idx] != null && cacheCamarillaPivots[idx].PivotRangeType == pivotRangeType && cacheCamarillaPivots[idx].PriorDayHlc == priorDayHlc && cacheCamarillaPivots[idx].UserDefinedClose == userDefinedClose && cacheCamarillaPivots[idx].UserDefinedHigh == userDefinedHigh && cacheCamarillaPivots[idx].UserDefinedLow == userDefinedLow && cacheCamarillaPivots[idx].Width == width && cacheCamarillaPivots[idx].EqualsInput(input))
						return cacheCamarillaPivots[idx];
			return CacheIndicator<CamarillaPivots>(new CamarillaPivots(){ PivotRangeType = pivotRangeType, PriorDayHlc = priorDayHlc, UserDefinedClose = userDefinedClose, UserDefinedHigh = userDefinedHigh, UserDefinedLow = userDefinedLow, Width = width }, input, ref cacheCamarillaPivots);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.CamarillaPivots CamarillaPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.CamarillaPivots(Input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}

		public Indicators.CamarillaPivots CamarillaPivots(ISeries<double> input , PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.CamarillaPivots(input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.CamarillaPivots CamarillaPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.CamarillaPivots(Input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}

		public Indicators.CamarillaPivots CamarillaPivots(ISeries<double> input , PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.CamarillaPivots(input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class CandlestickPattern : Indicator
	{
		private Brush					downBrush				= Brushes.DimGray;
		private CandleStickPatternLogic	logic;
		private int 					numPatternsFound;
		private TextPosition			textBoxPosition			= TextPosition.BottomRight;
		private Brush					textBrush				= Brushes.DimGray;
		private Brush					upBrush					= Brushes.DimGray;
		
		private void DrawText(string text, int barsAgo, double price, int yOffset)
		{
			Draw.Text(this, text + CurrentBar, false, text + " # " + ++numPatternsFound, barsAgo, price, yOffset, textBrush, TextFont, 
				TextAlignment.Center, Brushes.Transparent, Brushes.Transparent, 0);
		}

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description			= Custom.Resource.NinjaScriptIndicatorDescriptionCandlestickPattern;
				Name				= Custom.Resource.NinjaScriptIndicatorNameCandlestickPattern;
				Calculate			= Calculate.OnBarClose;
				IsOverlay			= true;
				DrawOnPricePanel	= true;
				DisplayInDataBox	= false;
				IsAutoScale			= false;
				PaintPriceMarkers	= false;
				Pattern				= ChartPattern.MorningStar;
				ShowAlerts			= true;
				ShowPatternCount	= true;
				TrendStrength		= 4;
				TextFont			= new Gui.Tools.SimpleFont() { Size = 14 };

				downBrush			= Brushes.DimGray;
				upBrush				= Brushes.DimGray;
				textBrush			= Brushes.DimGray;

				AddPlot(Brushes.Transparent, Custom.Resource.CandlestickPatternFound);
			}
			else if (State == State.Configure)
				Calculate	= Calculate.OnBarClose;
			else if (State == State.DataLoaded)
				logic = new CandleStickPatternLogic(this, TrendStrength);
			else if (State == State.Historical)
			{
				if (ChartControl != null)
				{
					downBrush	= ChartControl.Properties.AxisPen.Brush;
					textBrush	= ChartControl.Properties.ChartText;
				}

				if (downBrush == upBrush)
					upBrush	= Brushes.Transparent;
			}
		}

		protected override void OnBarUpdate()
		{
			PatternFound[0] = (logic.Evaluate(Pattern) ? 1 : 0);
			
			if (PatternFound[0] == 1)
			{
				bool 	isBearish 	= false;
				string 	text 		= string.Empty;
				
				switch (Pattern)
				{
					case ChartPattern.BearishBeltHold: 		text = "Bearish Belt Hold"; 	isBearish = true; 	break;
					case ChartPattern.BearishEngulfing: 	text = "Bearish Engulfing"; 	isBearish = true; 	break;
					case ChartPattern.BearishHarami: 		text = "Bearish Harami"; 		isBearish = true; 	break;
					case ChartPattern.BearishHaramiCross: 	text = "Bearish Harami Cross"; 	isBearish = true; 	break;
					case ChartPattern.BullishBeltHold: 		text = "Bullish Belt Hold"; 						break;
					case ChartPattern.BullishEngulfing: 	text = "Bullish Engulfing"; 						break;
					case ChartPattern.BullishHarami: 		text = "Bullish Harami"; 							break;
					case ChartPattern.BullishHaramiCross: 	text = "Bullish Harami Cross"; 						break;
				}
				
				if (!string.IsNullOrEmpty(text))
				{
					BarBrushes[1] 			= isBearish 								? upBrush 	: downBrush;
					BarBrushes[0] 			= isBearish 								? downBrush : upBrush;
					CandleOutlineBrushes[1] = Pattern == ChartPattern.BearishBeltHold 	? downBrush : CandleOutlineBrushes[1];
					CandleOutlineBrushes[0] = !isBearish 								? downBrush : CandleOutlineBrushes[0];
					DrawText(text, 0, isBearish ? Math.Max(High[0], High[1]) : Math.Min(Low[0], Low[1]), isBearish ? 40 : 10);
				}
				
				switch (Pattern)
				{
					case ChartPattern.DarkCloudCover:
						BarBrushes[1] 			= upBrush;
						BarBrushes[0] 			= downBrush;
						CandleOutlineBrushes[1] = downBrush;
						DrawText("Dark Cloud Cover", 1, Math.Max(High[0], High[1]), 50);
						break;
					case ChartPattern.Doji:
						BarBrushes[0] 			= upBrush;
						CandleOutlineBrushes[0] = downBrush;
						int yOffset 			= Close[0] > Close[Math.Min(1, CurrentBar)] ? 20 : -20;
						DrawText("Doji", 0, (yOffset > 0 ? High[0] : Low[0]), yOffset);
						break;
					case ChartPattern.DownsideTasukiGap:
						BarBrushes[2] 			= downBrush;
						BarBrushes[1] 			= downBrush;
						BarBrushes[0] 			= upBrush;
						CandleOutlineBrushes[0] = downBrush;
						DrawText("Downside Tasuki Gap", 1, MAX(High, 3)[0], 10);
						break;
					case ChartPattern.EveningStar:
						BarBrushes[2] 			= Close[2] > Open[2] ? upBrush : downBrush;
						BarBrushes[1] 			= Close[1] > Open[1] ? upBrush : downBrush;
						BarBrushes[0] 			= Close[0] > Open[0] ? upBrush : downBrush;
						CandleOutlineBrushes[2] = Close[2] > Open[2] ? downBrush : CandleOutlineBrushes[2];
						CandleOutlineBrushes[1] = Close[1] > Open[1] ? downBrush : CandleOutlineBrushes[1];
						CandleOutlineBrushes[0] = Close[0] > Open[0] ? downBrush : CandleOutlineBrushes[0];
						DrawText("Evening Star", 1, MAX(High, 3)[0], 40);
						break;
					case ChartPattern.FallingThreeMethods:
						BarBrushes[4] = downBrush;
						BarBrushes[0] = downBrush;
						for (int i = 1; i < 4; i++)
						{
							BarBrushes[i] 			= Close[i] > Open[i] ? upBrush : downBrush;
							CandleOutlineBrushes[i] = Close[i] > Open[i] ? downBrush : CandleOutlineBrushes[i];
						}
						DrawText("Falling Three Methods", 2, Math.Max(High[0], High[4]), 40);
						break;
					case ChartPattern.Hammer:
						BarBrushes[0] 			= Close[0] > Open[0] ? upBrush : downBrush;
						CandleOutlineBrushes[0] = Close[0] > Open[0] ? downBrush : CandleOutlineBrushes[0];
						DrawText("Hammer", 0, Low[0], -20);
						break;
					case ChartPattern.HangingMan:
						BarBrushes[0] 			= Close[0] > Open[0] ? upBrush : downBrush;
						CandleOutlineBrushes[0] = Close[0] > Open[0] ? downBrush : CandleOutlineBrushes[0];
						DrawText("Hanging Man", 0, Low[0], -20);
						break;
					case ChartPattern.InvertedHammer:
						BarBrushes[0] 			= Close[0] > Open[0] ? upBrush : downBrush;
						CandleOutlineBrushes[0] = Close[0] > Open[0] ? downBrush : CandleOutlineBrushes[0];
						DrawText("Inverted Hammer", 0, Low[0] - 2 * TickSize, 20);
						break;
					case ChartPattern.MorningStar:
						BarBrushes[2] 			= Close[2] > Open[2] ? upBrush : downBrush;
						BarBrushes[1] 			= Close[1] > Open[1] ? upBrush : downBrush;
						BarBrushes[0] 			= Close[0] > Open[0] ? upBrush : downBrush;
						CandleOutlineBrushes[2] = Close[2] > Open[2] ? downBrush : CandleOutlineBrushes[2];
						CandleOutlineBrushes[1] = Close[1] > Open[1] ? downBrush : CandleOutlineBrushes[1];
						CandleOutlineBrushes[0] = Close[0] > Open[0] ? downBrush : CandleOutlineBrushes[0];
						DrawText("Morning Star", 1, MIN(Low, 3)[0], -20);
						break;
					case ChartPattern.PiercingLine:
						BarBrushes[1] 			= upBrush;
						BarBrushes[0] 			= downBrush;
						CandleOutlineBrushes[1] = downBrush;
						DrawText("Piercing Line", 1, Low[0], -10);
						break;
					case ChartPattern.RisingThreeMethods:
						BarBrushes[4] 			= upBrush;
						BarBrushes[0] 			= upBrush;
						CandleOutlineBrushes[4] = downBrush;
						CandleOutlineBrushes[0] = downBrush;
						for (int i = 1; i < 4; i++)
						{
							BarBrushes[i] 			= Close[i] > Open[i] ? upBrush : downBrush;
							CandleOutlineBrushes[i] = Close[i] > Open[i] ? downBrush : CandleOutlineBrushes[i];
						}
						DrawText("Rising Three Methods", 2, MIN(Low, 5)[0], -10);
						break;
					case ChartPattern.ShootingStar:
						BarBrushes[0] = downBrush;
						DrawText("Shooting Star", 0, High[0], 30);
						break;
					case ChartPattern.StickSandwich:
						BarBrushes[2] 			= downBrush;
						BarBrushes[1] 			= upBrush;
						BarBrushes[0] 			= downBrush;
						CandleOutlineBrushes[1] = downBrush;
						DrawText("Stick Sandwich", 1, MAX(High, 3)[0], 50);
						break;
					case ChartPattern.ThreeBlackCrows:
						BarBrushes[2] 			= downBrush;
						BarBrushes[1] 			= downBrush;
						BarBrushes[0] 			= downBrush;
						DrawText("Three Black Crows", 1, MAX(High, 3)[0], 50);
						break;
					case ChartPattern.ThreeWhiteSoldiers:
						BarBrushes[2] 			= upBrush;
						BarBrushes[1] 			= upBrush;
						BarBrushes[0] 			= upBrush;
						CandleOutlineBrushes[2] = downBrush;
						CandleOutlineBrushes[1] = downBrush;
						CandleOutlineBrushes[0] = downBrush;
						DrawText("Three White Soldiers", 1, Low[2], -10);
						break;
					case ChartPattern.UpsideGapTwoCrows:
						BarBrushes[2] 			= upBrush;
						BarBrushes[1] 			= downBrush;
						BarBrushes[0] 			= downBrush;
						CandleOutlineBrushes[2] = downBrush;
						DrawText("Upside Gap Two Crows", 1, Math.Max(High[0], High[1]), 10);
						break;
					case ChartPattern.UpsideTasukiGap:
						BarBrushes[2] 			= upBrush;
						BarBrushes[1] 			= upBrush;
						BarBrushes[0] 			= downBrush;
						CandleOutlineBrushes[2] = downBrush;
						CandleOutlineBrushes[1] = downBrush;
						DrawText("Upide Tasuki Gap", 1, MIN(Low, 3)[0], -20);
						break;

					}

				if (ShowAlerts)
					Alert("myAlert", Priority.Low, string.Format("Pattern(s) found: {0} {1} on {2} {3} {4} Chart", numPatternsFound, Pattern, 
						Instrument.FullName, BarsPeriod.Value, BarsPeriod.BarsPeriodType), "Alert3.wav", 10, Brushes.Transparent, textBrush);
			}
			
			if (ShowPatternCount)
				Draw.TextFixed(this, "Count", string.Format("{0} {1}\n patterns found", numPatternsFound, Pattern), textBoxPosition, textBrush, TextFont, 
					Brushes.Transparent, Brushes.Transparent, 0);
		}

		public override string ToString()
		{
			return string.Format("{0}({1})", Name, Pattern);
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> PatternFound
		{
			get { return Values[0]; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "SelectPattern", Description = "SelectPatternDescription", GroupName = "NinjaScriptGeneral", Order = 1)]
		public ChartPattern Pattern
		{ get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "SendAlerts", Description = "SendAlertsDescription", GroupName = "NinjaScriptGeneral", Order = 2)]
		public bool ShowAlerts
		{ get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowPatternCount", Description = "ShowPatternCountDescription", GroupName = "NinjaScriptGeneral", Order = 3)]
		public bool ShowPatternCount
		{ get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "TextFont", Description = "TextFontDescription", GroupName = "NinjaScriptGeneral", Order = 4)]
		public Gui.Tools.SimpleFont TextFont
		{ get; set; }

		[NinjaScriptProperty]
		[Range(0, int.MaxValue)]
		[Display(ResourceType = typeof(Custom.Resource), Name = "TrendStrength", Description = "TrendStrengthDescription",
		GroupName = "NinjaScriptGeneral", Order = 5)]
		public int TrendStrength
		{ get; set; }
		#endregion
	}

	public class CandleStickPatternLogic
	{
		private		bool				isInDownTrend;
		private		bool				isInUpTrend;
		private		MAX					max;
		private		MIN					min;
		private		NinjaScriptBase		ninjaScript;
		private		bool[]				prior = new bool[2];		// Check if there was any pattern in the last 2 bars. Ignore a match in case.
		private		Swing				swing;
		private		int					trendStrength;

		public CandleStickPatternLogic(NinjaScriptBase ninjaScript, int trendStrength)
		{
			this.ninjaScript	= ninjaScript;
			this.trendStrength	= trendStrength;
		}

		public bool Evaluate(ChartPattern pattern)
		{
			if (ninjaScript.CurrentBar < trendStrength || ninjaScript.CurrentBar < 2)
				return false;

			if (max == null && trendStrength > 0 && (pattern == ChartPattern.HangingMan || pattern == ChartPattern.InvertedHammer))
			{
				max = new Indicators.MAX();
				max.Period = trendStrength;
				try 
				{
					max.SetState(State.Configure);
				}
				catch (Exception exp)
				{
					Cbi.Log.Process(typeof(Resource), "CbiUnableToCreateInstance2", new object[] { max.Name, exp.InnerException != null ? exp.InnerException.ToString() : exp.ToString() }, Cbi.LogLevel.Error, Cbi.LogCategories.Default);
					max.SetState(State.Finalized);
				}

				max.Parent = ninjaScript;
				max.SetInput(ninjaScript.High);

				lock (ninjaScript.NinjaScripts)
					ninjaScript.NinjaScripts.Add(max);

				try
				{
					max.SetState(ninjaScript.State);
				}
				catch (Exception exp)
				{
					Cbi.Log.Process(typeof(Resource), "CbiUnableToCreateInstance2", new object[] { max.Name, exp.InnerException != null ? exp.InnerException.ToString() : exp.ToString() }, Cbi.LogLevel.Error, Cbi.LogCategories.Default);
					max.SetState(State.Finalized);
					return false;
				}
			}

			if (min == null && trendStrength > 0 && pattern == ChartPattern.Hammer)
			{
				min = new MIN();
				min.Period = trendStrength;
				try 
				{
					min.SetState(State.Configure);
				}
				catch (Exception exp)
				{
					Cbi.Log.Process(typeof(Resource), "CbiUnableToCreateInstance2", new object[] { min.Name, exp.InnerException != null ? exp.InnerException.ToString() : exp.ToString() }, Cbi.LogLevel.Error, Cbi.LogCategories.Default);
					min.SetState(State.Finalized);
				}

				min.Parent = ninjaScript;
				min.SetInput(ninjaScript.Low);

				lock (ninjaScript.NinjaScripts)
					ninjaScript.NinjaScripts.Add(min);

				try
				{
					min.SetState(ninjaScript.State);
				}
				catch (Exception exp)
				{
					Cbi.Log.Process(typeof(Resource), "CbiUnableToCreateInstance2", new object[] { min.Name, exp.InnerException != null ? exp.InnerException.ToString() : exp.ToString() }, Cbi.LogLevel.Error, Cbi.LogCategories.Default);
					min.SetState(State.Finalized);
					return false;
				}
			}

			if (pattern != ChartPattern.Doji
					&& pattern != ChartPattern.DownsideTasukiGap
					&& pattern != ChartPattern.EveningStar
					&& pattern != ChartPattern.FallingThreeMethods
					&& pattern != ChartPattern.MorningStar
					&& pattern != ChartPattern.RisingThreeMethods
					&& pattern != ChartPattern.StickSandwich
					&& pattern != ChartPattern.UpsideTasukiGap)
            {             
                if (trendStrength == 0)
                {
                    isInDownTrend = true;
                    isInUpTrend = true;
                }
                else
                {
                    if (swing == null)
                    {
                        swing = new Swing();
                        swing.Strength = trendStrength;
                        try
                        {
                            swing.SetState(State.Configure);
                        }
                        catch (Exception exp)
                        {
                            Cbi.Log.Process(typeof(Resource), "CbiUnableToCreateInstance2", new object[] { swing.Name, exp.InnerException != null ? exp.InnerException.ToString() : exp.ToString() }, Cbi.LogLevel.Error, Cbi.LogCategories.Default);
                            swing.SetState(State.Finalized);
                        }

                        swing.Parent = ninjaScript;
                        swing.SetInput(ninjaScript.Input);

                        lock (ninjaScript.NinjaScripts)
                            ninjaScript.NinjaScripts.Add(swing);

                        try
                        {
                            swing.SetState(ninjaScript.State);
                        }
                        catch (Exception exp)
                        {
                            Cbi.Log.Process(typeof(Resource), "CbiUnableToCreateInstance2", new object[] { swing.Name, exp.InnerException != null ? exp.InnerException.ToString() : exp.ToString() }, Cbi.LogLevel.Error, Cbi.LogCategories.Default);
                            swing.SetState(State.Finalized);
                            return false;
                        }
                    }

                    // Calculate up trend line
                    int upTrendStartBarsAgo = 0;
                    int upTrendEndBarsAgo = 0;
                    int upTrendOccurence = 1;

                    while (ninjaScript.Low[upTrendEndBarsAgo] <= ninjaScript.Low[upTrendStartBarsAgo])
                    {
                        upTrendStartBarsAgo = swing.SwingLowBar(0, upTrendOccurence + 1, ninjaScript.CurrentBar);
                        upTrendEndBarsAgo = swing.SwingLowBar(0, upTrendOccurence, ninjaScript.CurrentBar);

                        if (upTrendStartBarsAgo < 0 || upTrendEndBarsAgo < 0)
                            break;

                        upTrendOccurence++;
                    }

                    // Calculate down trend line
                    int downTrendStartBarsAgo = 0;
                    int downTrendEndBarsAgo = 0;
                    int downTrendOccurence = 1;

                    while (ninjaScript.High[downTrendEndBarsAgo] >= ninjaScript.High[downTrendStartBarsAgo])
                    {

                        downTrendStartBarsAgo = swing.SwingHighBar(0, downTrendOccurence + 1, ninjaScript.CurrentBar);
                        downTrendEndBarsAgo = swing.SwingHighBar(0, downTrendOccurence, ninjaScript.CurrentBar);

                        if (downTrendStartBarsAgo < 0 || downTrendEndBarsAgo < 0)
                            break;

                        downTrendOccurence++;
                    }

                    if (upTrendStartBarsAgo > 0 && upTrendEndBarsAgo > 0 && upTrendStartBarsAgo < downTrendStartBarsAgo)
                    {
                        isInDownTrend = false;
                        isInUpTrend = true;
                    }
                    else if (downTrendStartBarsAgo > 0 && downTrendEndBarsAgo > 0 && upTrendStartBarsAgo > downTrendStartBarsAgo)
                    {
                        isInDownTrend = true;
                        isInUpTrend = false;
                    }
                    else
                    {
                        isInDownTrend = false;
                        isInUpTrend = false;
                    }
                }
            }

            bool    found	= false;
			NinjaScriptBase n		= ninjaScript;
			if (!prior[0] && !prior[1])				// no pattern found on the last 2 bars
				switch (pattern)
				{
					case ChartPattern.BearishBeltHold:		found = isInUpTrend && n.Close[1] > n.Open[1] && n.Open[0] > n.Close[1] + 5 * n.TickSize && n.Open[0] == n.High[0] && n.Close[0] < n.Open[0]; break;
					case ChartPattern.BearishEngulfing:		found = isInUpTrend && n.Close[1] > n.Open[1] && n.Close[0] < n.Open[0] && n.Open[0] > n.Close[1] && n.Close[0] < n.Open[1]; break;
					case ChartPattern.BearishHarami:		found = isInUpTrend && n.Close[0] < n.Open[0] && n.Close[1] > n.Open[1] && n.Low[0] >= n.Open[1] && n.High[0] <= n.Close[1]; break;
					case ChartPattern.BearishHaramiCross:	found = isInUpTrend && (n.High[0] <= n.Close[1]) && (n.Low[0] >= n.Open[1]) && n.Open[0] <= n.Close[1] && n.Close[0] >= n.Open[1]
																	&& ((n.Close[0] >= n.Open[0] && n.Close[0] <= n.Open[0] + n.TickSize) || (n.Close[0] <= n.Open[0] && n.Close[0] >= n.Open[0] - n.TickSize)); break;
					case ChartPattern.BullishBeltHold:		found = isInDownTrend && n.Close[1] < n.Open[1] && n.Open[0] < n.Close[1] - 5 * n.TickSize && n.Open[0] == n.Low[0] && n.Close[0] > n.Open[0]; break;
					case ChartPattern.BullishEngulfing:		found = isInDownTrend && n.Close[1] < n.Open[1] && n.Close[0] > n.Open[0] && n.Close[0] > n.Open[1] && n.Open[0] < n.Close[1]; break;
					case ChartPattern.BullishHarami:		found = isInDownTrend && n.Close[0] > n.Open[0] && n.Close[1] < n.Open[1] && n.Low[0] >= n.Close[1] && n.High[0] <= n.Open[1]; break;
					case ChartPattern.BullishHaramiCross:	found = isInDownTrend && (n.High[0] <= n.Open[1]) && (n.Low[0] >= n.Close[1]) && n.Open[0] >= n.Close[1] && n.Close[0] <= n.Open[1]
																	&& ((n.Close[0] >= n.Open[0] && n.Close[0] <= n.Open[0] + n.TickSize) || (n.Close[0] <= n.Open[0] && n.Close[0] >= n.Open[0] - n.TickSize)); break;
					case ChartPattern.DarkCloudCover:		found = isInUpTrend && n.Open[0] > n.High[1] && n.Close[1] > n.Open[1] && n.Close[0] < n.Open[0] && n.Close[0] <= n.Close[1] - (n.Close[1] - n.Open[1]) / 2 && n.Close[0] >= n.Open[1]; break;
					case ChartPattern.Doji:					found = Math.Abs(n.Close[0] - n.Open[0]) <= (n.High[0] - n.Low[0]) * 0.07; break;
					case ChartPattern.DownsideTasukiGap:	found = n.Close[2] < n.Open[2] && n.Close[1] < n.Open[1] && n.Close[0] > n.Open[0] && n.High[1] < n.Low[2]
																	&& n.Open[0] > n.Close[1] && n.Open[0] < n.Open[1] && n.Close[0] > n.Open[1] && n.Close[0] < n.Close[2]; break;
					case ChartPattern.EveningStar:			found = n.Close[2] > n.Open[2] && n.Close[1] > n.Close[2] && n.Open[0] < (Math.Abs((n.Close[1] - n.Open[1]) / 2) + n.Open[1]) && n.Close[0] < n.Open[0]; break;
					case ChartPattern.FallingThreeMethods:	found = n.CurrentBar > 5 && n.Close[4] < n.Open[4] && n.Close[0] < n.Open[0] && n.Close[0] < n.Low[4] && n.High[3] < n.High[4] && n.Low[3] > n.Low[4]
																	&& n.High[2] < n.High[4] && n.Low[2] > n.Low[4] && n.High[1] < n.High[4] && n.Low[1] > n.Low[4]; break;
					case ChartPattern.Hammer:				found = isInDownTrend && (min == null ? true : min[0] == n.Low[0]) && n.Low[0] < n.Open[0] - 5 * n.TickSize 
																	&& Math.Abs(n.Open[0] - n.Close[0]) < (0.10 * (n.High[0] - n.Low[0])) && (n.High[0] - n.Close[0]) < (0.25 * (n.High[0] - n.Low[0])); break;
					case ChartPattern.HangingMan:			found = isInUpTrend && (max == null ? true : max[0] == n.High[0]) && n.Low[0] < n.Open[0] - 5 * n.TickSize 
																	&& Math.Abs(n.Open[0] - n.Close[0]) < (0.10 * (n.High[0] - n.Low[0])) && (n.High[0] - n.Close[0]) < (0.25 * (n.High[0] - n.Low[0])); break;
					case ChartPattern.InvertedHammer:		found = isInUpTrend && (max == null ? true : max[0] == n.High[0]) && n.High[0] > n.Open[0] + 5 * n.TickSize 
																	&& Math.Abs(n.Open[0] - n.Close[0]) < (0.10 * (n.High[0] - n.Low[0])) && (n.Close[0] - n.Low[0]) < (0.25 * (n.High[0] - n.Low[0])); break;
					case ChartPattern.MorningStar:			found = n.Close[2] < n.Open[2] && n.Close[1] < n.Close[2] && n.Open[0] > (Math.Abs((n.Close[1] - n.Open[1]) / 2) + n.Open[1]) && n.Close[0] > n.Open[0]; break;
					case ChartPattern.PiercingLine:			found = isInDownTrend && n.Open[0] < n.Low[1] && n.Close[1] < n.Open[1] && n.Close[0] > n.Open[0] && n.Close[0] >= n.Close[1] + (n.Open[1] - n.Close[1]) / 2 && n.Close[0] <= n.Open[1]; break;
					case ChartPattern.RisingThreeMethods:	found = n.CurrentBar > 5 && n.Close[4] > n.Open[4] && n.Close[0] > n.Open[0] && n.Close[0] > n.High[4] && n.High[3] < n.High[4] && n.Low[3] > n.Low[4]
																	&& n.High[2] < n.High[4] && n.Low[2] > n.Low[4] && n.High[1] < n.High[4] && n.Low[1] > n.Low[4]; break;
					case ChartPattern.ShootingStar:			found = isInUpTrend && n.High[0] > n.Open[0] && (n.High[0] - n.Open[0]) >= 2 * (n.Open[0] - n.Close[0]) && n.Close[0] < n.Open[0] && (n.Close[0] - n.Low[0]) <= 2 * n.TickSize; break;
					case ChartPattern.StickSandwich:		found = n.Close[2] == n.Close[0] && n.Close[2] < n.Open[2] && n.Close[1] > n.Open[1] && n.Close[0] < n.Open[0]; break;
					case ChartPattern.ThreeBlackCrows:		found = isInUpTrend && n.Close[0] < n.Open[0] && n.Close[1] < n.Open[1] && n.Close[2] < n.Open[2] && n.Close[0] < n.Close[1] && n.Close[1] < n.Close[2]
																	&& n.Open[0] < n.Open[1] && n.Open[0] > n.Close[1] && n.Open[1] < n.Open[2] && n.Open[1] > n.Close[2]; break;
					case ChartPattern.ThreeWhiteSoldiers:	found = isInDownTrend && n.Close[0] > n.Open[0] && n.Close[1] > n.Open[1] && n.Close[2] > n.Open[2] && n.Close[0] > n.Close[1] && n.Close[1] > n.Close[2]
																	&& n.Open[0] < n.Close[1] && n.Open[0] > n.Open[1] && n.Open[1] < n.Close[2] && n.Open[1] > n.Open[2]; break;
					case ChartPattern.UpsideGapTwoCrows:	found = isInUpTrend && n.Close[2] > n.Open[2] && n.Close[1] < n.Open[1] && n.Close[0] < n.Open[0] && n.Low[1] > n.High[2]
																	&& n.Close[0] > n.High[2] && n.Close[0] < n.Close[1] && n.Open[0] > n.Open[1]; break;
					case ChartPattern.UpsideTasukiGap:		found = n.Close[2] > n.Open[2] && n.Close[1] > n.Open[1] && n.Close[0] < n. Open[0] && n.Low[1] > n.High[2]
																	&& n.Open[0] < n.Close[1] && n.Open[0] > n.Open[1] && n.Close[0] < n.Open[1] && n.Close[0] > n.Close[2]; break;
				}
			prior[n.CurrentBars[0] % 2] = found;

			return found;
		}
	}
}

public enum ChartPattern
{
	BearishBeltHold			= 0,
	BearishEngulfing		= 1,
	BearishHarami			= 2,
	BearishHaramiCross		= 3,
	BullishBeltHold			= 4,
	BullishEngulfing		= 5,
	BullishHarami			= 6,
	BullishHaramiCross		= 7,
	DarkCloudCover			= 8,
	Doji					= 9,
	DownsideTasukiGap		= 10,
	EveningStar				= 11,
	FallingThreeMethods		= 12,
	Hammer					= 13,
	HangingMan				= 14,
	InvertedHammer			= 15,
	MorningStar				= 16,
	PiercingLine			= 17,
	RisingThreeMethods		= 18,
	ShootingStar			= 19,
	StickSandwich			= 20,
	ThreeBlackCrows			= 21,
	ThreeWhiteSoldiers		= 22,
	UpsideGapTwoCrows		= 23,
	UpsideTasukiGap			= 24,
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private CandlestickPattern[] cacheCandlestickPattern;
		public CandlestickPattern CandlestickPattern(ChartPattern pattern, int trendStrength)
		{
			return CandlestickPattern(Input, pattern, trendStrength);
		}

		public CandlestickPattern CandlestickPattern(ISeries<double> input, ChartPattern pattern, int trendStrength)
		{
			if (cacheCandlestickPattern != null)
				for (int idx = 0; idx < cacheCandlestickPattern.Length; idx++)
					if (cacheCandlestickPattern[idx] != null && cacheCandlestickPattern[idx].Pattern == pattern && cacheCandlestickPattern[idx].TrendStrength == trendStrength && cacheCandlestickPattern[idx].EqualsInput(input))
						return cacheCandlestickPattern[idx];
			return CacheIndicator<CandlestickPattern>(new CandlestickPattern(){ Pattern = pattern, TrendStrength = trendStrength }, input, ref cacheCandlestickPattern);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.CandlestickPattern CandlestickPattern(ChartPattern pattern, int trendStrength)
		{
			return indicator.CandlestickPattern(Input, pattern, trendStrength);
		}

		public Indicators.CandlestickPattern CandlestickPattern(ISeries<double> input , ChartPattern pattern, int trendStrength)
		{
			return indicator.CandlestickPattern(input, pattern, trendStrength);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.CandlestickPattern CandlestickPattern(ChartPattern pattern, int trendStrength)
		{
			return indicator.CandlestickPattern(Input, pattern, trendStrength);
		}

		public Indicators.CandlestickPattern CandlestickPattern(ISeries<double> input , ChartPattern pattern, int trendStrength)
		{
			return indicator.CandlestickPattern(input, pattern, trendStrength);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Commodity Channel Index (CCI) measures the variation of a security's price
	/// from its statistical mean. High values show that prices are unusually high
	/// compared to average prices whereas low values indicate that prices are unusually low.
	/// </summary>
	public class CCI : Indicator
	{
		private SMA sma;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionCCI;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameCCI;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod,			NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameCCI);
				AddLine(Brushes.DarkGray,	200,	NinjaTrader.Custom.Resource.CCILevel2);
				AddLine(Brushes.DarkGray,	100,	NinjaTrader.Custom.Resource.CCILevel1);
				AddLine(Brushes.DarkGray,	0,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
				AddLine(Brushes.DarkGray,	-100,	NinjaTrader.Custom.Resource.CCILevelMinus1);
				AddLine(Brushes.DarkGray,	-200,	NinjaTrader.Custom.Resource.CCILevelMinus2);
			}
			else if (State == State.DataLoaded)
				sma  = SMA(Typical, Period);
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
				Value[0] = 0;
			else
			{
				double mean = 0;
				double sma0 = sma[0];

				for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)
					mean += Math.Abs(Typical[idx] - sma0);

				Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private CCI[] cacheCCI;
		public CCI CCI(int period)
		{
			return CCI(Input, period);
		}

		public CCI CCI(ISeries<double> input, int period)
		{
			if (cacheCCI != null)
				for (int idx = 0; idx < cacheCCI.Length; idx++)
					if (cacheCCI[idx] != null && cacheCCI[idx].Period == period && cacheCCI[idx].EqualsInput(input))
						return cacheCCI[idx];
			return CacheIndicator<CCI>(new CCI(){ Period = period }, input, ref cacheCCI);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.CCI CCI(int period)
		{
			return indicator.CCI(Input, period);
		}

		public Indicators.CCI CCI(ISeries<double> input , int period)
		{
			return indicator.CCI(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.CCI CCI(int period)
		{
			return indicator.CCI(Input, period);
		}

		public Indicators.CCI CCI(ISeries<double> input , int period)
		{
			return indicator.CCI(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Chaikin Money Flow.
	/// </summary>
	public class ChaikinMoneyFlow : Indicator
	{
		private	Series<double>		moneyFlow;
		private SUM					sumMoneyFlow;
		private SUM					sumVolume;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionChaikinMoneyFlow;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameChaikinMoneyFlow;
				IsSuspendedWhileInactive	= true;
				DrawOnPricePanel			= false;
				Period						= 21;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameChaikinMoneyFlow);
			}
			else if (State == State.DataLoaded)
			{
				moneyFlow		= new Series<double>(this);
				sumMoneyFlow	= SUM(moneyFlow, Period);
				sumVolume		= SUM(Volume, Period);
			}
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			double close0		= Close[0];
			double low0			= Low[0];
			double high0		= High[0];
			double volume0		= Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0];
			double sumVolume0	= Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)sumVolume[0]) : sumVolume[0];

			moneyFlow[0]		= volume0 * ((close0 - low0) - (high0 - close0)) / ((high0 - low0).ApproxCompare(0) == 0 ? 1 : (high0 - low0));
			
			double val 			= 100 * sumMoneyFlow[0] / sumVolume0;
			Value[0]			= double.IsNaN(val) ? 0 : val;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ChaikinMoneyFlow[] cacheChaikinMoneyFlow;
		public ChaikinMoneyFlow ChaikinMoneyFlow(int period)
		{
			return ChaikinMoneyFlow(Input, period);
		}

		public ChaikinMoneyFlow ChaikinMoneyFlow(ISeries<double> input, int period)
		{
			if (cacheChaikinMoneyFlow != null)
				for (int idx = 0; idx < cacheChaikinMoneyFlow.Length; idx++)
					if (cacheChaikinMoneyFlow[idx] != null && cacheChaikinMoneyFlow[idx].Period == period && cacheChaikinMoneyFlow[idx].EqualsInput(input))
						return cacheChaikinMoneyFlow[idx];
			return CacheIndicator<ChaikinMoneyFlow>(new ChaikinMoneyFlow(){ Period = period }, input, ref cacheChaikinMoneyFlow);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ChaikinMoneyFlow ChaikinMoneyFlow(int period)
		{
			return indicator.ChaikinMoneyFlow(Input, period);
		}

		public Indicators.ChaikinMoneyFlow ChaikinMoneyFlow(ISeries<double> input , int period)
		{
			return indicator.ChaikinMoneyFlow(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ChaikinMoneyFlow ChaikinMoneyFlow(int period)
		{
			return indicator.ChaikinMoneyFlow(Input, period);
		}

		public Indicators.ChaikinMoneyFlow ChaikinMoneyFlow(ISeries<double> input , int period)
		{
			return indicator.ChaikinMoneyFlow(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Chaikin Oscillator.
	/// </summary>
	public class ChaikinOscillator : Indicator
	{
		private Series<double>	cummulative;
		private EMA				emaFast;
		private EMA				emaSlow;
		private Series<double>	moneyFlow;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionChaikinOscillator;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameChaikinOscillator;
				Fast						= 3;
				DrawOnPricePanel			= false;
				IsSuspendedWhileInactive	= true;
				Slow						= 10;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameChaikinOscillator);
			}
			else if (State == State.DataLoaded)
			{
				cummulative		= new Series<double>(this);
				moneyFlow		= new Series<double>(this);
				emaFast			= EMA(cummulative, Fast);
				emaSlow			= EMA(cummulative, Slow);
			}
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			double close0	= Close[0];
			double low0		= Low[0];
			double high0	= High[0];
			double volume0	= Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0];

			moneyFlow[0]	= volume0 * ((close0 - low0) - (high0 - close0)) / ((high0 - low0).ApproxCompare(0) == 0 ? 1 : (high0 - low0));
			cummulative[0]	= moneyFlow[0] + (CurrentBar == 0 ? 0 : cummulative[1]);
			Value[0]		= emaFast[0] - emaSlow[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Fast", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Fast
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Slow", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Slow
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ChaikinOscillator[] cacheChaikinOscillator;
		public ChaikinOscillator ChaikinOscillator(int fast, int slow)
		{
			return ChaikinOscillator(Input, fast, slow);
		}

		public ChaikinOscillator ChaikinOscillator(ISeries<double> input, int fast, int slow)
		{
			if (cacheChaikinOscillator != null)
				for (int idx = 0; idx < cacheChaikinOscillator.Length; idx++)
					if (cacheChaikinOscillator[idx] != null && cacheChaikinOscillator[idx].Fast == fast && cacheChaikinOscillator[idx].Slow == slow && cacheChaikinOscillator[idx].EqualsInput(input))
						return cacheChaikinOscillator[idx];
			return CacheIndicator<ChaikinOscillator>(new ChaikinOscillator(){ Fast = fast, Slow = slow }, input, ref cacheChaikinOscillator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ChaikinOscillator ChaikinOscillator(int fast, int slow)
		{
			return indicator.ChaikinOscillator(Input, fast, slow);
		}

		public Indicators.ChaikinOscillator ChaikinOscillator(ISeries<double> input , int fast, int slow)
		{
			return indicator.ChaikinOscillator(input, fast, slow);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ChaikinOscillator ChaikinOscillator(int fast, int slow)
		{
			return indicator.ChaikinOscillator(Input, fast, slow);
		}

		public Indicators.ChaikinOscillator ChaikinOscillator(ISeries<double> input , int fast, int slow)
		{
			return indicator.ChaikinOscillator(input, fast, slow);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Chaikin Volatility
	/// </summary>
	public class ChaikinVolatility : Indicator
	{
		private EMA	ema;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionChaikinVolatility;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameChaikinVolatility;
				IsSuspendedWhileInactive	= true;
				MAPeriod					= 10;
				ROCPeriod					= 10;

				AddPlot(Brushes.Crimson, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameChaikinVolatility);
			}
			else if (State == State.DataLoaded)
				ema	= EMA(Range(), MAPeriod);
		}

		protected override void OnBarUpdate()
		{
			double emaROCPeriod	= ema[Math.Min(CurrentBar, ROCPeriod)];
			Value[0]			= CurrentBar == 0 ? ema[0] : ((ema[0] - emaROCPeriod) / emaROCPeriod) * 100;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "MAPeriod", GroupName = "NinjaScriptParameters", Order = 0)]
		public int MAPeriod
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "ROCPeriod", GroupName = "NinjaScriptParameters", Order = 1)]
		public int ROCPeriod
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ChaikinVolatility[] cacheChaikinVolatility;
		public ChaikinVolatility ChaikinVolatility(int mAPeriod, int rOCPeriod)
		{
			return ChaikinVolatility(Input, mAPeriod, rOCPeriod);
		}

		public ChaikinVolatility ChaikinVolatility(ISeries<double> input, int mAPeriod, int rOCPeriod)
		{
			if (cacheChaikinVolatility != null)
				for (int idx = 0; idx < cacheChaikinVolatility.Length; idx++)
					if (cacheChaikinVolatility[idx] != null && cacheChaikinVolatility[idx].MAPeriod == mAPeriod && cacheChaikinVolatility[idx].ROCPeriod == rOCPeriod && cacheChaikinVolatility[idx].EqualsInput(input))
						return cacheChaikinVolatility[idx];
			return CacheIndicator<ChaikinVolatility>(new ChaikinVolatility(){ MAPeriod = mAPeriod, ROCPeriod = rOCPeriod }, input, ref cacheChaikinVolatility);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ChaikinVolatility ChaikinVolatility(int mAPeriod, int rOCPeriod)
		{
			return indicator.ChaikinVolatility(Input, mAPeriod, rOCPeriod);
		}

		public Indicators.ChaikinVolatility ChaikinVolatility(ISeries<double> input , int mAPeriod, int rOCPeriod)
		{
			return indicator.ChaikinVolatility(input, mAPeriod, rOCPeriod);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ChaikinVolatility ChaikinVolatility(int mAPeriod, int rOCPeriod)
		{
			return indicator.ChaikinVolatility(Input, mAPeriod, rOCPeriod);
		}

		public Indicators.ChaikinVolatility ChaikinVolatility(ISeries<double> input , int mAPeriod, int rOCPeriod)
		{
			return indicator.ChaikinVolatility(input, mAPeriod, rOCPeriod);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class ChoppinessIndex : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description = NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionChoppinessIndex;
				Name		= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameChoppinessIndex;
				IsOverlay	= false;
				Period		= 14;

				AddPlot(Brushes.DodgerBlue,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameChoppinessIndex);
				AddLine(Brushes.DarkCyan, 38.2,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.DarkCyan, 62.8,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = (MAX(High, Period)[0] - MIN(Low, Period)[0]).ApproxCompare(0) == 0 || SUM(ATR(1), Period)[0].ApproxCompare(0) == 0 ? 0 : 100 * Math.Log10(SUM(ATR(1), Period)[0] / (MAX(High, Period)[0] - MIN(Low, Period)[0])) / Math.Log10(Period);
		}
		
		#region Properties
		[Range(2, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ChoppinessIndex[] cacheChoppinessIndex;
		public ChoppinessIndex ChoppinessIndex(int period)
		{
			return ChoppinessIndex(Input, period);
		}

		public ChoppinessIndex ChoppinessIndex(ISeries<double> input, int period)
		{
			if (cacheChoppinessIndex != null)
				for (int idx = 0; idx < cacheChoppinessIndex.Length; idx++)
					if (cacheChoppinessIndex[idx] != null && cacheChoppinessIndex[idx].Period == period && cacheChoppinessIndex[idx].EqualsInput(input))
						return cacheChoppinessIndex[idx];
			return CacheIndicator<ChoppinessIndex>(new ChoppinessIndex(){ Period = period }, input, ref cacheChoppinessIndex);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ChoppinessIndex ChoppinessIndex(int period)
		{
			return indicator.ChoppinessIndex(Input, period);
		}

		public Indicators.ChoppinessIndex ChoppinessIndex(ISeries<double> input , int period)
		{
			return indicator.ChoppinessIndex(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ChoppinessIndex ChoppinessIndex(int period)
		{
			return indicator.ChoppinessIndex(Input, period);
		}

		public Indicators.ChoppinessIndex ChoppinessIndex(ISeries<double> input , int period)
		{
			return indicator.ChoppinessIndex(input, period);
		}
	}
}

#endregion

#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The CMO differs from other momentum oscillators such as Relative Strength Index (RSI) and Stochastics.
	/// It uses both up and down days data in the numerator of the calculation to measure momentum directly.
	/// Primarily used to look for extreme overbought and oversold conditions, CMO can also be used to look for trends.
	/// </summary>
	public class CMO : Indicator
	{
		private Series<double>	down;
		private Series<double>	up;
		private SUM				sumDown;
		private SUM				sumUp;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionCMO;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameCMO;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= false;
				Period						= 14;

				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameCMO);
			}
			else if (State == State.DataLoaded)
			{
				down	= new Series<double>(this);
				up		= new Series<double>(this);
				sumDown	= SUM(down, Period);
				sumUp	= SUM(up, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				down[0]		= 0;
				up[0]		= 0;
				return;
			}

			double input0	= Input[0];
			double input1	= Input[1];
			down[0]			= Math.Max(input1 - input0, 0);
			up[0]			= Math.Max(input0 - input1, 0);

			double sumDown0 = sumDown[0];
			double sumUp0	= sumUp[0];

			if (sumUp0.ApproxCompare(sumDown0) == 0)
				Value[0] = 0;
			else
				Value[0] = 100 * ((sumUp0 - sumDown0) / (sumUp0 + sumDown0));
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private CMO[] cacheCMO;
		public CMO CMO(int period)
		{
			return CMO(Input, period);
		}

		public CMO CMO(ISeries<double> input, int period)
		{
			if (cacheCMO != null)
				for (int idx = 0; idx < cacheCMO.Length; idx++)
					if (cacheCMO[idx] != null && cacheCMO[idx].Period == period && cacheCMO[idx].EqualsInput(input))
						return cacheCMO[idx];
			return CacheIndicator<CMO>(new CMO(){ Period = period }, input, ref cacheCMO);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.CMO CMO(int period)
		{
			return indicator.CMO(Input, period);
		}

		public Indicators.CMO CMO(ISeries<double> input , int period)
		{
			return indicator.CMO(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.CMO CMO(int period)
		{
			return indicator.CMO(Input, period);
		}

		public Indicators.CMO CMO(ISeries<double> input , int period)
		{
			return indicator.CMO(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Plots lines at user  defined values.
	/// </summary>
	public class ConstantLines : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionConstantLines;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameConstantLines;
				IsSuspendedWhileInactive	= true;
				Line1Value					= 0;
				Line2Value					= 0;
				Line3Value					= 0;
				Line4Value					= 0;
				IsAutoScale					= false;
				IsOverlay					= true;

				IsChartOnly					= true;
				DisplayInDataBox			= false;

				AddPlot(new Stroke(Brushes.DodgerBlue),	PlotStyle.HLine, NinjaTrader.Custom.Resource.ConstantLines1);
				AddPlot(new Stroke(Brushes.DarkCyan),	PlotStyle.HLine, NinjaTrader.Custom.Resource.ConstantLines2);
				AddPlot(new Stroke(Brushes.SlateBlue),	PlotStyle.HLine, NinjaTrader.Custom.Resource.ConstantLines3);
				AddPlot(new Stroke(Brushes.Goldenrod),	PlotStyle.HLine, NinjaTrader.Custom.Resource.ConstantLines4);
			}
		}

		protected override void OnBarUpdate()
		{
			if (Line1Value != 0) Line1[0] = Line1Value;
			if (Line2Value != 0) Line2[0] = Line2Value;
			if (Line3Value != 0) Line3[0] = Line3Value;
			if (Line4Value != 0) Line4[0] = Line4Value;
		}

		#region Properties
		[Browsable(false)]	// This line prevents the data series from being displayed in the indicator properties dialog, do not remove
		[XmlIgnore()]		// This line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
		public Series<double> Line1
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Line2
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Line3
		{
			get { return Values[2]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Line4
		{
			get { return Values[3]; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Line1Value", GroupName = "NinjaScriptParameters", Order = 0)]
		public double Line1Value
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Line2Value", GroupName = "NinjaScriptParameters", Order = 1)]
		public double Line2Value
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Line3Value", GroupName = "NinjaScriptParameters", Order = 2)]
		public double Line3Value
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Line4Value", GroupName = "NinjaScriptParameters", Order = 3)]
		public double Line4Value
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ConstantLines[] cacheConstantLines;
		public ConstantLines ConstantLines(double line1Value, double line2Value, double line3Value, double line4Value)
		{
			return ConstantLines(Input, line1Value, line2Value, line3Value, line4Value);
		}

		public ConstantLines ConstantLines(ISeries<double> input, double line1Value, double line2Value, double line3Value, double line4Value)
		{
			if (cacheConstantLines != null)
				for (int idx = 0; idx < cacheConstantLines.Length; idx++)
					if (cacheConstantLines[idx] != null && cacheConstantLines[idx].Line1Value == line1Value && cacheConstantLines[idx].Line2Value == line2Value && cacheConstantLines[idx].Line3Value == line3Value && cacheConstantLines[idx].Line4Value == line4Value && cacheConstantLines[idx].EqualsInput(input))
						return cacheConstantLines[idx];
			return CacheIndicator<ConstantLines>(new ConstantLines(){ Line1Value = line1Value, Line2Value = line2Value, Line3Value = line3Value, Line4Value = line4Value }, input, ref cacheConstantLines);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ConstantLines ConstantLines(double line1Value, double line2Value, double line3Value, double line4Value)
		{
			return indicator.ConstantLines(Input, line1Value, line2Value, line3Value, line4Value);
		}

		public Indicators.ConstantLines ConstantLines(ISeries<double> input , double line1Value, double line2Value, double line3Value, double line4Value)
		{
			return indicator.ConstantLines(input, line1Value, line2Value, line3Value, line4Value);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ConstantLines ConstantLines(double line1Value, double line2Value, double line3Value, double line4Value)
		{
			return indicator.ConstantLines(Input, line1Value, line2Value, line3Value, line4Value);
		}

		public Indicators.ConstantLines ConstantLines(ISeries<double> input , double line1Value, double line2Value, double line3Value, double line4Value)
		{
			return indicator.ConstantLines(input, line1Value, line2Value, line3Value, line4Value);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class Correlation : Indicator
	{
		private		double				avg0;
		private		double				avg1;
		private		SessionIterator		sessionIterator;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description			= Custom.Resource.NinjaScriptIndicatorDescriptionCorrelation;
				Name				= Custom.Resource.NinjaScriptIndicatorNameCorrelation;
				Calculate			= Calculate.OnBarClose;
				IsOverlay			= false;
				Period				= 10;
				CorrelationSeries	= string.Empty;

				AddPlot(new Stroke(Brushes.Goldenrod, 1), PlotStyle.Line, Custom.Resource.NinjaScriptIndicatorNameCorrelation);
			}
			else if (State == State.Configure && !string.IsNullOrWhiteSpace(CorrelationSeries))
				AddDataSeries(CorrelationSeries);
		}

		private SessionIterator SessionIterator
		{
			get
			{
				if (sessionIterator == null && BarsArray.Length == 2 && BarsArray[1] != null)
					sessionIterator = new SessionIterator(BarsArray[1]);
				return sessionIterator;
			}
		}
		protected override void OnBarUpdate()
		{
			if (BarsInProgress == 1)
			{
				avg1 = SMA(BarsArray[1], Period)[0];
				return;
			}

			if (SessionIterator == null || CurrentBars[0] < Period || CurrentBars[1] < Period)
				return;

			if (Bars.BarsType.IsIntraday && !SessionIterator.IsInSession(Times[0][0], true, true))
				return;

			avg0 = SMA(BarsArray[0], Period)[0];

			double nominator	= 0;
			double denominator1 = 0;
			double denominator2 = 0;

			for (int i = 0; i < Period; i++)
			{
				nominator		+= (avg0 - Inputs[0][i]) * (avg1 - Inputs[1][i]);
				denominator1	+= (avg0 - Inputs[0][i]) * (avg0 - Inputs[0][i]);
				denominator2	+= (avg1 - Inputs[1][i]) * (avg1 - Inputs[1][i]);
			}

			double denominator	= Math.Sqrt(denominator1) * Math.Sqrt(denominator2);

			Value[0]			= denominator.ApproxCompare(0) == 0 ? 0 : nominator / denominator;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "NinjaScriptIndicatorCount", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period { get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "NinjaScriptMarketAnalyzerColumnNameInstrument", GroupName = "NinjaScriptParameters", Order = 0)]
		[PropertyEditor("NinjaTrader.Gui.Tools.UppercaseTextEditor")]
		public string CorrelationSeries { get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Correlation[] cacheCorrelation;
		public Correlation Correlation(int period, string correlationSeries)
		{
			return Correlation(Input, period, correlationSeries);
		}

		public Correlation Correlation(ISeries<double> input, int period, string correlationSeries)
		{
			if (cacheCorrelation != null)
				for (int idx = 0; idx < cacheCorrelation.Length; idx++)
					if (cacheCorrelation[idx] != null && cacheCorrelation[idx].Period == period && cacheCorrelation[idx].CorrelationSeries == correlationSeries && cacheCorrelation[idx].EqualsInput(input))
						return cacheCorrelation[idx];
			return CacheIndicator<Correlation>(new Correlation(){ Period = period, CorrelationSeries = correlationSeries }, input, ref cacheCorrelation);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Correlation Correlation(int period, string correlationSeries)
		{
			return indicator.Correlation(Input, period, correlationSeries);
		}

		public Indicators.Correlation Correlation(ISeries<double> input , int period, string correlationSeries)
		{
			return indicator.Correlation(input, period, correlationSeries);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Correlation Correlation(int period, string correlationSeries)
		{
			return indicator.Correlation(Input, period, correlationSeries);
		}

		public Indicators.Correlation Correlation(ISeries<double> input , int period, string correlationSeries)
		{
			return indicator.Correlation(input, period, correlationSeries);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX;
using SharpDX.DirectWrite;

#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Commitment of traders indicator
	/// </summary>
	[TypeConverter("NinjaTrader.NinjaScript.Indicators.COTTypeConverter")]
	public class COT : Indicator
	{
		private		bool					backCalculated;
		private		CotReport[]				reports;
		private		TextFormat				textFormat;
		private		Gui.Tools.SimpleFont	font;

		private Vector2 GetPosition(TextLayout textLayout, int pos)
		{
			switch (LegendLocation)
			{
				case LegendLocation.TopLeft		: return new Vector2(8, ChartPanel.Y + 12 + (pos + 1) * textLayout.Metrics.Height);
				case LegendLocation.TopRight	: return new Vector2(ChartPanel.W - 8 - textLayout.Metrics.Width, ChartPanel.Y + 12 + (pos + 1) * textLayout.Metrics.Height);
				case LegendLocation.BottomLeft	: return new Vector2(8, ChartPanel.Y + (float)ChartPanel.H - (Number + 1 - pos) * textLayout.Metrics.Height);
				case LegendLocation.BottomRight	: return new Vector2(ChartPanel.W - 8 - textLayout.Metrics.Width, ChartPanel.Y + (float)ChartPanel.H - (Number + 1 - pos) * textLayout.Metrics.Height);
			}
			return new Vector2(-1,-1);
		}

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= Custom.Resource.NinjaScriptIndicatorDescriptionCOT;
				Name						= Custom.Resource.NinjaScriptIndicatorNameCOT;
				IsSuspendedWhileInactive	= true;
				Number						= 3;
				LegendLocation				= LegendLocation.TopLeft;

				CotReport1					= new CotReport { ReportType = CotReportType.Futures, Field = CotReportField.NoncommercialNet };
				CotReport2					= new CotReport { ReportType = CotReportType.Futures, Field = CotReportField.CommercialNet };
				CotReport3					= new CotReport { ReportType = CotReportType.Futures, Field = CotReportField.NonreportablePositionsNet };
				CotReport4					= new CotReport { ReportType = CotReportType.Futures, Field = CotReportField.OpenInterest };
				CotReport5					= new CotReport { ReportType = CotReportType.Futures, Field = CotReportField.TotalNet };

				AddPlot(Brushes.CornflowerBlue,	Custom.Resource.COT1);
				AddPlot(Brushes.Red,			Custom.Resource.COT2);
				AddPlot(Brushes.LimeGreen,		Custom.Resource.COT3);
				AddPlot(Brushes.Goldenrod,		Custom.Resource.COT4);
				AddPlot(Brushes.BlueViolet,		Custom.Resource.COT5);
			}
			else if (State == State.Configure)
			{
				reports				= new[] { CotReport1, CotReport2, CotReport3, CotReport4, CotReport5 };
				BarsRequiredToPlot	= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (CotData.GetCotReportNames(Instrument.MasterInstrument.Name).Count == 0)
			{
				Draw.TextFixed(this, "Error", Custom.Resource.CotDataError, TextPosition.BottomRight);
				return;
			}

			if (!Core.Globals.MarketDataOptions.DownloadCotData)
				Draw.TextFixed(this, "Warning", Custom.Resource.CotDataWarning, TextPosition.BottomRight);

			if (CotData.IsDownloadingData)
			{
				Draw.TextFixed(this, "Warning", Custom.Resource.CotDataStillDownloading, TextPosition.BottomRight);
				return;
			}

			for (int i = 0; i < Number; i++)
			{
				if (!backCalculated && CurrentBar > 0)
				{
					for (int j = CurrentBar - 1; j >= 0; j--)
					{
						double value1 = reports[i].Calculate(Instrument.MasterInstrument.Name, Time[j]);
						if (!double.IsNaN(value1)) // returns NaN if Instrument/Report combination is not valid.
							Values[i][j] = value1;
					}
				}
				double value = reports[i].Calculate(Instrument.MasterInstrument.Name, Time[0]);
				if (!double.IsNaN(value)) // returns NaN if Instrument/Report combination is not valid.
					Values[i][0] = value;
			}
			backCalculated = true;
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
		{
			base.OnRender(chartControl, chartScale);
			if (!backCalculated || LegendLocation == LegendLocation.Disabled)
				return;

			if (font == null || !font.Equals(chartControl.Properties.LabelFont) || textFormat == null || textFormat.IsDisposed)
			{
				if (textFormat != null && !textFormat.IsDisposed)
					textFormat.Dispose();
				font		= chartControl.Properties.LabelFont;
				textFormat	= font.ToDirectWriteTextFormat();
			}

			for (int i = 0; i < Number; i++)
			{
				TextLayout d = new TextLayout(Core.Globals.DirectWriteFactory, Core.Globals.ToLocalizedObject(reports[i].Field, Core.Globals.GeneralOptions.CurrentUICulture), textFormat, ChartPanel.W, textFormat.FontSize);
				RenderTarget.DrawTextLayout(GetPosition(d, i), d, Plots[i].BrushDX);
				d.Dispose();
			}
		}

		#region Properties

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Cot1 { get { return Values[0]; } }

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Cot2 { get { return Values[1]; } }

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Cot3 { get { return Values[2]; } }

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Cot4 { get { return Values[3]; } }

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Cot5 { get { return Values[4]; } }

		[Range(1, 5)]
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "NumberOfCotPlots", GroupName = "NinjaScriptParameters", Order = 0)]
		[TypeConverter(typeof(RangeEnumConverter))]
		[RefreshProperties(RefreshProperties.All)]
		public int Number { get; set; }

		//[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "COT1", GroupName = "NinjaScriptParameters", Order = 1)]
		[XmlIgnore]
		public CotReport CotReport1 {  get; set; }

		//[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "COT2", GroupName = "NinjaScriptParameters", Order = 2)]
		[XmlIgnore]
		public CotReport CotReport2 {  get; set; }

		//[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "COT3", GroupName = "NinjaScriptParameters", Order = 3)]
		[XmlIgnore]
		public CotReport CotReport3 {  get; set; }

		//[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "COT4", GroupName = "NinjaScriptParameters", Order = 4)]
		[XmlIgnore]
		public CotReport CotReport4 {  get; set; }

		//[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "COT5", GroupName = "NinjaScriptParameters", Order = 5)]
		[XmlIgnore]
		public CotReport CotReport5 {  get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "LegendLocation", GroupName = "NinjaScriptParameters", Order = 6)]
		public LegendLocation LegendLocation { get; set; }

		[Browsable(false)]
		public int Cot1Serialize
		{
			get { return (int) CotReport1.ReportType * 100 + (int) CotReport1.Field; }
			set { CotReport1 = new CotReport { ReportType = (CotReportType) (value / 100), Field = (CotReportField) (value % 100) };}
		}

		[Browsable(false)]
		public int Cot2Serialize
		{
			get { return (int) CotReport2.ReportType * 100 + (int) CotReport2.Field; }
			set { CotReport2 = new CotReport { ReportType = (CotReportType) (value / 100), Field = (CotReportField) (value % 100) };}
		}

		[Browsable(false)]
		public int Cot3Serialize
		{
			get { return (int) CotReport3.ReportType * 100 + (int) CotReport3.Field; }
			set { CotReport3 = new CotReport { ReportType = (CotReportType) (value / 100), Field = (CotReportField) (value % 100) };}
		}

		[Browsable(false)]
		public int Cot4Serialize
		{
			get { return (int) CotReport4.ReportType * 100 + (int) CotReport4.Field; }
			set { CotReport4 = new CotReport { ReportType = (CotReportType) (value / 100), Field = (CotReportField) (value % 100) };}
		}

		[Browsable(false)]
		public int Cot5Serialize
		{
			get { return (int) CotReport5.ReportType * 100 + (int) CotReport5.Field; }
			set { CotReport5 = new CotReport { ReportType = (CotReportType) (value / 100), Field = (CotReportField) (value % 100) };}
		}

		#endregion
	}

	[TypeConverter("NinjaTrader.Custom.ResourceEnumConverter")]
	public enum LegendLocation
	{
		Disabled,
		TopLeft,
		TopRight,
		BottomLeft,
		BottomRight
	}

	public class COTTypeConverter : IndicatorBaseConverter
	{
		public override bool GetPropertiesSupported(ITypeDescriptorContext context) { return true; }

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection propertyDescriptorCollection = base.GetPropertiesSupported(context) ? base.GetProperties(context, value, attributes) : TypeDescriptor.GetProperties(value, attributes);

			COT	thisCotInstance			= (COT) value;
			int	number					= thisCotInstance.Number;
			if (number == 5)
				return propertyDescriptorCollection;

			PropertyDescriptorCollection	adjusted	= new PropertyDescriptorCollection(null);
			List<string>					propsToSkip	= new List<string>();

			for (int i = number + 1; i <= 5; i++)
			{
				propsToSkip.Add("CotReport" + i);
				propsToSkip.Add("Plot" + (i - 1));
			}

			if (propertyDescriptorCollection != null)
				foreach (PropertyDescriptor thisDescriptor in propertyDescriptorCollection)
				{
					if (propsToSkip.Contains(thisDescriptor.Name))
						adjusted.Add(new PropertyDescriptorExtended(thisDescriptor, o => value, null, new Attribute[] { new BrowsableAttribute(false) }));
					else
						adjusted.Add(thisDescriptor);
				}

			return adjusted;
		}
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private COT[] cacheCOT;
		public COT COT(int number)
		{
			return COT(Input, number);
		}

		public COT COT(ISeries<double> input, int number)
		{
			if (cacheCOT != null)
				for (int idx = 0; idx < cacheCOT.Length; idx++)
					if (cacheCOT[idx] != null && cacheCOT[idx].Number == number && cacheCOT[idx].EqualsInput(input))
						return cacheCOT[idx];
			return CacheIndicator<COT>(new COT() { Number = number }, input, ref cacheCOT);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.COT COT(int number)
		{
			return indicator.COT(Input, number);
		}

		public Indicators.COT COT(ISeries<double> input, int number)
		{
			return indicator.COT(input, number);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.COT COT(int number)
		{
			return indicator.COT(Input, number);
		}

		public Indicators.COT COT(ISeries<double> input, int number)
		{
			return indicator.COT(input, number);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Plots the open, high, and low values from the session starting on the current day.
	/// </summary>
	public class CurrentDayOHL : Indicator
	{
		private DateTime			currentDate			=	Core.Globals.MinDate;
		private double				currentOpen			=	double.MinValue;
		private double				currentHigh			=	double.MinValue;
		private double				currentLow			=	double.MaxValue;
		private DateTime			lastDate			= 	Core.Globals.MinDate;
		private SessionIterator		sessionIterator;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= Custom.Resource.NinjaScriptIndicatorDescriptionCurrentDayOHL;
				Name						= Custom.Resource.NinjaScriptIndicatorNameCurrentDayOHL;
				IsAutoScale					= false;
				DrawOnPricePanel			= false;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				ShowLow						= true;
				ShowHigh					= true;
				ShowOpen					= true;
				BarsRequiredToPlot			= 0;

				AddPlot(new Stroke(Brushes.Goldenrod,	DashStyleHelper.Dash, 2), PlotStyle.Square, Custom.Resource.CurrentDayOHLOpen);
				AddPlot(new Stroke(Brushes.SeaGreen,	DashStyleHelper.Dash, 2), PlotStyle.Square, Custom.Resource.CurrentDayOHLHigh);
				AddPlot(new Stroke(Brushes.Red,			DashStyleHelper.Dash, 2), PlotStyle.Square, Custom.Resource.CurrentDayOHLLow);
			}
			else if (State == State.Configure)
			{
				currentDate			= Core.Globals.MinDate;
				currentOpen			= double.MinValue;
				currentHigh			= double.MinValue;
				currentLow			= double.MaxValue;
				lastDate			= Core.Globals.MinDate;
			}
			else if (State == State.DataLoaded)
			{
				sessionIterator = new SessionIterator(Bars);
			}
			else if (State == State.Historical)
			{
				if (!Bars.BarsType.IsIntraday)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", Custom.Resource.CurrentDayOHLError, TextPosition.BottomRight);
					Log(Custom.Resource.CurrentDayOHLError, LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (!Bars.BarsType.IsIntraday) return;

			lastDate 		= currentDate;
			currentDate 	= sessionIterator.GetTradingDay(Time[0]);
			
			if (lastDate != currentDate || currentOpen == double.MinValue)
			{
				currentOpen		= Open[0];
				currentHigh		= High[0];
				currentLow		= Low[0];
			}

			currentHigh			= Math.Max(currentHigh, High[0]);
			currentLow			= Math.Min(currentLow, Low[0]);

			if (ShowOpen)
				CurrentOpen[0] = currentOpen;

			if (ShowHigh)
				CurrentHigh[0] = currentHigh;

			if (ShowLow)
				CurrentLow[0] = currentLow;
		}

		#region Properties
		[Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
		[XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
		public Series<double> CurrentOpen
		{
			get { return Values[0]; }
		}

		[Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
		[XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
		public Series<double> CurrentHigh
		{
			get { return Values[1]; }
		}

		[Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
		[XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
		public Series<double> CurrentLow
		{
			get { return Values[2]; }
		}

		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowHigh", GroupName = "NinjaScriptParameters", Order = 1)]
		public bool ShowHigh
		{ get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowLow", GroupName = "NinjaScriptParameters", Order = 2)]
		public bool ShowLow
		{ get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowOpen", GroupName = "NinjaScriptParameters", Order = 3)]
		public bool ShowOpen
		{ get; set; }
		#endregion
		
		public override string FormatPriceMarker(double price)
		{
			return Instrument.MasterInstrument.FormatPrice(price);
		}
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private CurrentDayOHL[] cacheCurrentDayOHL;
		public CurrentDayOHL CurrentDayOHL()
		{
			return CurrentDayOHL(Input);
		}

		public CurrentDayOHL CurrentDayOHL(ISeries<double> input)
		{
			if (cacheCurrentDayOHL != null)
				for (int idx = 0; idx < cacheCurrentDayOHL.Length; idx++)
					if (cacheCurrentDayOHL[idx] != null &&  cacheCurrentDayOHL[idx].EqualsInput(input))
						return cacheCurrentDayOHL[idx];
			return CacheIndicator<CurrentDayOHL>(new CurrentDayOHL(), input, ref cacheCurrentDayOHL);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.CurrentDayOHL CurrentDayOHL()
		{
			return indicator.CurrentDayOHL(Input);
		}

		public Indicators.CurrentDayOHL CurrentDayOHL(ISeries<double> input )
		{
			return indicator.CurrentDayOHL(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.CurrentDayOHL CurrentDayOHL()
		{
			return indicator.CurrentDayOHL(Input);
		}

		public Indicators.CurrentDayOHL CurrentDayOHL(ISeries<double> input )
		{
			return indicator.CurrentDayOHL(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class Darvas : Indicator
	{
		private double			boxBottom				= double.MaxValue;
		private double			boxTop					= double.MinValue;
		private bool			buySignal;
		private double			currentBarHigh			= double.MinValue;
		private double			currentBarLow			= double.MaxValue;
		private bool			isRealtime;
		private int				savedCurrentBar			= -1;
		private bool			sellSignal;
		private int				startBarActBox;
		private int				state;

		private int				prevCurrentBar			= -1;
		private Series<double>	boxBottomSeries;
		private Series<double>	boxTopSeries;
		private Series<double>	currentBarHighSeries;
		private Series<double>	currentBarLowSeries;
		private Series<int>		startBarActBoxSeries;
		private Series<int>		stateSeries;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description	= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionDarvas;
				Name		= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDarvas;
				IsOverlay	= true;
				Calculate	= Calculate.OnBarClose;

				AddPlot(new Stroke(Brushes.Crimson,		2), PlotStyle.Square, NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddPlot(new Stroke(Brushes.DarkCyan,	2), PlotStyle.Square, NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
			else if (State == State.DataLoaded)
			{
				if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
				{
					boxBottomSeries			= new Series<double>(this);
					boxTopSeries			= new Series<double>(this);
					currentBarHighSeries	= new Series<double>(this);
					currentBarLowSeries		= new Series<double>(this);
					startBarActBoxSeries	= new Series<int>(this);
					stateSeries				= new Series<int>(this);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			BuySignal	= false;
			SellSignal	= false;

			if (BarsArray[0].BarsType.IsRemoveLastBarSupported && CurrentBar < prevCurrentBar)
			{
				boxBottom		= boxBottomSeries[0];
				boxTop			= boxTopSeries[0];
				currentBarHigh	= currentBarHighSeries[0];
				currentBarLow	= currentBarLowSeries[0];
				startBarActBox	= startBarActBoxSeries[0];
				state			= stateSeries[0];
			}

			if (savedCurrentBar == -1)
			{
				currentBarHigh	= High[0];
				currentBarLow	= Low[0];
				state			= GetNextState();
				savedCurrentBar = CurrentBar;
			}
			else if (savedCurrentBar != CurrentBar)
			{
				// Check for new bar
				currentBarHigh	= (isRealtime && Calculate == Calculate.OnEachTick) ? High[1] : High[0];
				currentBarLow	= (isRealtime && Calculate == Calculate.OnEachTick) ? Low[1] : Low[0];

				// Today buy/sell signal is triggered
				if ((state == 5 && currentBarHigh > boxTop) || (state == 5 && currentBarLow < boxBottom))
				{
					if (state == 5 && currentBarHigh > boxTop)
						BuySignal = true;
					else
						SellSignal = true;

					state			 = 0;
					startBarActBox	 = CurrentBar;
				}

				state = GetNextState();
				// Draw with today
				if (boxBottom == double.MaxValue)
					for (int i = CurrentBar - startBarActBox; i >= 0; i--)
					{
						Upper[i] = boxTop;
					}
				else
					for (int i = CurrentBar - startBarActBox; i >= 0; i--)
					{
						Upper[i] = boxTop;
						Lower[i] = boxBottom;
					}
			}
			else
			{
				isRealtime = true;

				// Today buy/sell signal is triggered
				if ((state == 5 && currentBarHigh > boxTop) || (state == 5 && currentBarLow < boxBottom))
				{
					if (state == 5 && currentBarHigh > boxTop)
						BuySignal = true;
					else
						SellSignal = true;

					startBarActBox = CurrentBar + 1;
					state = 0;
				}

				// Draw with today
				if (boxBottom == double.MaxValue)
				{
					Upper[0] = boxTop;
				}
				else
				{
					Upper[0] = boxTop;
					Lower[0] = boxBottom;
				}
			}

			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				boxBottomSeries[0]		= boxBottom;
				boxTopSeries[0]			= boxTop;
				currentBarHighSeries[0]	= currentBarHigh;
				currentBarLowSeries[0]	= currentBarLow;
				startBarActBoxSeries[0]	= startBarActBox;
				stateSeries[0]			= state;
				prevCurrentBar			= CurrentBar;
			}
		}

		#region Miscellaneous
		private int GetNextState()
		{
			switch (state)
			{
				case 0:
					boxTop		= currentBarHigh;
					boxBottom	= double.MaxValue;
					return 1;

				case 1:
					if (boxTop > currentBarHigh)
						return 2;
					else
					{
						boxTop = currentBarHigh;
						return 1;
					}

				case 2:
					if (boxTop > currentBarHigh)
					{
						boxBottom = currentBarLow;
						return 3;
					}
					else
					{
						boxTop = currentBarHigh;
						return 1;
					}

				case 3:
					if (boxTop > currentBarHigh)
					{
						if (boxBottom < currentBarLow)
							return 4;
						else
						{
							boxBottom = currentBarLow;
							return 3;
						}
					}
					else
					{
						boxTop		= currentBarHigh;
						boxBottom	= double.MaxValue;
						return 1;
					}

				case 4:
					if (boxTop > currentBarHigh)
					{
						if (boxBottom < currentBarLow)
							return 5;
						else
						{
							boxBottom = currentBarLow;
							return 3;
						}
					}
					else
					{
						boxTop		= currentBarHigh;
						boxBottom	= double.MaxValue;
						return 1;
					}

				case 5:
					return 5;

				default:			// Should not happen
					return state;
			}

		}
		#endregion

		#region Properties
		[Browsable(false)]
		[XmlIgnore]
		public bool BuySignal
		{
			get
			{
				Update();
				return buySignal;
			}
			set { buySignal = value; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Lower
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public bool SellSignal
		{
			get
			{
				Update();
				return sellSignal;
			}
			set { sellSignal = value; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Upper
		{
			get { return Values[1]; }
		}
		#endregion

	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Darvas[] cacheDarvas;
		public Darvas Darvas()
		{
			return Darvas(Input);
		}

		public Darvas Darvas(ISeries<double> input)
		{
			if (cacheDarvas != null)
				for (int idx = 0; idx < cacheDarvas.Length; idx++)
					if (cacheDarvas[idx] != null &&  cacheDarvas[idx].EqualsInput(input))
						return cacheDarvas[idx];
			return CacheIndicator<Darvas>(new Darvas(), input, ref cacheDarvas);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Darvas Darvas()
		{
			return indicator.Darvas(Input);
		}

		public Indicators.Darvas Darvas(ISeries<double> input )
		{
			return indicator.Darvas(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Darvas Darvas()
		{
			return indicator.Darvas(Input);
		}

		public Indicators.Darvas Darvas(ISeries<double> input )
		{
			return indicator.Darvas(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Double Exponential Moving Average
	/// </summary>
	public class DEMA : Indicator
	{
		private EMA ema;
		private EMA emaEma;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionDEMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDEMA;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDEMA);
			}
			else if (State == State.DataLoaded)
			{
				ema		= EMA(Inputs[0], Period);
				emaEma	= EMA(ema, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = 2 * ema[0] -  emaEma[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private DEMA[] cacheDEMA;
		public DEMA DEMA(int period)
		{
			return DEMA(Input, period);
		}

		public DEMA DEMA(ISeries<double> input, int period)
		{
			if (cacheDEMA != null)
				for (int idx = 0; idx < cacheDEMA.Length; idx++)
					if (cacheDEMA[idx] != null && cacheDEMA[idx].Period == period && cacheDEMA[idx].EqualsInput(input))
						return cacheDEMA[idx];
			return CacheIndicator<DEMA>(new DEMA(){ Period = period }, input, ref cacheDEMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.DEMA DEMA(int period)
		{
			return indicator.DEMA(Input, period);
		}

		public Indicators.DEMA DEMA(ISeries<double> input , int period)
		{
			return indicator.DEMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.DEMA DEMA(int period)
		{
			return indicator.DEMA(Input, period);
		}

		public Indicators.DEMA DEMA(ISeries<double> input , int period)
		{
			return indicator.DEMA(input, period);
		}
	}
}

#endregion


#########################

﻿//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Windows.Media;
using System.Xml.Serialization;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Disparity Index measures the difference between the price and an exponential moving average. A value greater could suggest bullish momentum, while a value less than zero could suggest bearish momentum.
	/// </summary>
	public class DisparityIndex : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionDisparityIndex;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDisparityIndex;
				IsOverlay					= false;
				IsSuspendedWhileInactive	= true;
				Period 						= 25;
				
				AddPlot(Brushes.DodgerBlue,   NinjaTrader.Custom.Resource.NinjaScriptIndicatorDisparityLine);
				AddLine(Brushes.DarkGray, 0,  NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
		}

		protected override void OnBarUpdate()
		{
			if (Close[0] <= 0)
				return;
			
			DisparityLine[0] = 100 * (Close[0] - EMA(Close, Period)[0]) / Close[0];
		}	
		
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period { get; set; }

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> DisparityLine { get { return Values[0]; } }
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private DisparityIndex[] cacheDisparityIndex;
		public DisparityIndex DisparityIndex(int period)
		{
			return DisparityIndex(Input, period);
		}

		public DisparityIndex DisparityIndex(ISeries<double> input, int period)
		{
			if (cacheDisparityIndex != null)
				for (int idx = 0; idx < cacheDisparityIndex.Length; idx++)
					if (cacheDisparityIndex[idx] != null && cacheDisparityIndex[idx].Period == period && cacheDisparityIndex[idx].EqualsInput(input))
						return cacheDisparityIndex[idx];
			return CacheIndicator<DisparityIndex>(new DisparityIndex(){ Period = period }, input, ref cacheDisparityIndex);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.DisparityIndex DisparityIndex(int period)
		{
			return indicator.DisparityIndex(Input, period);
		}

		public Indicators.DisparityIndex DisparityIndex(ISeries<double> input , int period)
		{
			return indicator.DisparityIndex(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.DisparityIndex DisparityIndex(int period)
		{
			return indicator.DisparityIndex(Input, period);
		}

		public Indicators.DisparityIndex DisparityIndex(ISeries<double> input , int period)
		{
			return indicator.DisparityIndex(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Directional Movement (DM). This is the same indicator as the ADX,
	/// with the addition of the two directional movement indicators +DI
	/// and -DI. +DI and -DI measure upward and downward momentum. A buy
	/// signal is generated when +DI crosses -DI to the upside.
	/// A sell signal is generated when -DI crosses +DI to the downside.
	/// </summary>
	public class DM : Indicator
	{
		private Series<double> dmPlus;
		private Series<double> dmMinus;
		private Series<double> sumDmPlus;
		private Series<double> sumDmMinus;
		private Series<double> sumTr;
		private Series<double> tr;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionDM;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDM;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(new Stroke(Brushes.DarkSeaGreen, 2),	PlotStyle.Line,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameADX);
				AddPlot(Brushes.DodgerBlue,										NinjaTrader.Custom.Resource.DMPlusDI);
				AddPlot(Brushes.Crimson,										NinjaTrader.Custom.Resource.DMMinusDI);

				AddLine(Brushes.DarkCyan,						25,				NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.DarkCyan,						75,				NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}

			else if (State == State.DataLoaded)
			{
				dmPlus		= new Series<double>(this);
				dmMinus		= new Series<double>(this);
				sumDmPlus	= new Series<double>(this);
				sumDmMinus	= new Series<double>(this);
				sumTr		= new Series<double>(this);
				tr			= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			double high0		= High[0];
			double low0			= Low[0];
			double trueRange	= high0 - low0;

			if (CurrentBar == 0)
			{
				tr[0]			= trueRange;
				dmPlus[0]		= 0;
				dmMinus[0]		= 0;
				sumTr[0]		= tr[0];
				sumDmPlus[0]	= dmPlus[0];
				sumDmMinus[0]	= dmMinus[0];
				ADXPlot[0]		= 50;
			}
			else
			{
				double low1			= Low[1];
				double high1		= High[1];
				double close1		= Close[1];

				tr[0]				= Math.Max(Math.Abs(low0 - close1), Math.Max(trueRange, Math.Abs(high0 - close1)));
				dmPlus[0]			= high0 - high1 > low1 - low0 ? Math.Max(high0 - high1, 0) : 0;
				dmMinus[0]			= low1 - low0 > high0 - high1 ? Math.Max(low1 - low0, 0) : 0;

				double sumDmPlus1	= sumDmPlus[1];
				double sumDmMinus1	= sumDmMinus[1];
				double sumTr1		= sumTr[1];

				if (CurrentBar < Period)
				{
					sumTr[0]		= sumTr1 + tr[0];
					sumDmPlus[0]	= sumDmPlus1 + dmPlus[0];
					sumDmMinus[0]	= sumDmMinus1 + dmMinus[0];
				}
				else
				{
					sumTr[0]		= sumTr1 - sumTr[1] / Period + tr[0];
					sumDmPlus[0]	= sumDmPlus1 - sumDmPlus1 / Period + dmPlus[0];
					sumDmMinus[0]	= sumDmMinus1 - sumDmMinus1 / Period + dmMinus[0];
				}

				double diPlus	= 100 * (sumTr[0] == 0 ? 0 : sumDmPlus[0] / sumTr[0]);
				double diMinus	= 100 * (sumTr[0] == 0 ? 0 : sumDmMinus[0] / sumTr[0]);
				double diff		= Math.Abs(diPlus - diMinus);
				double sum		= diPlus + diMinus;

				ADXPlot[0]		= sum == 0 ? 50 : ((Period - 1) * ADXPlot[1] + 100 * diff / sum) / Period;
				DiPlus[0]		= diPlus;
				DiMinus[0]		= diMinus;
			}
		}

		#region Properties
		[Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
		[XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
		public Series<double> ADXPlot
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> DiPlus
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> DiMinus
		{
			get { return Values[2]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private DM[] cacheDM;
		public DM DM(int period)
		{
			return DM(Input, period);
		}

		public DM DM(ISeries<double> input, int period)
		{
			if (cacheDM != null)
				for (int idx = 0; idx < cacheDM.Length; idx++)
					if (cacheDM[idx] != null && cacheDM[idx].Period == period && cacheDM[idx].EqualsInput(input))
						return cacheDM[idx];
			return CacheIndicator<DM>(new DM(){ Period = period }, input, ref cacheDM);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.DM DM(int period)
		{
			return indicator.DM(Input, period);
		}

		public Indicators.DM DM(ISeries<double> input , int period)
		{
			return indicator.DM(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.DM DM(int period)
		{
			return indicator.DM(Input, period);
		}

		public Indicators.DM DM(ISeries<double> input , int period)
		{
			return indicator.DM(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Directional Movement Index. 
	/// An indicator developed by J. Welles Wilder for identifying when a definable trend is present in an instrument. 
	/// That is, the DMI tells whether an instrument is trending or not.
	/// </summary>
	public class DMI : Indicator
	{
		private Series<double>		dmMinus;
		private Series<double>		dmPlus;
		private Series<double>		tr;
		private SMA					smaTr;
		private	SMA					smaDmPlus;
		private	SMA					smaDmMinus;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionDMI;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDMI;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.DarkCyan, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDMI);
			}
			else if (State == State.DataLoaded)
			{
				dmMinus		= new Series<double>(this);
				dmPlus		= new Series<double>(this);
				tr			= new Series<double>(this);
				smaTr		= SMA(tr, Period);
				smaDmMinus	= SMA(dmMinus, Period);
				smaDmPlus	= SMA(dmPlus, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			double high0	= High[0];
			double low0		= Low[0];

			if (CurrentBar == 0)
			{
				dmMinus[0]		= 0;
				dmPlus[0]		= 0;
				tr[0]			= high0 - low0;
				Value[0]		= 0;
			}
			else
			{
				double low1				= Low[1];
				double High1			= High[1];
				double close1			= Close[1];

				dmMinus[0]				= low1 - low0 > high0 - High1 ? Math.Max(low1 - low0, 0) : 0;
				dmPlus[0]				= high0 - High1 > low1 - low0 ? Math.Max(high0 - High1, 0) : 0;
				tr[0]					= Math.Max(high0 - low0, Math.Max(Math.Abs(high0 - close1), Math.Abs(low0 - close1)));

				double smaTr0			= smaTr[0];
				double smaDmMinus0		= smaDmMinus[0];
				double smaDmPlus0		= smaDmPlus[0];
				double diMinus			= (smaTr0 == 0) ? 0 : smaDmMinus0 / smaTr0;
				double diPlus			= (smaTr0 == 0) ? 0 : smaDmPlus0 / smaTr0;

				Value[0]				= (diPlus + diMinus == 0) ? 0 : (diPlus - diMinus) / (diPlus + diMinus);
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private DMI[] cacheDMI;
		public DMI DMI(int period)
		{
			return DMI(Input, period);
		}

		public DMI DMI(ISeries<double> input, int period)
		{
			if (cacheDMI != null)
				for (int idx = 0; idx < cacheDMI.Length; idx++)
					if (cacheDMI[idx] != null && cacheDMI[idx].Period == period && cacheDMI[idx].EqualsInput(input))
						return cacheDMI[idx];
			return CacheIndicator<DMI>(new DMI(){ Period = period }, input, ref cacheDMI);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.DMI DMI(int period)
		{
			return indicator.DMI(Input, period);
		}

		public Indicators.DMI DMI(ISeries<double> input , int period)
		{
			return indicator.DMI(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.DMI DMI(int period)
		{
			return indicator.DMI(Input, period);
		}

		public Indicators.DMI DMI(ISeries<double> input , int period)
		{
			return indicator.DMI(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Dynamic Momentum Index is a variable term RSI. The RSI term varies
	///  from 3 to 30. The variable time period makes the RSI more responsive to
	/// short-term moves. The more volatile the price is, the shorter the time period is.
	///  It is interpreted in the same way as the RSI, but provides signals earlier.
	/// </summary>
	public class DMIndex : Indicator
	{
		private SMA		sma;
		private StdDev	stdDev;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionDMIndex;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDMIndex;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= false;
				Smooth						= 3;

				AddPlot(Brushes.DarkCyan, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDMIndex);
			}
			else if (State == State.DataLoaded)
			{
				stdDev		= StdDev(5);
				sma			= SMA(stdDev, 10);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				Value[0] = Input[0];
				return;
			}
			int rsiPeriod	= (int)(14 / (stdDev[0] / sma[0])) < 1 ? 1 : (int) (14 / (stdDev[0] / sma[0]));
			Value[0]		= RSI(rsiPeriod, Smooth)[0];
		}

		#region Properties
		// This property will be removed in future version because it does not affect calculation of DM Index
		[Browsable(false)]
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private DMIndex[] cacheDMIndex;
		public DMIndex DMIndex(int smooth)
		{
			return DMIndex(Input, smooth);
		}

		public DMIndex DMIndex(ISeries<double> input, int smooth)
		{
			if (cacheDMIndex != null)
				for (int idx = 0; idx < cacheDMIndex.Length; idx++)
					if (cacheDMIndex[idx] != null && cacheDMIndex[idx].Smooth == smooth && cacheDMIndex[idx].EqualsInput(input))
						return cacheDMIndex[idx];
			return CacheIndicator<DMIndex>(new DMIndex(){ Smooth = smooth }, input, ref cacheDMIndex);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.DMIndex DMIndex(int smooth)
		{
			return indicator.DMIndex(Input, smooth);
		}

		public Indicators.DMIndex DMIndex(ISeries<double> input , int smooth)
		{
			return indicator.DMIndex(input, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.DMIndex DMIndex(int smooth)
		{
			return indicator.DMIndex(Input, smooth);
		}

		public Indicators.DMIndex DMIndex(ISeries<double> input , int smooth)
		{
			return indicator.DMIndex(input, smooth);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Donchian Channel. The Donchian Channel indicator was created by Richard Donchian.
	///  It uses the highest high and the lowest low of a period of time to plot the channel.
	/// </summary>
	public class DonchianChannel : Indicator
	{
		private MAX max;
		private MIN min;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionDonchianChannel;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDonchianChannel;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod,	NinjaTrader.Custom.Resource.DonchianChannelMean);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
			}
			else if (State == State.DataLoaded)
			{
				max = MAX(High, Period);
				min	= MIN(Low, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			double max0 = max[0];
			double min0	= min[0];

			Value[0]	= (max0 + min0) / 2;
			Upper[0]	= max0;
			Lower[0]	= min0;
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Lower
		{
			get { return Values[2]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Mean
		{
			get { return Values[0]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Upper
		{
			get { return Values[1]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private DonchianChannel[] cacheDonchianChannel;
		public DonchianChannel DonchianChannel(int period)
		{
			return DonchianChannel(Input, period);
		}

		public DonchianChannel DonchianChannel(ISeries<double> input, int period)
		{
			if (cacheDonchianChannel != null)
				for (int idx = 0; idx < cacheDonchianChannel.Length; idx++)
					if (cacheDonchianChannel[idx] != null && cacheDonchianChannel[idx].Period == period && cacheDonchianChannel[idx].EqualsInput(input))
						return cacheDonchianChannel[idx];
			return CacheIndicator<DonchianChannel>(new DonchianChannel(){ Period = period }, input, ref cacheDonchianChannel);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.DonchianChannel DonchianChannel(int period)
		{
			return indicator.DonchianChannel(Input, period);
		}

		public Indicators.DonchianChannel DonchianChannel(ISeries<double> input , int period)
		{
			return indicator.DonchianChannel(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.DonchianChannel DonchianChannel(int period)
		{
			return indicator.DonchianChannel(Input, period);
		}

		public Indicators.DonchianChannel DonchianChannel(ISeries<double> input , int period)
		{
			return indicator.DonchianChannel(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Double stochastics
	/// </summary>
	public class DoubleStochastics : Indicator
	{
		private EMA				emaP1;
		private EMA				emaP3;
		private	MIN				minLow;
		private MIN				minP2;
		private	MAX				maxHigh;
		private MAX				maxP2;
		private Series<double>	p1;
		private Series<double>	p2;
		private Series<double>	p3;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionDoubleStochastics;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameDoubleStochastics;
				IsSuspendedWhileInactive	= true;
				Period						= 10;

				AddPlot(Brushes.Crimson,													NinjaTrader.Custom.Resource.StochasticsK);
				AddLine(new Gui.Stroke(Brushes.DodgerBlue, Gui.DashStyleHelper.Dash, 1), 90,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
				AddLine(new Gui.Stroke(Brushes.DodgerBlue, Gui.DashStyleHelper.Dash, 1), 10,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
			}
			else if (State == State.DataLoaded)
			{
				p1		= new Series<double>(this);
				p2		= new Series<double>(this);
				p3		= new Series<double>(this);
				emaP1	= EMA(p1, 3);
				emaP3	= EMA(p3, 3);
				maxHigh	= MAX(High, Period);
				maxP2	= MAX(p2, Period);
				minLow	= MIN(Low, Period);
				minP2	= MIN(p2, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			double maxHigh0		= maxHigh[0];
			double minLow0		= minLow[0];
			double r			= maxHigh0 - minLow0;
			r					= r.ApproxCompare(0) == 0 ? 0 : r;

			if (r == 0)
				p1[0] = CurrentBar == 0 ? 50 : p1[1];
			else
				p1[0] = Math.Min(100, Math.Max(0, 100 * (Close[0] - minLow0) / r));

			p2[0]				= emaP1[0];
			double minP20		= minP2[0];
			double s			= maxP2[0] - minP20;
			s					= s.ApproxCompare(0) == 0 ? 0 : s;

			if (s == 0)
				p3[0] = CurrentBar == 0 ? 50 : p3[1];
			else
				p3[0] = Math.Min(100, Math.Max(0, 100 * (p2[0] - minP20) / s));

			K[0] = emaP3[0];
		}

		#region Properties
		[Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
		[XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
		public Series<double> K
		{
			get { return Values[0]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private DoubleStochastics[] cacheDoubleStochastics;
		public DoubleStochastics DoubleStochastics(int period)
		{
			return DoubleStochastics(Input, period);
		}

		public DoubleStochastics DoubleStochastics(ISeries<double> input, int period)
		{
			if (cacheDoubleStochastics != null)
				for (int idx = 0; idx < cacheDoubleStochastics.Length; idx++)
					if (cacheDoubleStochastics[idx] != null && cacheDoubleStochastics[idx].Period == period && cacheDoubleStochastics[idx].EqualsInput(input))
						return cacheDoubleStochastics[idx];
			return CacheIndicator<DoubleStochastics>(new DoubleStochastics(){ Period = period }, input, ref cacheDoubleStochastics);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.DoubleStochastics DoubleStochastics(int period)
		{
			return indicator.DoubleStochastics(Input, period);
		}

		public Indicators.DoubleStochastics DoubleStochastics(ISeries<double> input , int period)
		{
			return indicator.DoubleStochastics(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.DoubleStochastics DoubleStochastics(int period)
		{
			return indicator.DoubleStochastics(Input, period);
		}

		public Indicators.DoubleStochastics DoubleStochastics(ISeries<double> input , int period)
		{
			return indicator.DoubleStochastics(input, period);
		}
	}
}

#endregion


#########################

﻿// 
// Copyright (C) 2024, NinjaTrader LLC <ninjatrader@ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Windows.Media;
using NinjaTrader.Gui;
using System.Windows;
using System.Windows.Controls;
using System.Xml.Linq;
using System.Windows.Data;
using NinjaTrader.Cbi;
using NinjaTrader.Gui.Chart;
#endregion

namespace NinjaTrader.NinjaScript.Indicators
{
	[TypeConverter("NinjaTrader.NinjaScript.Indicators.DrawingToolIndicatorTypeConverter")]
	[CategoryOrder(typeof(Custom.Resource), "NinjaScriptParameters", 1)]
	[CategoryOrder(typeof(Resource), "PropertyCategoryDataSeries", 2)]
	[CategoryOrder(typeof(Resource), "NinjaScriptSetup", 3)]
	[CategoryOrder(typeof(Custom.Resource), "NinjaScriptDrawingTools", 4)]
	[CategoryOrder(typeof(Custom.Resource), "NinjaScriptIndicatorVisualGroup", 5)]
	[CategoryExpanded(typeof(Custom.Resource), "NinjaScriptDrawingTools", false)]
	public class DrawingToolTile : Indicator
	{
		private		Border		b;
		private		Grid		grid;
		private		Thickness	margin;
		private		bool		subscribedToSize;
		private		Point		startPoint;

		protected override void OnBarUpdate()
		{
			if (!subscribedToSize && ChartPanel != null)
			{
				subscribedToSize = true;

				ChartPanel.SizeChanged += (o, e) =>
				{
					if (grid == null || ChartPanel == null)
						return;
					if (grid.Margin.Left + grid.ActualWidth > ChartPanel.ActualWidth || grid.Margin.Top + grid.ActualHeight > ChartPanel.ActualHeight)
					{
						double left	= Math.Max(0, Math.Min(grid.Margin.Left, ChartPanel.ActualWidth - grid.ActualWidth));
						double top	= Math.Max(0, Math.Min(grid.Margin.Top, ChartPanel.ActualHeight - grid.ActualHeight));
						grid.Margin	= new Thickness(left, top, 0, 0);
						Left		= left;
						Top			= top;
					}
				};
			}
		}

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Name							= Custom.Resource.DrawingToolIndicatorName;
				Description						= Custom.Resource.DrawingToolIndicatorDescription;
				IsOverlay						= true;
				IsChartOnly						= true;
				DisplayInDataBox				= false;
				PaintPriceMarkers				= false;
				IsSuspendedWhileInactive		= true;
				SelectedTypes					= new XElement("SelectedTypes");

				foreach (Type type in new[]
				{
					typeof(DrawingTools.Ellipse), typeof(DrawingTools.ExtendedLine),
					typeof(DrawingTools.FibonacciExtensions), typeof(DrawingTools.FibonacciRetracements),
					typeof(DrawingTools.HorizontalLine), typeof(DrawingTools.Line),
					typeof(DrawingTools.Ray), typeof(DrawingTools.Rectangle), typeof(DrawingTools.Text), typeof(DrawingTools.VerticalLine)
				})
				{
					XElement	el				= new XElement(type.FullName);
					el.Add(new XAttribute("Assembly", "NinjaTrader.Custom"));
					SelectedTypes.Add(el);
				}
				Left			= 5;
				Top				= -1;
				NumberOfRows	= 5;
			}
			else if (State == State.Historical)
			{
				if (IsVisible)
				{
					if (ChartControl != null)
					{
						if (Top < 0)
							Top = 25;

						ChartControl.Dispatcher.InvokeAsync(() => { UserControlCollection.Add(CreateControl()); });
					}
				}
			}
		}

		private FrameworkElement CreateControl()
		{
			if (grid != null)
				return grid;

			grid = new Grid { VerticalAlignment = VerticalAlignment.Top, HorizontalAlignment = HorizontalAlignment.Left, Margin = new Thickness(Left, Top, 0, 0) };

			grid.ColumnDefinitions	.Add(new ColumnDefinition	{ Width		= new GridLength() });
			grid.ColumnDefinitions	.Add(new ColumnDefinition	{ Width		= new GridLength() });
			grid.RowDefinitions		.Add(new RowDefinition		{ Height	= new GridLength() });

			Brush	background	= Application.Current.FindResource("BackgroundMainWindow")	as Brush ?? Brushes.White;
			Brush	borderBrush	= Application.Current.FindResource("BorderThinBrush")		as Brush ?? Brushes.Black;

			Grid	g			= new Grid();
			g.RowDefinitions.Add(new RowDefinition { Height = new GridLength(2, GridUnitType.Star) });
			g.RowDefinitions.Add(new RowDefinition { Height = new GridLength(1, GridUnitType.Star) });
			g.RowDefinitions.Add(new RowDefinition { Height = new GridLength(2, GridUnitType.Star) });

			for (int r = 0; r < g.RowDefinitions.Count; r++)
			{
				System.Windows.Shapes.Ellipse e = new System.Windows.Shapes.Ellipse
				{
					Width				= 3,
					Height				= 3,
					HorizontalAlignment	= HorizontalAlignment.Center,
					VerticalAlignment	= VerticalAlignment.Center,
					Fill				= borderBrush
				};
				Grid.SetRow(e, r);
				g.Children.Add(e);
			}
			
			b = new Border
			{
				VerticalAlignment	= VerticalAlignment.Top,
				BorderThickness		= new Thickness(0, 1, 1, 1),
				BorderBrush			= borderBrush,
				Background			= background,
				Width				= 12,
				Height				= 24,
				Cursor				= System.Windows.Input.Cursors.Hand,
				Child				= g
			};

			b.MouseDown += (o, e) =>
			{
				startPoint	= e.GetPosition(ChartPanel);
				margin		= grid.Margin;
				if (e.ClickCount > 1)
				{
					b.ReleaseMouseCapture();
					ChartControl.OnIndicatorsHotKey(this, null);
				}
				else
					b.CaptureMouse();
			};

			b.MouseUp += (o, e) => { b.ReleaseMouseCapture(); };

			b.MouseMove += (o, e) =>
			{
				if (!b.IsMouseCaptured || grid == null || ChartPanel == null)
					return;

				Point newPoint	= e.GetPosition(ChartPanel);
				grid.Margin		= new Thickness	{
													Left	= Math.Max(0, Math.Min(margin.Left	+ (newPoint.X - startPoint.X), ChartPanel.ActualWidth	- grid.ActualWidth)),
													Top		= Math.Max(0, Math.Min(margin.Top	+ (newPoint.Y - startPoint.Y), ChartPanel.ActualHeight	- grid.ActualHeight))
												};

				Left			= grid.Margin.Left;
				Top				= grid.Margin.Top;
			};

			Grid.SetColumn(b, 1);

			grid.Children.Add(b);

			Grid			contentGrid		= new Grid();
			List<XElement>	elements		= SortElements(XElement.Parse(SelectedTypes.ToString()));
			int				column			= 0;
			int				count			= 0;
			FontFamily		fontFamily		= Application.Current.Resources["IconsFamily"] as FontFamily;
			Style			style			= Application.Current.Resources["LinkButtonStyle"] as Style;

			while (count < elements.Count)
			{
				if (contentGrid.ColumnDefinitions.Count <= column)
					contentGrid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(1, GridUnitType.Star)});
				for (int j = 0; j < NumberOfRows && count < elements.Count; j++)
				{
					if (contentGrid.RowDefinitions.Count <= j)
						contentGrid.RowDefinitions.Add(new RowDefinition {Height = new GridLength(1, GridUnitType.Auto)});
					XElement element = elements[count];
					try
					{
						DrawingTools.DrawingTool dt = Core.Globals.AssemblyRegistry[element.Attribute("Assembly").Value].CreateInstance(element.Name.ToString()) as DrawingTools.DrawingTool;
						if (dt != null && dt.DisplayOnChartsMenus)
						{
							Button bb = new Button
							{
								Content		= dt.Icon ?? Gui.Tools.Icons.DrawPencil,
								ToolTip		= dt.DisplayName,
								Style		= style,
								FontFamily	= fontFamily,
								FontSize	= 16,
								FontStyle	= FontStyles.Normal,
								Margin		= new Thickness(3),
								Padding		= new Thickness(3)
							};

							Grid.SetRow(bb, j);
							Grid.SetColumn(bb, column);

							bb.Click += (sender, args) =>
							{
								if (ChartControl != null)
									ChartControl.TryStartDrawing(dt.GetType().FullName);
							};

							contentGrid.Children.Add(bb);
							//tb.Items.Add(bb);
							count++;
						}
						else
						{
							elements.RemoveAt(j);
							j--;
						}
					}
					catch (Exception e)
					{
						elements.RemoveAt(j);
						j--;
						Cbi.Log.Process(typeof(Custom.Resource), "NinjaScriptTileError", new object[] { element.Name.ToString(), e }, LogLevel.Error, LogCategories.NinjaScript);
					}
				}
				column++;
			}

			Border tileHolder	= new Border
			{
				Cursor				= System.Windows.Input.Cursors.Arrow,
				Background			= Application.Current.FindResource("BackgroundMainWindow")as Brush,
				BorderThickness		= new Thickness ((double)(Application.Current.FindResource("BorderThinThickness") ?? 1)),
				BorderBrush			= Application.Current.FindResource("BorderThinBrush")as Brush,
				Child				= contentGrid
			};

			grid.Children.Add(tileHolder);

			if (IsVisibleOnlyFocused)
			{
				Binding binding = new Binding("IsActive") { Source = ChartControl.OwnerChart, Converter = Application.Current.FindResource("BoolToVisConverter") as IValueConverter};
				grid.SetBinding(UIElement.VisibilityProperty, binding);
			}

			return grid;
		}

		public override void CopyTo(NinjaScript ninjaScript)
		{
			DrawingToolTile dti = ninjaScript as DrawingToolTile;
			if (dti != null)
			{
				dti.Left	= Left;
				dti.Top		= Top;
			}
			base.CopyTo(ninjaScript);
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale) { }

		private List<XElement> SortElements(XElement elements)
		{
			string[] ordered =	{
									typeof(DrawingTools.Ruler)					.FullName,
									typeof(DrawingTools.RiskReward)				.FullName,
									typeof(DrawingTools.RegionHighlightX)		.FullName,
									typeof(DrawingTools.RegionHighlightY)		.FullName,
									typeof(DrawingTools.Line)					.FullName,
									typeof(DrawingTools.Ray)					.FullName,
									typeof(DrawingTools.ExtendedLine)			.FullName,
									typeof(DrawingTools.ArrowLine)				.FullName,
									typeof(DrawingTools.HorizontalLine)			.FullName,
									typeof(DrawingTools.VerticalLine)			.FullName,
									typeof(DrawingTools.PathTool)				.FullName,
									typeof(DrawingTools.FibonacciRetracements)	.FullName,
									typeof(DrawingTools.FibonacciExtensions)	.FullName,
									typeof(DrawingTools.FibonacciTimeExtensions).FullName,
									typeof(DrawingTools.FibonacciCircle)		.FullName,
									typeof(DrawingTools.AndrewsPitchfork)		.FullName,
									typeof(DrawingTools.GannFan)				.FullName,
									typeof(DrawingTools.RegressionChannel)		.FullName,
									typeof(DrawingTools.TrendChannel)			.FullName,
									typeof(DrawingTools.TimeCycles)				.FullName,
									typeof(DrawingTools.Ellipse)				.FullName,
									typeof(DrawingTools.Rectangle)				.FullName,
									typeof(DrawingTools.Triangle)				.FullName,
									typeof(DrawingTools.Polygon)				.FullName,
									"NinjaTrader.NinjaScript.DrawingTools.OrderFlowVolumeProfile",
									"NinjaTrader.NinjaScript.DrawingTools.OrderFlowVWAPDrawingTool",
									typeof(DrawingTools.Arc)					.FullName,
									typeof(DrawingTools.Text)					.FullName,
									typeof(DrawingTools.ArrowUp)				.FullName,
									typeof(DrawingTools.ArrowDown)				.FullName,
									typeof(DrawingTools.Diamond)				.FullName,
									typeof(DrawingTools.Dot)					.FullName,
									typeof(DrawingTools.Square)					.FullName,
									typeof(DrawingTools.TriangleUp)				.FullName,
									typeof(DrawingTools.TriangleDown)			.FullName
								};

			List<XElement> ret = new List<XElement>();
			foreach (string s in ordered)
			{
				XElement c = elements.Element(s);
				if (c != null)
				{
					ret.Add(XElement.Parse(c.ToString()));
					c.Remove();
				}
			}

			foreach (XElement element in elements.Elements())
				ret.Add(element);

			return ret;
		}

		#region Properties

		[Browsable(false)]
		public double Top { get; set; }
		[Browsable(false)]
		public double Left { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "NinjaScriptIsVisibleOnlyFocused", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 499)]
		public bool IsVisibleOnlyFocused { get; set; }

		public XElement SelectedTypes { get; set; }
		[Range(1, int.MaxValue)]
		[Display(ResourceType = typeof(Custom.Resource), Name = "NinjaScriptNumberOfRows", GroupName = "NinjaScriptParameters", Order = 0)]
		public int NumberOfRows { get; set; }
		#endregion
	}

	public class DrawingToolPropertyDescriptor : PropertyDescriptor
	{
		private readonly string		displayName;
		private readonly string		name;
		private readonly int		order;
		private readonly Type		type;

		public override AttributeCollection Attributes
		{
			get
			{
				Attribute[] attr	= new Attribute[1];
				attr[0]				= new DisplayAttribute { Name = DisplayName, GroupName = Custom.Resource.NinjaScriptDrawingTools, Order = order };

				return new AttributeCollection(attr);
			}
		}

		public DrawingToolPropertyDescriptor(Type type, string displayName, int order) : base(type.FullName, null)
		{
			name					= type.FullName;
			this.displayName		= displayName;
			this.order				= order;
			this.type				= type;
		}

		public	override	Type	ComponentType							{ get { return typeof (DrawingToolTile); } }
		public	override	string	DisplayName								{ get { return displayName; } }
		public	override	bool	IsReadOnly								{ get { return false; } }
		public	override	string	Name									{ get { return name; } }
		public	override	Type	PropertyType							{ get { return typeof (bool); } }

		public	override	bool	CanResetValue(object component)			{ return true; }
		public	override	bool	ShouldSerializeValue(object component)	{ return true; }

		public	override	object	GetValue(object component)
		{
			DrawingToolTile c = component as DrawingToolTile;

			return c != null && c.SelectedTypes.Element(Name) != null;
		}

		public override void ResetValue(object component) { }

		public override void SetValue(object component, object value)
		{
			DrawingToolTile c = component as DrawingToolTile;
			if (c == null)
				return;
			bool val = (bool) value;

			if (val && c.SelectedTypes.Element(Name) == null)
			{
				XElement toAdd = new XElement(Name);
				toAdd.Add(new XAttribute("Assembly", Core.Globals.AssemblyRegistry.IsNinjaTraderCustomAssembly(type) ? "NinjaTrader.Custom" : type.Assembly.GetName().Name));
				c.SelectedTypes.Add(toAdd);
			}
			else if(!val && c.SelectedTypes.Element(Name) != null)
				c.SelectedTypes.Element(Name).Remove();
		}
	}

	public class DrawingToolIndicatorTypeConverter : TypeConverter
	{
		public override bool GetPropertiesSupported(ITypeDescriptorContext context) { return true; }

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[] attrs)
		{
			TypeConverter					tc								= component is IndicatorBase ? TypeDescriptor.GetConverter(typeof(IndicatorBase)) : TypeDescriptor.GetConverter(typeof(DrawingTools.DrawingTool));
			PropertyDescriptorCollection	propertyDescriptorCollection	= tc.GetProperties(context, component, attrs);

			if (propertyDescriptorCollection == null) 
				return null;

			PropertyDescriptorCollection properties	= new PropertyDescriptorCollection(null);

			foreach (PropertyDescriptor pd in propertyDescriptorCollection)
			{
				if (!pd.IsBrowsable || pd.IsReadOnly) continue;

				if (pd.Name == "IsAutoScale"	|| pd.Name == "DisplayInDataBox"	|| pd.Name == "MaximumBarsLookBack"	|| pd.Name == "Calculate"
												|| pd.Name == "PaintPriceMarkers"	|| pd.Name == "Displacement"		|| pd.Name == "ScaleJustification")
					continue;

				if (pd.Name == "SelectedTypes")
				{
					int i = 1;
					foreach (Type type in Core.Globals.AssemblyRegistry.GetDerivedTypes(typeof(DrawingTools.DrawingTool)))
					{
						DrawingTools.DrawingTool tool = type.Assembly.CreateInstance(type.FullName) as DrawingTools.DrawingTool;
						if (tool == null || !tool.DisplayOnChartsMenus) continue;
						DrawingToolPropertyDescriptor descriptor = new DrawingToolPropertyDescriptor(type, tool.Name, i);
						properties.Add(descriptor);
						i++;
					}
					continue;
				}

				properties.Add(pd);
			}
			return properties;
		}
	}
}

#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Ease of Movement (EMV) indicator emphasizes days in which the stock is moving
	///  easily and minimizes the days in which the stock is finding it difficult to move.
	/// A buy signal is generated when the EMV crosses above zero, a sell signal when it
	///  crosses below zero. When the EMV hovers around zero, then there are small price
	/// movements and/or high volume, which is to say, the price is not moving easily.
	/// </summary>
	public class EaseOfMovement : Indicator
	{
		private EMA				ema;
		private Series<double>	emv;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionEaseOfMovement;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameEaseOfMovement;
				IsSuspendedWhileInactive	= true;
				DrawOnPricePanel			= false;
				Smoothing					= 14;
				VolumeDivisor				= 10000;

				AddPlot(Brushes.DodgerBlue,			NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameEaseOfMovement);
				AddLine(Brushes.DarkGray,	0,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.DataLoaded)
			{
				emv = new Series<double>(this);
				ema = EMA(emv, Smoothing);
			}
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
				}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
				return;
			double volume0	= Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0];
			double midPoint	= Median[0] - Median[1];
			double boxRatio = (volume0 / VolumeDivisor) / (High[0] - Low[0]);

			emv[0] 			= boxRatio.ApproxCompare(0) == 0 ? 0 : midPoint / boxRatio;
			Value[0]		= ema[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smoothing", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Smoothing
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "VolumeDivisor", GroupName = "NinjaScriptParameters", Order = 1)]
		public int VolumeDivisor
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private EaseOfMovement[] cacheEaseOfMovement;
		public EaseOfMovement EaseOfMovement(int smoothing, int volumeDivisor)
		{
			return EaseOfMovement(Input, smoothing, volumeDivisor);
		}

		public EaseOfMovement EaseOfMovement(ISeries<double> input, int smoothing, int volumeDivisor)
		{
			if (cacheEaseOfMovement != null)
				for (int idx = 0; idx < cacheEaseOfMovement.Length; idx++)
					if (cacheEaseOfMovement[idx] != null && cacheEaseOfMovement[idx].Smoothing == smoothing && cacheEaseOfMovement[idx].VolumeDivisor == volumeDivisor && cacheEaseOfMovement[idx].EqualsInput(input))
						return cacheEaseOfMovement[idx];
			return CacheIndicator<EaseOfMovement>(new EaseOfMovement(){ Smoothing = smoothing, VolumeDivisor = volumeDivisor }, input, ref cacheEaseOfMovement);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.EaseOfMovement EaseOfMovement(int smoothing, int volumeDivisor)
		{
			return indicator.EaseOfMovement(Input, smoothing, volumeDivisor);
		}

		public Indicators.EaseOfMovement EaseOfMovement(ISeries<double> input , int smoothing, int volumeDivisor)
		{
			return indicator.EaseOfMovement(input, smoothing, volumeDivisor);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.EaseOfMovement EaseOfMovement(int smoothing, int volumeDivisor)
		{
			return indicator.EaseOfMovement(Input, smoothing, volumeDivisor);
		}

		public Indicators.EaseOfMovement EaseOfMovement(ISeries<double> input , int smoothing, int volumeDivisor)
		{
			return indicator.EaseOfMovement(input, smoothing, volumeDivisor);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Exponential Moving Average. The Exponential Moving Average is an indicator that
	/// shows the average value of a security's price over a period of time. When calculating
	/// a moving average. The EMA applies more weight to recent prices than the SMA.
	/// </summary>
	public class EMA : Indicator
	{
		private double constant1;
		private double constant2;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionEMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameEMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameEMA);
			}
			else if (State == State.Configure)
			{
				constant1 = 2.0 / (1 + Period);
				constant2 = 1 - (2.0 / (1 + Period));
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = (CurrentBar == 0 ? Input[0] : Input[0] * constant1 + constant2 * Value[1]);
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private EMA[] cacheEMA;
		public EMA EMA(int period)
		{
			return EMA(Input, period);
		}

		public EMA EMA(ISeries<double> input, int period)
		{
			if (cacheEMA != null)
				for (int idx = 0; idx < cacheEMA.Length; idx++)
					if (cacheEMA[idx] != null && cacheEMA[idx].Period == period && cacheEMA[idx].EqualsInput(input))
						return cacheEMA[idx];
			return CacheIndicator<EMA>(new EMA(){ Period = period }, input, ref cacheEMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.EMA EMA(int period)
		{
			return indicator.EMA(Input, period);
		}

		public Indicators.EMA EMA(ISeries<double> input , int period)
		{
			return indicator.EMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.EMA EMA(int period)
		{
			return indicator.EMA(Input, period);
		}

		public Indicators.EMA EMA(ISeries<double> input , int period)
		{
			return indicator.EMA(input, period);
		}
	}
}

#endregion


#########################

﻿//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Core;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX.DirectWrite;

#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	[TypeConverter("NinjaTrader.NinjaScript.Indicators.FibonacciPivotsTypeConverter")]
	public class FibonacciPivots : Indicator
	{
		private DateTime				cacheMonthlyEndDate		= Globals.MinDate;
		private DateTime				cacheSessionDate		= Globals.MinDate;
		private DateTime				cacheSessionEnd			= Globals.MinDate;
		private DateTime				cacheTime;
		private DateTime				cacheWeeklyEndDate		= Globals.MinDate;
		private DateTime				currentDate				= Globals.MinDate;
		private DateTime				currentMonth			= Globals.MinDate;
		private DateTime				currentWeek				= Globals.MinDate;
		private DateTime				sessionDateTmp			= Globals.MinDate;
		private HLCCalculationMode		priorDayHlc;
		private PivotRange				pivotRangeType;
		private SessionIterator			storedSession;
		private double					currentClose;
		private double					currentHigh				= double.MinValue;
		private double					currentLow				= double.MaxValue;
		private double					dailyBarClose			= double.MinValue;
		private double					dailyBarHigh			= double.MinValue;
		private double					dailyBarLow				= double.MinValue;
		private double					pp;
		private double					r1;
		private double					r2;
		private double					r3;
		private double					s1;
		private double					s2;
		private double					s3;
		private double					userDefinedClose;
		private double					userDefinedHigh;
		private double					userDefinedLow;
		private int						cacheBar;
		private int						width					= 20;
		private readonly List<int>		newSessionBarIdxArr		= new List<int>();

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description				= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionFibonacciPivots;
				Name					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameFibonacciPivots;
				Calculate				= Calculate.OnBarClose;
				DisplayInDataBox		= true;
				DrawOnPricePanel		= false;
				IsAutoScale				= false;
				IsOverlay				= true;
				PaintPriceMarkers		= true;
				ScaleJustification		= ScaleJustification.Right;

				AddPlot(Brushes.Goldenrod,	NinjaTrader.Custom.Resource.PivotsPP);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.PivotsR1);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.PivotsR2);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.PivotsR3);
				AddPlot(Brushes.Crimson,	NinjaTrader.Custom.Resource.PivotsS1);
				AddPlot(Brushes.Crimson,	NinjaTrader.Custom.Resource.PivotsS2);
				AddPlot(Brushes.Crimson,	NinjaTrader.Custom.Resource.PivotsS3);
			}
			else if (State == State.Configure)
			{
				if (priorDayHlc == HLCCalculationMode.DailyBars)
					AddDataSeries(BarsPeriodType.Day, 1);
			}
			else if (State == State.DataLoaded)
			{
				storedSession = new SessionIterator(Bars);
			}
			else if (State == State.Historical)
			{
				if (priorDayHlc == HLCCalculationMode.DailyBars && BarsArray[1].DayCount <= 0)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsDailyDataError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsDailyDataError, LogLevel.Error);
					return;
				}

				if (!Bars.BarsType.IsIntraday && BarsPeriod.BarsPeriodType != BarsPeriodType.Day && (BarsPeriod.BarsPeriodType != BarsPeriodType.HeikenAshi && BarsPeriod.BarsPeriodType != BarsPeriodType.Volumetric || BarsPeriod.BaseBarsPeriodType != BarsPeriodType.Day))
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsDailyBarsError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsDailyBarsError, LogLevel.Error);
				}
				if ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && pivotRangeType == PivotRange.Daily)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsWeeklyBarsError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsWeeklyBarsError, LogLevel.Error);
				}
				if ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && BarsPeriod.Value > 1)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsPeriodTypeError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsPeriodTypeError, LogLevel.Error);
				}
				if ((priorDayHlc == HLCCalculationMode.DailyBars &&
					(pivotRangeType == PivotRange.Monthly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddMonths(-1)
					|| pivotRangeType == PivotRange.Weekly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-7)
					|| pivotRangeType == PivotRange.Daily && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-1)))
					|| pivotRangeType == PivotRange.Monthly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddMonths(-1)
					|| pivotRangeType == PivotRange.Weekly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-7)
					|| pivotRangeType == PivotRange.Daily && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-1)
					)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsInsufficentDataError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsInsufficentDataError, LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsInProgress != 0)
				return;

			if ((priorDayHlc == HLCCalculationMode.DailyBars && BarsArray[1].DayCount <= 0)
				|| (!Bars.BarsType.IsIntraday && BarsPeriod.BarsPeriodType != BarsPeriodType.Day && (BarsPeriod.BarsPeriodType != BarsPeriodType.HeikenAshi && BarsPeriod.BarsPeriodType != BarsPeriodType.Volumetric || BarsPeriod.BaseBarsPeriodType != BarsPeriodType.Day))
				|| ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && pivotRangeType == PivotRange.Daily)
				|| ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && BarsPeriod.Value > 1)
				|| ((priorDayHlc == HLCCalculationMode.DailyBars && (pivotRangeType == PivotRange.Monthly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddMonths(-1)
				|| pivotRangeType == PivotRange.Weekly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-7)
				|| pivotRangeType == PivotRange.Daily && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-1)))
				|| pivotRangeType == PivotRange.Monthly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddMonths(-1)
				|| pivotRangeType == PivotRange.Weekly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-7)
				|| pivotRangeType == PivotRange.Daily && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-1)))
				return;

			RemoveDrawObject("NinjaScriptInfo");

			if (PriorDayHlc == HLCCalculationMode.DailyBars && CurrentBars[1] >= 0)
			{
				// Get daily bars like this to avoid situation where primary series moves to next session before previous day OHLC are added
				if (cacheTime != Times[0][0])
				{
					cacheTime	= Times[0][0];
					cacheBar	= BarsArray[1].GetBar(Times[0][0]);
				}
				dailyBarHigh	= BarsArray[1].GetHigh(cacheBar);
				dailyBarLow		= BarsArray[1].GetLow(cacheBar);
				dailyBarClose	= BarsArray[1].GetClose(cacheBar);
			}
			else
			{
				dailyBarHigh	= double.MinValue;
				dailyBarLow		= double.MinValue;
				dailyBarClose	= double.MinValue;
			}

			double high		= (dailyBarHigh == double.MinValue)		? Highs[0][0]	: dailyBarHigh;
			double low		= (dailyBarLow == double.MinValue)		? Lows[0][0]	: dailyBarLow;
			double close	= (dailyBarClose == double.MinValue)	? Closes[0][0]	: dailyBarClose;

			DateTime lastBarTimeStamp = GetLastBarSessionDate(Times[0][0], pivotRangeType);

			if ((currentDate != Globals.MinDate && pivotRangeType == PivotRange.Daily && lastBarTimeStamp != currentDate)
				|| (currentWeek != Globals.MinDate && pivotRangeType == PivotRange.Weekly && lastBarTimeStamp != currentWeek)
				|| (currentMonth != Globals.MinDate && pivotRangeType == PivotRange.Monthly && lastBarTimeStamp != currentMonth))
			{
				pp				= (currentHigh + currentLow + currentClose) / 3;
				s1				= pp - (currentHigh - currentLow) * 0.382;
				r1				= pp + (currentHigh - currentLow) * 0.382;
				s2				= pp - (currentHigh - currentLow) * 0.618;
				r2				= pp + (currentHigh - currentLow) * 0.618;
				s3				= pp - (currentHigh - currentLow) * 1.000;
				r3				= pp + (currentHigh - currentLow) * 1.000;
				currentClose	= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedClose	: close;
				currentHigh		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedHigh	: high;
				currentLow		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedLow	: low;
			}
			else
			{
				currentClose	= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedClose	: close;
				currentHigh		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedHigh	: Math.Max(currentHigh, high);
				currentLow		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedLow	: Math.Min(currentLow, low);
			}


			if (pivotRangeType == PivotRange.Daily)
				currentDate = lastBarTimeStamp;
			if (pivotRangeType == PivotRange.Weekly)
				currentWeek = lastBarTimeStamp;
			if (pivotRangeType == PivotRange.Monthly)
				currentMonth = lastBarTimeStamp;

			if ((pivotRangeType == PivotRange.Daily && currentDate != Globals.MinDate)
				|| (pivotRangeType == PivotRange.Weekly && currentWeek != Globals.MinDate)
				|| (pivotRangeType == PivotRange.Monthly && currentMonth != Globals.MinDate))
			{
				Pp[0] = pp;
				R1[0] = r1;
				R2[0] = r2;
				R3[0] = r3;
				S1[0] = s1;
				S2[0] = s2;
				S3[0] = s3;
			}
		}

		#region Misc
		private DateTime GetLastBarSessionDate(DateTime time, PivotRange pivotRange)
		{
			// Check the time[0] against the previous session end
			if (time > cacheSessionEnd)
			{
				if (Bars.BarsType.IsIntraday)
				{
					// Make use of the stored session iterator to find the next session...
					storedSession.GetNextSession(time, true);
					// Store the actual session's end datetime as the session
					cacheSessionEnd = storedSession.ActualSessionEnd;
					// We need to convert that time from the session to the users time zone settings
					sessionDateTmp = TimeZoneInfo.ConvertTime(cacheSessionEnd.AddSeconds(-1), Globals.GeneralOptions.TimeZoneInfo, Bars.TradingHours.TimeZoneInfo).Date;
				}
				else
					sessionDateTmp = time.Date;
			}

			if (pivotRange == PivotRange.Daily)
			{
				if (sessionDateTmp != cacheSessionDate)
				{
					if (newSessionBarIdxArr.Count == 0 || newSessionBarIdxArr.Count > 0 && CurrentBar > newSessionBarIdxArr[newSessionBarIdxArr.Count - 1])
						newSessionBarIdxArr.Add(CurrentBar);
					cacheSessionDate = sessionDateTmp;
				}
				return sessionDateTmp;
			}

			DateTime tmpWeeklyEndDate = RoundUpTimeToPeriodTime(sessionDateTmp, PivotRange.Weekly);
			if (pivotRange == PivotRange.Weekly)
			{
				if (tmpWeeklyEndDate != cacheWeeklyEndDate)
				{
					if (newSessionBarIdxArr.Count == 0 || newSessionBarIdxArr.Count > 0 && CurrentBar > newSessionBarIdxArr[newSessionBarIdxArr.Count - 1])
						newSessionBarIdxArr.Add(CurrentBar);
					cacheWeeklyEndDate = tmpWeeklyEndDate;
				}
				return tmpWeeklyEndDate;
			}

			DateTime tmpMonthlyEndDate = RoundUpTimeToPeriodTime(sessionDateTmp, PivotRange.Monthly);
			if (tmpMonthlyEndDate != cacheMonthlyEndDate)
			{
				if (newSessionBarIdxArr.Count == 0 || newSessionBarIdxArr.Count > 0 && CurrentBar > newSessionBarIdxArr[newSessionBarIdxArr.Count - 1])
					newSessionBarIdxArr.Add(CurrentBar);
				cacheMonthlyEndDate = tmpMonthlyEndDate;
			}
			return tmpMonthlyEndDate;
		}

		private DateTime RoundUpTimeToPeriodTime(DateTime time, PivotRange pivotRange)
		{
			if (pivotRange == PivotRange.Weekly)
				return Gui.Tools.Extensions.GetEndOfWeekTime(time);
			if (pivotRange == PivotRange.Monthly)
				return Gui.Tools.Extensions.GetEndOfMonthTime(time);
			return time;
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
		{
			// Set text to chart label color and font
			TextFormat	textFormat			= chartControl.Properties.LabelFont.ToDirectWriteTextFormat();

			// Loop through each Plot Values on the chart
			for (int seriesCount = 0; seriesCount < Values.Length; seriesCount++)
			{
				double	y					= -1;
				double	startX				= -1;
				double	endX				= -1;
				int		firstBarIdxToPaint	= -1;
				int		firstBarPainted		= ChartBars.FromIndex;
				int		lastBarPainted		= ChartBars.ToIndex;
				Plot	plot				= Plots[seriesCount];

				for (int i = newSessionBarIdxArr.Count - 1; i >= 0; i--)
				{
					int prevSessionBreakIdx = newSessionBarIdxArr[i];
					if (prevSessionBreakIdx <= lastBarPainted)
					{
						firstBarIdxToPaint = prevSessionBreakIdx;
						break;
					}
				}

				// Loop through visble bars to render plot values
				for (int idx = lastBarPainted; idx >= Math.Max(firstBarPainted, lastBarPainted - width); idx--)
				{
					if (idx < firstBarIdxToPaint)
						break;

					startX		= chartControl.GetXByBarIndex(ChartBars, idx);
					endX		= chartControl.GetXByBarIndex(ChartBars, lastBarPainted);
					double val	= Values[seriesCount].GetValueAt(idx);
					y			= chartScale.GetYByValue(val);
				}

				// Draw pivot lines
				Point startPoint	= new Point(startX, y);
				Point endPoint		= new Point(endX, y);
				RenderTarget.DrawLine(startPoint.ToVector2(), endPoint.ToVector2(), plot.BrushDX, plot.Width, plot.StrokeStyle);

				// Draw pivot text
				TextLayout textLayout = new TextLayout(Globals.DirectWriteFactory, plot.Name, textFormat, ChartPanel.W, textFormat.FontSize);
				RenderTarget.DrawTextLayout(startPoint.ToVector2(), textLayout, plot.BrushDX);
				textLayout.Dispose();
			}
			textFormat.Dispose();
		}
		#endregion

		#region Properties

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "PivotRange", GroupName = "NinjaScriptParameters", Order = 0)]
		public PivotRange PivotRangeType
		{
			get { return pivotRangeType; }
			set { pivotRangeType = value; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Pp
		{
			get { return Values[0]; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "HLCCalculationMode", GroupName = "NinjaScriptParameters", Order = 1)]
		[RefreshProperties(RefreshProperties.All)] // Update UI when value is changed
		public HLCCalculationMode PriorDayHlc
		{
			get { return priorDayHlc; }
			set { priorDayHlc = value; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> R1
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> R2
		{
			get { return Values[2]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> R3
		{
			get { return Values[3]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> S1
		{
			get { return Values[4]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> S2
		{
			get { return Values[5]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> S3
		{
			get { return Values[6]; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UserDefinedClose", GroupName = "NinjaScriptParameters", Order = 2)]
		public double UserDefinedClose
		{
			get { return userDefinedClose; }
			set { userDefinedClose = value; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UserDefinedHigh", GroupName = "NinjaScriptParameters", Order = 3)]
		public double UserDefinedHigh
		{
			get { return userDefinedHigh; }
			set { userDefinedHigh = value; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UserDefinedLow", GroupName = "NinjaScriptParameters", Order = 4)]
		public double UserDefinedLow
		{
			get { return userDefinedLow; }
			set { userDefinedLow = value; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Width", GroupName = "NinjaScriptParameters", Order = 5)]
		public int Width
		{
			get { return width; }
			set { width = value; }
		}

		#endregion
	}
	
	// Hide UserDefinedValues properties when not in use by the HLCCalculationMode.UserDefinedValues
	// When creating a custom type converter for indicators it must inherit from NinjaTrader.NinjaScript.IndicatorBaseConverter to work correctly with indicators
	public class FibonacciPivotsTypeConverter : NinjaTrader.NinjaScript.IndicatorBaseConverter
	{
		public override bool GetPropertiesSupported(ITypeDescriptorContext context) { return true; }

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection propertyDescriptorCollection = base.GetPropertiesSupported(context) ? base.GetProperties(context, value, attributes) : TypeDescriptor.GetProperties(value, attributes);

			FibonacciPivots		thisPivotsInstance			= (FibonacciPivots) value;
			HLCCalculationMode	selectedHLCCalculationMode	= thisPivotsInstance.PriorDayHlc;
			if (selectedHLCCalculationMode == HLCCalculationMode.UserDefinedValues)
				return propertyDescriptorCollection;

			PropertyDescriptorCollection adjusted = new PropertyDescriptorCollection(null);
			foreach (PropertyDescriptor thisDescriptor in propertyDescriptorCollection)
			{
				if (thisDescriptor.Name == "UserDefinedClose" || thisDescriptor.Name == "UserDefinedHigh" || thisDescriptor.Name == "UserDefinedLow")
					adjusted.Add(new PropertyDescriptorExtended(thisDescriptor, o => value, null, new Attribute[] {new BrowsableAttribute(false), }));
				else
					adjusted.Add(thisDescriptor);
			}
			return adjusted;
		}
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private FibonacciPivots[] cacheFibonacciPivots;
		public FibonacciPivots FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return FibonacciPivots(Input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}

		public FibonacciPivots FibonacciPivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			if (cacheFibonacciPivots != null)
				for (int idx = 0; idx < cacheFibonacciPivots.Length; idx++)
					if (cacheFibonacciPivots[idx] != null && cacheFibonacciPivots[idx].PivotRangeType == pivotRangeType && cacheFibonacciPivots[idx].PriorDayHlc == priorDayHlc && cacheFibonacciPivots[idx].UserDefinedClose == userDefinedClose && cacheFibonacciPivots[idx].UserDefinedHigh == userDefinedHigh && cacheFibonacciPivots[idx].UserDefinedLow == userDefinedLow && cacheFibonacciPivots[idx].Width == width && cacheFibonacciPivots[idx].EqualsInput(input))
						return cacheFibonacciPivots[idx];
			return CacheIndicator<FibonacciPivots>(new FibonacciPivots(){ PivotRangeType = pivotRangeType, PriorDayHlc = priorDayHlc, UserDefinedClose = userDefinedClose, UserDefinedHigh = userDefinedHigh, UserDefinedLow = userDefinedLow, Width = width }, input, ref cacheFibonacciPivots);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.FibonacciPivots FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.FibonacciPivots(Input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}

		public Indicators.FibonacciPivots FibonacciPivots(ISeries<double> input , PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.FibonacciPivots(input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.FibonacciPivots FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.FibonacciPivots(Input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}

		public Indicators.FibonacciPivots FibonacciPivots(ISeries<double> input , PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.FibonacciPivots(input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Fisher Transform. The Fisher Transform has sharp and distinct turning points
	/// that occur in a timely fashion. The resulting peak swings are used to identify price reversals.
	/// </summary>
	public class FisherTransform : Indicator
	{
		private	MAX				max;
		private	MIN				min;
		private Series<double>	tmpSeries;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionFisherTransform;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameFisherTransform;
				IsSuspendedWhileInactive	= true;
				Period						= 10;

				AddPlot(new Stroke(Brushes.DodgerBlue, 2), PlotStyle.Bar, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameFisherTransform);
			}
			else if (State == State.DataLoaded)
			{
				max			= MAX(Input, Period);
				min			= MIN(Input, Period);
				tmpSeries	= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			double fishPrev		= 0;
			double tmpValuePrev	= 0;

			if (CurrentBar > 0)
			{
				fishPrev		= Value[1];
				tmpValuePrev	= tmpSeries[1];
			}

			double minLo	= min[0];
			double num1		= max[0] - minLo;

			// Guard against infinite numbers and div by zero
			num1			= (num1 < TickSize / 10 ? TickSize / 10 : num1);
			double tmpValue = 0.66 * ((Input[0] - minLo) / num1 - 0.5) + 0.67 * tmpValuePrev;

			if (tmpValue > 0.99)
				tmpValue = 0.999;
			else if (tmpValue < -0.99)
				tmpValue = -0.999;

			tmpSeries[0]	= tmpValue;
			Value[0]		= 0.5 * Math.Log((1 + tmpValue) / (1 - tmpValue)) + 0.5 * fishPrev;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private FisherTransform[] cacheFisherTransform;
		public FisherTransform FisherTransform(int period)
		{
			return FisherTransform(Input, period);
		}

		public FisherTransform FisherTransform(ISeries<double> input, int period)
		{
			if (cacheFisherTransform != null)
				for (int idx = 0; idx < cacheFisherTransform.Length; idx++)
					if (cacheFisherTransform[idx] != null && cacheFisherTransform[idx].Period == period && cacheFisherTransform[idx].EqualsInput(input))
						return cacheFisherTransform[idx];
			return CacheIndicator<FisherTransform>(new FisherTransform(){ Period = period }, input, ref cacheFisherTransform);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.FisherTransform FisherTransform(int period)
		{
			return indicator.FisherTransform(Input, period);
		}

		public Indicators.FisherTransform FisherTransform(ISeries<double> input , int period)
		{
			return indicator.FisherTransform(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.FisherTransform FisherTransform(int period)
		{
			return indicator.FisherTransform(Input, period);
		}

		public Indicators.FisherTransform FisherTransform(ISeries<double> input , int period)
		{
			return indicator.FisherTransform(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Forecast Oscillator (FOSC) is an extension of the linear regression based indicators
	/// made popular by Tushar Chande. The Forecast Oscillator plots the percentage difference
	/// between the forecast price (generated by an x-period linear regression line) and the actual
	/// price. The oscillator is above zero when the forecast price is greater than the actual price.
	/// Conversely, it's less than zero if its below. In the rare case when the forecast price and the
	///  actual price are the same, the oscillator would plot zero. Actual prices that are persistently
	///  below the forecast price suggest lower prices ahead.  Likewise, actual prices that are persistently
	///  above the forecast price suggest higher prices ahead. Short-term traders should use shorter time
	///  periods and perhaps more relaxed standards for the required length of time above or below the
	///  forecast price. Long-term traders should use longer time periods and perhaps stricter standards
	///  for the required length of time above or below the forecast price. Chande also suggests plotting
	///  a three-day moving average trigger line of the Forecast Oscillator to generate early warnings of
	/// changes in trend. When the oscillator crosses below the trigger line, lower prices are suggested.
	/// When the oscillator crosses above the trigger line, higher prices are suggested.
	/// </summary>
	public class FOSC : Indicator
	{
		private TSF	tsf;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionFOSC;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameFOSC;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= false;
				Period						= 14;

				AddPlot(Brushes.DarkCyan,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameFOSC);
				AddLine(Brushes.DarkGray,	0,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.DataLoaded)
				tsf = TSF(Inputs[0], 0, Period);
		}

		protected override void OnBarUpdate()
		{
			if (Input[0] <= 0)
				return;
			
			Value[0] = 100 * ((Input[0] - tsf[0]) / Input[0]);
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private FOSC[] cacheFOSC;
		public FOSC FOSC(int period)
		{
			return FOSC(Input, period);
		}

		public FOSC FOSC(ISeries<double> input, int period)
		{
			if (cacheFOSC != null)
				for (int idx = 0; idx < cacheFOSC.Length; idx++)
					if (cacheFOSC[idx] != null && cacheFOSC[idx].Period == period && cacheFOSC[idx].EqualsInput(input))
						return cacheFOSC[idx];
			return CacheIndicator<FOSC>(new FOSC(){ Period = period }, input, ref cacheFOSC);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.FOSC FOSC(int period)
		{
			return indicator.FOSC(Input, period);
		}

		public Indicators.FOSC FOSC(ISeries<double> input , int period)
		{
			return indicator.FOSC(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.FOSC FOSC(int period)
		{
			return indicator.FOSC(Input, period);
		}

		public Indicators.FOSC FOSC(ISeries<double> input , int period)
		{
			return indicator.FOSC(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Hull Moving Average (HMA) employs weighted MA calculations to offer superior
	/// smoothing, and much less lag, over traditional SMA indicators.
	/// This indicator is based on the reference article found here:
	/// http://www.justdata.com.au/Journals/AlanHull/hull_ma.htm
	/// </summary>
	public class HMA : Indicator
	{
		private Series<double> diffSeries;
		private WMA	wma1;
		private WMA wma2;
		private WMA wmaDiffSeries;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionHMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameHMA;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				IsOverlay 					= true;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameHMA);
			}
			else if (State == State.DataLoaded)
			{
				diffSeries		= new Series<double>(this);
				wma1			= WMA(Inputs[0], (Period / 2));
				wma2			= WMA(Inputs[0], Period);
				wmaDiffSeries	= WMA(diffSeries, (int) Math.Sqrt(Period));
			}
		}

		protected override void OnBarUpdate()
		{
			diffSeries[0]	= 2 * wma1[0] - wma2[0];
			Value[0]		= wmaDiffSeries[0];
		}

		#region Properties
		[Range(2, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private HMA[] cacheHMA;
		public HMA HMA(int period)
		{
			return HMA(Input, period);
		}

		public HMA HMA(ISeries<double> input, int period)
		{
			if (cacheHMA != null)
				for (int idx = 0; idx < cacheHMA.Length; idx++)
					if (cacheHMA[idx] != null && cacheHMA[idx].Period == period && cacheHMA[idx].EqualsInput(input))
						return cacheHMA[idx];
			return CacheIndicator<HMA>(new HMA(){ Period = period }, input, ref cacheHMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.HMA HMA(int period)
		{
			return indicator.HMA(Input, period);
		}

		public Indicators.HMA HMA(ISeries<double> input , int period)
		{
			return indicator.HMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.HMA HMA(int period)
		{
			return indicator.HMA(Input, period);
		}

		public Indicators.HMA HMA(ISeries<double> input , int period)
		{
			return indicator.HMA(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
#endregion

// This namespace holds all indicators and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
	}
}


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Kaufman's Adaptive Moving Average. Developed by Perry Kaufman, this indicator is an
	/// EMA using an Efficiency Ratio to modify the smoothing constant, which ranges from
	/// a minimum of Fast Length to a maximum of Slow Length. Since this moving average is
	/// adaptive it tends to follow prices more closely than other MA's.
	/// </summary>
	public class KAMA : Indicator
	{
		private Series<double>	diffSeries;
		private double			fastCF;
		private double			slowCF;
		private SUM				sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionKAMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameKAMA;
				Fast						= 2;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				Period						= 10;
				Slow						= 30;

				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameKAMA);
			}
			else if (State == State.Configure)
			{
				fastCF		= 2.0 / (Fast + 1);
				slowCF		= 2.0 / (Slow + 1);
			}
			else if (State == State.DataLoaded)
			{
				diffSeries = new Series<double>(this);
				sum = SUM(diffSeries, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			double input0 = Input[0];
			diffSeries[0] = CurrentBar > 0 ? Math.Abs(input0 - Input[1]) : input0;

			if (CurrentBar < Period)
			{
				Value[0] = Input[0];
				return;
			}

			double signal = Math.Abs(input0 - Input[Period]);
			double noise  = sum[0];

			// Prevent div by zero
			if (noise == 0)
			{
				Value[0] = Value[1];
				return;
			}

			double value1   = Value[1];
			Value[0]		= value1 + Math.Pow((signal / noise) * (fastCF - slowCF) + slowCF, 2) * (input0 - value1);
		}

		#region Properties
		[Range(1, 125), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Fast", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Fast
		{ get; set; }

		[Range(5, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Period
		{ get; set; }

		[Range(1, 125), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Slow", GroupName = "NinjaScriptParameters", Order = 2)]
		public int Slow
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private KAMA[] cacheKAMA;
		public KAMA KAMA(int fast, int period, int slow)
		{
			return KAMA(Input, fast, period, slow);
		}

		public KAMA KAMA(ISeries<double> input, int fast, int period, int slow)
		{
			if (cacheKAMA != null)
				for (int idx = 0; idx < cacheKAMA.Length; idx++)
					if (cacheKAMA[idx] != null && cacheKAMA[idx].Fast == fast && cacheKAMA[idx].Period == period && cacheKAMA[idx].Slow == slow && cacheKAMA[idx].EqualsInput(input))
						return cacheKAMA[idx];
			return CacheIndicator<KAMA>(new KAMA(){ Fast = fast, Period = period, Slow = slow }, input, ref cacheKAMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.KAMA KAMA(int fast, int period, int slow)
		{
			return indicator.KAMA(Input, fast, period, slow);
		}

		public Indicators.KAMA KAMA(ISeries<double> input , int fast, int period, int slow)
		{
			return indicator.KAMA(input, fast, period, slow);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.KAMA KAMA(int fast, int period, int slow)
		{
			return indicator.KAMA(Input, fast, period, slow);
		}

		public Indicators.KAMA KAMA(ISeries<double> input , int fast, int period, int slow)
		{
			return indicator.KAMA(input, fast, period, slow);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Keltner Channel. The Keltner Channel is a similar indicator to Bollinger Bands.
	/// Here the midline is a standard moving average with the upper and lower bands offset
	/// by the SMA of the difference between the high and low of the previous bars.
	/// The offset multiplier as well as the SMA period is configurable.
	/// </summary>
	public class KeltnerChannel : Indicator
	{
		private Series<double>		diff;
		private	SMA					smaDiff;
		private	SMA					smaTypical;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionKeltnerChannel;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameKelterChannel;
				Period						= 10;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				OffsetMultiplier			= 1.5;

				AddPlot(Brushes.DarkGray,		NinjaTrader.Custom.Resource.KeltnerChannelMidline);
				AddPlot(Brushes.DodgerBlue,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
				AddPlot(Brushes.DodgerBlue,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
			}
			else if (State == State.DataLoaded)
			{
				diff				= new Series<double>(this);
				smaDiff				= SMA(diff, Period);
				smaTypical			= SMA(Typical, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			diff[0]			= High[0] - Low[0];

			double middle	= smaTypical[0];
			double offset	= smaDiff[0] * OffsetMultiplier;

			double upper	= middle + offset;
			double lower	= middle - offset;

			Midline[0]		= middle;
			Upper[0]		= upper;
			Lower[0]		= lower;
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Lower
		{
			get { return Values[2]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Midline
		{
			get { return Values[0]; }
		}

		[Range(0.01, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "OffsetMultiplier", GroupName = "NinjaScriptParameters", Order = 0)]
		public double OffsetMultiplier
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Period
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Upper
		{
			get { return Values[1]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private KeltnerChannel[] cacheKeltnerChannel;
		public KeltnerChannel KeltnerChannel(double offsetMultiplier, int period)
		{
			return KeltnerChannel(Input, offsetMultiplier, period);
		}

		public KeltnerChannel KeltnerChannel(ISeries<double> input, double offsetMultiplier, int period)
		{
			if (cacheKeltnerChannel != null)
				for (int idx = 0; idx < cacheKeltnerChannel.Length; idx++)
					if (cacheKeltnerChannel[idx] != null && cacheKeltnerChannel[idx].OffsetMultiplier == offsetMultiplier && cacheKeltnerChannel[idx].Period == period && cacheKeltnerChannel[idx].EqualsInput(input))
						return cacheKeltnerChannel[idx];
			return CacheIndicator<KeltnerChannel>(new KeltnerChannel(){ OffsetMultiplier = offsetMultiplier, Period = period }, input, ref cacheKeltnerChannel);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.KeltnerChannel KeltnerChannel(double offsetMultiplier, int period)
		{
			return indicator.KeltnerChannel(Input, offsetMultiplier, period);
		}

		public Indicators.KeltnerChannel KeltnerChannel(ISeries<double> input , double offsetMultiplier, int period)
		{
			return indicator.KeltnerChannel(input, offsetMultiplier, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.KeltnerChannel KeltnerChannel(double offsetMultiplier, int period)
		{
			return indicator.KeltnerChannel(Input, offsetMultiplier, period);
		}

		public Indicators.KeltnerChannel KeltnerChannel(ISeries<double> input , double offsetMultiplier, int period)
		{
			return indicator.KeltnerChannel(input, offsetMultiplier, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Returns a value of 1 when the current close is less than the prior close after penetrating the highest high of the last n bars.
	/// </summary>
	public class KeyReversalDown : Indicator
	{
		private MAX max;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionKeyReversalDown;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameKeyReversalDown;
				IsSuspendedWhileInactive	= true;
				Period						= 1;

				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.KeyReversalPlot0);
			}
			else if (State == State.DataLoaded)
				max = MAX(High, Period);
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < Period + 1)
				return;

			Value[0] = High[0] > max[1] && Close[0] < Close[1] ? 1: 0;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private KeyReversalDown[] cacheKeyReversalDown;
		public KeyReversalDown KeyReversalDown(int period)
		{
			return KeyReversalDown(Input, period);
		}

		public KeyReversalDown KeyReversalDown(ISeries<double> input, int period)
		{
			if (cacheKeyReversalDown != null)
				for (int idx = 0; idx < cacheKeyReversalDown.Length; idx++)
					if (cacheKeyReversalDown[idx] != null && cacheKeyReversalDown[idx].Period == period && cacheKeyReversalDown[idx].EqualsInput(input))
						return cacheKeyReversalDown[idx];
			return CacheIndicator<KeyReversalDown>(new KeyReversalDown(){ Period = period }, input, ref cacheKeyReversalDown);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.KeyReversalDown KeyReversalDown(int period)
		{
			return indicator.KeyReversalDown(Input, period);
		}

		public Indicators.KeyReversalDown KeyReversalDown(ISeries<double> input , int period)
		{
			return indicator.KeyReversalDown(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.KeyReversalDown KeyReversalDown(int period)
		{
			return indicator.KeyReversalDown(Input, period);
		}

		public Indicators.KeyReversalDown KeyReversalDown(ISeries<double> input , int period)
		{
			return indicator.KeyReversalDown(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Returns a value of 1 when the current close is greater than the prior close after penetrating the lowest low of the last n bars.
	/// </summary>
	public class KeyReversalUp : Indicator
	{
		private MIN min;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionKeyReversalUp;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameKeyReversalUp;
				IsSuspendedWhileInactive	= true;
				Period						= 1;

				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.KeyReversalPlot0);
			}
			else if (State == State.DataLoaded)
				min = MIN(Low, Period);
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < Period + 1)
				return;

			Value[0] = Low[0] < min[1] && Close[0] > Close[1] ? 1: 0;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private KeyReversalUp[] cacheKeyReversalUp;
		public KeyReversalUp KeyReversalUp(int period)
		{
			return KeyReversalUp(Input, period);
		}

		public KeyReversalUp KeyReversalUp(ISeries<double> input, int period)
		{
			if (cacheKeyReversalUp != null)
				for (int idx = 0; idx < cacheKeyReversalUp.Length; idx++)
					if (cacheKeyReversalUp[idx] != null && cacheKeyReversalUp[idx].Period == period && cacheKeyReversalUp[idx].EqualsInput(input))
						return cacheKeyReversalUp[idx];
			return CacheIndicator<KeyReversalUp>(new KeyReversalUp(){ Period = period }, input, ref cacheKeyReversalUp);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.KeyReversalUp KeyReversalUp(int period)
		{
			return indicator.KeyReversalUp(Input, period);
		}

		public Indicators.KeyReversalUp KeyReversalUp(ISeries<double> input , int period)
		{
			return indicator.KeyReversalUp(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.KeyReversalUp KeyReversalUp(int period)
		{
			return indicator.KeyReversalUp(Input, period);
		}

		public Indicators.KeyReversalUp KeyReversalUp(ISeries<double> input , int period)
		{
			return indicator.KeyReversalUp(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Linear Regression. The Linear Regression is an indicator that 'predicts' the value of a security's price.
	/// </summary>
	public class LinReg : Indicator
	{
		private double	avg;
		private double	divisor;
		private	double	intercept;
		private double	myPeriod;
		private double	priorSumXY;
		private	double	priorSumY;
		private double	slope;
		private double	sumX2;
		private	double	sumX;
		private double	sumXY;
		private double	sumY;
		private SUM		sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionLinReg;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameLinReg;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameLinReg);
			}
			else if (State == State.Configure)
			{
				avg	= divisor = intercept = myPeriod = priorSumXY
					= priorSumY = slope = sumX = sumX2 = sumY = sumXY = 0;
			}
			else if (State == State.DataLoaded)
			{
				sum = SUM(Inputs[0], Period);
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				double sumX = (double)Period * (Period - 1) * 0.5;
				double divisor = sumX * sumX - (double)Period * Period * (Period - 1) * (2 * Period - 1) / 6;
				double sumXY = 0;

				for (int count = 0; count < Period && CurrentBar - count >= 0; count++)
					sumXY += count * Input[count];

				double slope = ((double)Period * sumXY - sumX * SUM(Inputs[0], Period)[0]) / divisor;
				double intercept = (SUM(Inputs[0], Period)[0] - slope * sumX) / Period;

				Value[0] = intercept + slope * (Period - 1);
			}
			else
			{
				if (IsFirstTickOfBar)
				{
					priorSumY = sumY;
					priorSumXY = sumXY;
					myPeriod = Math.Min(CurrentBar + 1, Period);
					sumX = myPeriod * (myPeriod - 1) * 0.5;
					sumX2 = myPeriod * (myPeriod + 1) * 0.5;
					divisor = myPeriod * (myPeriod + 1) * (2 * myPeriod + 1) / 6 - sumX2 * sumX2 / myPeriod;
				}

				double input0 = Input[0];
				sumXY = priorSumXY - (CurrentBar >= Period ? priorSumY : 0) + myPeriod * input0;
				sumY = priorSumY + input0 - (CurrentBar >= Period ? Input[Period] : 0);
				avg = sumY / myPeriod;
				slope = (sumXY - sumX2 * avg) / divisor;
				intercept = (sum[0] - slope * sumX) / myPeriod;
				Value[0] = CurrentBar == 0 ? input0 : (intercept + slope * (myPeriod - 1));
			}
		}

		#region Properties
		[Range(2, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private LinReg[] cacheLinReg;
		public LinReg LinReg(int period)
		{
			return LinReg(Input, period);
		}

		public LinReg LinReg(ISeries<double> input, int period)
		{
			if (cacheLinReg != null)
				for (int idx = 0; idx < cacheLinReg.Length; idx++)
					if (cacheLinReg[idx] != null && cacheLinReg[idx].Period == period && cacheLinReg[idx].EqualsInput(input))
						return cacheLinReg[idx];
			return CacheIndicator<LinReg>(new LinReg(){ Period = period }, input, ref cacheLinReg);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.LinReg LinReg(int period)
		{
			return indicator.LinReg(Input, period);
		}

		public Indicators.LinReg LinReg(ISeries<double> input , int period)
		{
			return indicator.LinReg(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.LinReg LinReg(int period)
		{
			return indicator.LinReg(Input, period);
		}

		public Indicators.LinReg LinReg(ISeries<double> input , int period)
		{
			return indicator.LinReg(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Linnear Regression Intercept
	/// </summary>
	public class LinRegIntercept : Indicator
	{
		private double	avg;
		private double	divisor;
		private double	myPeriod;
		private double	priorSumXY;
		private	double	priorSumY;
		private double	slope;
		private double	sumX2;
		private	double	sumX;
		private double	sumXY;
		private double	sumY;
		private SUM		sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionLinRegIntercept;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameLinRegIntercept;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameLinRegIntercept);
			}
			else if (State == State.Configure)
			{
				avg	= divisor = myPeriod = priorSumXY = priorSumY = slope = sumX = sumX2 = sumY = sumXY = 0;
			}
			else if (State == State.DataLoaded)
			{
				sum = SUM(Inputs[0], Period);
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				double sumX = (double)Period * (Period - 1) * 0.5;
				double divisor = sumX * sumX - (double)Period * Period * (Period - 1) * (2 * Period - 1) / 6;
				double sumXY = 0;

				for (int count = 0; count < Period && CurrentBar - count >= 0; count++)
					sumXY += count * Input[count];

				double slope = ((double)Period * sumXY - sumX * SUM(Inputs[0], Period)[0]) / divisor;
				Value[0] = (SUM(Inputs[0], Period)[0] - slope * sumX) / Period;
			}
			else
			{
				if (IsFirstTickOfBar)
				{
					priorSumY = sumY;
					priorSumXY = sumXY;
					myPeriod = Math.Min(CurrentBar + 1, Period);
					sumX = myPeriod * (myPeriod - 1) * 0.5;
					sumX2 = myPeriod * (myPeriod + 1) * 0.5;
					divisor = myPeriod * (myPeriod + 1) * (2 * myPeriod + 1) / 6 - sumX2 * sumX2 / myPeriod;
				}

				double input0 = Input[0];
				sumXY = priorSumXY - (CurrentBar >= Period ? priorSumY : 0) + myPeriod * input0;
				sumY = priorSumY + input0 - (CurrentBar >= Period ? Input[Period] : 0);
				avg = sumY / myPeriod;
				slope = (sumXY - sumX2 * avg) / divisor;
				Value[0] = CurrentBar == 0 ? input0 : (sum[0] - slope * sumX) / myPeriod;
			}
		}

		#region Properties
		[Range(2, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private LinRegIntercept[] cacheLinRegIntercept;
		public LinRegIntercept LinRegIntercept(int period)
		{
			return LinRegIntercept(Input, period);
		}

		public LinRegIntercept LinRegIntercept(ISeries<double> input, int period)
		{
			if (cacheLinRegIntercept != null)
				for (int idx = 0; idx < cacheLinRegIntercept.Length; idx++)
					if (cacheLinRegIntercept[idx] != null && cacheLinRegIntercept[idx].Period == period && cacheLinRegIntercept[idx].EqualsInput(input))
						return cacheLinRegIntercept[idx];
			return CacheIndicator<LinRegIntercept>(new LinRegIntercept(){ Period = period }, input, ref cacheLinRegIntercept);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.LinRegIntercept LinRegIntercept(int period)
		{
			return indicator.LinRegIntercept(Input, period);
		}

		public Indicators.LinRegIntercept LinRegIntercept(ISeries<double> input , int period)
		{
			return indicator.LinRegIntercept(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.LinRegIntercept LinRegIntercept(int period)
		{
			return indicator.LinRegIntercept(Input, period);
		}

		public Indicators.LinRegIntercept LinRegIntercept(ISeries<double> input , int period)
		{
			return indicator.LinRegIntercept(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Linear Regression Slope
	/// </summary>
	public class LinRegSlope : Indicator
	{
		private double	avg;
		private double	divisor;
		private double	myPeriod;
		private double	priorSumXY;
		private	double	priorSumY;
		private double	sumX2;
		private double	sumXY;
		private double	sumY;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionLinRegSlope;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameLinRegSlope;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameLinRegSlope);
			}
			else if (State == State.Configure)
				avg	= divisor = myPeriod = priorSumXY = priorSumY = sumX2 = sumY = sumXY = 0;
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				double sumX = (double)Period * (Period - 1) * 0.5;
				double divisor = sumX * sumX - (double)Period * Period * (Period - 1) * (2 * Period - 1) / 6;
				double sumXY = 0;

				for (int count = 0; count < Period && CurrentBar - count >= 0; count++)
					sumXY += count * Input[count];

				Value[0] = ((double)Period * sumXY - sumX * SUM(Inputs[0], Period)[0]) / divisor;
			}
			else
			{
				if (IsFirstTickOfBar)
				{
					priorSumY = sumY;
					priorSumXY = sumXY;
					myPeriod = Math.Min(CurrentBar + 1, Period);
					sumX2 = myPeriod * (myPeriod + 1) * 0.5;
					divisor = myPeriod * (myPeriod + 1) * (2 * myPeriod + 1) / 6 - sumX2 * sumX2 / myPeriod;
				}

				double input0 = Input[0];
				sumXY = priorSumXY - (CurrentBar >= Period ? priorSumY : 0) + myPeriod * input0;
				sumY = priorSumY + input0 - (CurrentBar >= Period ? Input[Period] : 0);
				avg = sumY / myPeriod;
				Value[0] = CurrentBar <= Period ? 0 : (sumXY - sumX2 * avg) / divisor;
			}
		}

		#region Properties
		[Range(2, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private LinRegSlope[] cacheLinRegSlope;
		public LinRegSlope LinRegSlope(int period)
		{
			return LinRegSlope(Input, period);
		}

		public LinRegSlope LinRegSlope(ISeries<double> input, int period)
		{
			if (cacheLinRegSlope != null)
				for (int idx = 0; idx < cacheLinRegSlope.Length; idx++)
					if (cacheLinRegSlope[idx] != null && cacheLinRegSlope[idx].Period == period && cacheLinRegSlope[idx].EqualsInput(input))
						return cacheLinRegSlope[idx];
			return CacheIndicator<LinRegSlope>(new LinRegSlope(){ Period = period }, input, ref cacheLinRegSlope);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.LinRegSlope LinRegSlope(int period)
		{
			return indicator.LinRegSlope(Input, period);
		}

		public Indicators.LinRegSlope LinRegSlope(ISeries<double> input , int period)
		{
			return indicator.LinRegSlope(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.LinRegSlope LinRegSlope(int period)
		{
			return indicator.LinRegSlope(Input, period);
		}

		public Indicators.LinRegSlope LinRegSlope(ISeries<double> input , int period)
		{
			return indicator.LinRegSlope(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The MACD (Moving Average Convergence/Divergence) is a trend following momentum indicator
	/// that shows the relationship between two moving averages of prices.
	/// </summary>
	public class MACD : Indicator
	{
		private	Series<double>		fastEma;
		private	Series<double>		slowEma;
		private double				constant1;
		private double				constant2;
		private double				constant3;
		private double				constant4;
		private double				constant5;
		private double				constant6;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= Custom.Resource.NinjaScriptIndicatorDescriptionMACD;
				Name						= Custom.Resource.NinjaScriptIndicatorNameMACD;
				Fast						= 12;
				IsSuspendedWhileInactive	= true;
				Slow						= 26;
				Smooth						= 9;

				AddPlot(Brushes.DarkCyan,									Custom.Resource.NinjaScriptIndicatorNameMACD);
				AddPlot(Brushes.Crimson,									Custom.Resource.NinjaScriptIndicatorAvg);
				AddPlot(new Stroke(Brushes.DodgerBlue, 2),	PlotStyle.Bar,	Custom.Resource.NinjaScriptIndicatorDiff);
				AddLine(Brushes.DarkGray,					0,				Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.Configure)
			{
				constant1	= 2.0 / (1 + Fast);
				constant2	= 1 - (2.0 / (1 + Fast));
				constant3	= 2.0 / (1 + Slow);
				constant4	= 1 - (2.0 / (1 + Slow));
				constant5	= 2.0 / (1 + Smooth);
				constant6	= 1 - (2.0 / (1 + Smooth));
			}
			else if (State == State.DataLoaded)
			{
				fastEma = new Series<double>(this);
				slowEma = new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			double input0	= Input[0];

			if (CurrentBar == 0)
			{
				fastEma[0]		= input0;
				slowEma[0]		= input0;
				Value[0]		= 0;
				Avg[0]			= 0;
				Diff[0]			= 0;
			}
			else
			{
				double fastEma0	= constant1 * input0 + constant2 * fastEma[1];
				double slowEma0	= constant3 * input0 + constant4 * slowEma[1];
				double macd		= fastEma0 - slowEma0;
				double macdAvg	= constant5 * macd + constant6 * Avg[1];

				fastEma[0]		= fastEma0;
				slowEma[0]		= slowEma0;
				Value[0]		= macd;
				Avg[0]			= macdAvg;
				Diff[0]			= macd - macdAvg;
			}
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Avg
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Default
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Diff
		{
			get { return Values[2]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Fast", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Fast
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Slow", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Slow
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 2)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MACD[] cacheMACD;
		public MACD MACD(int fast, int slow, int smooth)
		{
			return MACD(Input, fast, slow, smooth);
		}

		public MACD MACD(ISeries<double> input, int fast, int slow, int smooth)
		{
			if (cacheMACD != null)
				for (int idx = 0; idx < cacheMACD.Length; idx++)
					if (cacheMACD[idx] != null && cacheMACD[idx].Fast == fast && cacheMACD[idx].Slow == slow && cacheMACD[idx].Smooth == smooth && cacheMACD[idx].EqualsInput(input))
						return cacheMACD[idx];
			return CacheIndicator<MACD>(new MACD(){ Fast = fast, Slow = slow, Smooth = smooth }, input, ref cacheMACD);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MACD MACD(int fast, int slow, int smooth)
		{
			return indicator.MACD(Input, fast, slow, smooth);
		}

		public Indicators.MACD MACD(ISeries<double> input , int fast, int slow, int smooth)
		{
			return indicator.MACD(input, fast, slow, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MACD MACD(int fast, int slow, int smooth)
		{
			return indicator.MACD(Input, fast, slow, smooth);
		}

		public Indicators.MACD MACD(ISeries<double> input , int fast, int slow, int smooth)
		{
			return indicator.MACD(input, fast, slow, smooth);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Moving Average Envelopes
	/// </summary>
	public class MAEnvelopes : Indicator
	{
		private EMA		ema;
		private HMA		hma;
		private SMA		sma;
		private TEMA	tema;
		private TMA		tma;
		private WMA		wma;
		private double envelopePercentage;
		private int period;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMAEnvelopes;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMAEnvelopes;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				MAType						= 3;
				Period						= 14;
				EnvelopePercentage			= 1.5;

				AddPlot(Brushes.DodgerBlue,																NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
				AddPlot(new Gui.Stroke(Brushes.DodgerBlue, DashStyleHelper.Dash, 1), PlotStyle.Line,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorMiddle);
				AddPlot(Brushes.DodgerBlue,																NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
			}
			else if (State == State.DataLoaded)
			{
				ema		= EMA(Inputs[0], Period);
				hma		= HMA(Inputs[0], Math.Max(2, Period));
				sma		= SMA(Inputs[0], Period);
				tma		= TMA(Inputs[0], Period);
				tema	= TEMA(Inputs[0], Period);
				wma		= WMA(Inputs[0], Period);
			}
		}

		protected override void OnBarUpdate()
		{
			double maValue = 0;

			switch (MAType)
			{
				case 1:
				{
					Middle[0] = maValue = ema[0];
					break;
				}
				case 2:
				{
					Middle[0] = maValue = hma[0];
					break;
				}
				case 3:
				{
					Middle[0] = maValue = sma[0];
					break;
				}
				case 4:
				{
					Middle[0] = maValue = tma[0];
					break;
				}
				case 5:
				{
					Middle[0] = maValue = tema[0];
					break;
				}
				case 6:
				{
					Middle[0] = maValue = wma[0];
					break;
				}
			}

			Upper[0] = maValue + (maValue * EnvelopePercentage / 100);
			Lower[0] = maValue - (maValue * EnvelopePercentage / 100);
		}

		#region Properties

		[Range(0.01, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "EnvelopePercentage",
			GroupName = "NinjaScriptParameters", Order = 0)]
		public double EnvelopePercentage
		{
			get { return envelopePercentage; }
			set { envelopePercentage = value; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Lower { get { return Values[2]; } }

		[Range(1, 6), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "MAType", GroupName = "NinjaScriptParameters", Order = 1)]
		[RefreshProperties(RefreshProperties.All)]
		[TypeConverter(typeof(MovingAverageEnumConverter))] // Converts the int to string values
		[PropertyEditor("NinjaTrader.Gui.Tools.StringStandardValuesEditorKey")] // Create the combo box on the property grid
		public int MAType { get; set; }

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Middle { get { return Values[1]; } }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 2)]
		public int Period
		{
			get { return MAType != 2 ? period : Math.Max(2, period); }
			set { period = MAType != 2 ? value : Math.Max(2, value); }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Upper { get { return Values[0]; } }
		#endregion
	}

	#region MovingAverageEnumConverter
	public class MovingAverageEnumConverter : TypeConverter
	{
		// Set the values to appear in the combo box
		public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
		{
			List<string> values = new List<string>() { "EMA", "HMA", "SMA", "TMA", "TEMA", "WMA" };

			return new StandardValuesCollection(values);
		}

		// map the value from string to int type
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			int mATypeValue = 3;

			switch (value.ToString())
			{
				case "EMA": mATypeValue = 1; break;
				case "HMA": mATypeValue = 2; break;
				case "SMA": mATypeValue = 3; break;
				case "TMA": mATypeValue = 4; break;
				case "TEMA": mATypeValue = 5; break;
				case "WMA": mATypeValue = 6; break;
			}
			return mATypeValue;
		}

		// map the int type to string
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			string mATypeString = "SMA";

			switch (value.ToString())
			{
				case "1": mATypeString = "EMA"; break;
				case "2": mATypeString = "HMA"; break;
				case "3": mATypeString = "SMA"; break;
				case "4": mATypeString = "TMA"; break;
				case "5": mATypeString = "TEMA"; break;
				case "6": mATypeString = "WMA"; break;
			}
			return mATypeString;
		}

		// required interface members needed to compile
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{ return true; }

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{ return true; }

		public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
		{ return true; }

		public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
		{ return true; }
	}
	#endregion
}
#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MAEnvelopes[] cacheMAEnvelopes;
		public MAEnvelopes MAEnvelopes(double envelopePercentage, int mAType, int period)
		{
			return MAEnvelopes(Input, envelopePercentage, mAType, period);
		}

		public MAEnvelopes MAEnvelopes(ISeries<double> input, double envelopePercentage, int mAType, int period)
		{
			if (cacheMAEnvelopes != null)
				for (int idx = 0; idx < cacheMAEnvelopes.Length; idx++)
					if (cacheMAEnvelopes[idx] != null && cacheMAEnvelopes[idx].EnvelopePercentage == envelopePercentage && cacheMAEnvelopes[idx].MAType == mAType && cacheMAEnvelopes[idx].Period == period && cacheMAEnvelopes[idx].EqualsInput(input))
						return cacheMAEnvelopes[idx];
			return CacheIndicator<MAEnvelopes>(new MAEnvelopes(){ EnvelopePercentage = envelopePercentage, MAType = mAType, Period = period }, input, ref cacheMAEnvelopes);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MAEnvelopes MAEnvelopes(double envelopePercentage, int mAType, int period)
		{
			return indicator.MAEnvelopes(Input, envelopePercentage, mAType, period);
		}

		public Indicators.MAEnvelopes MAEnvelopes(ISeries<double> input , double envelopePercentage, int mAType, int period)
		{
			return indicator.MAEnvelopes(input, envelopePercentage, mAType, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MAEnvelopes MAEnvelopes(double envelopePercentage, int mAType, int period)
		{
			return indicator.MAEnvelopes(Input, envelopePercentage, mAType, period);
		}

		public Indicators.MAEnvelopes MAEnvelopes(ISeries<double> input , double envelopePercentage, int mAType, int period)
		{
			return indicator.MAEnvelopes(input, envelopePercentage, mAType, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The MAMA (MESA Adaptive Moving Average) was developed by John Ehlers.
	/// It adapts to price movement in a new and unique way. The adaptation is
	/// based on the Hilbert Transform Discriminator. The adavantage of this method
	/// features fast attack average and a slow decay average. The MAMA + the FAMA
	/// (Following Adaptive Moving Average) lines only cross at major market reversals.
	/// </summary>
	public class MAMA : Indicator
	{
		private Series<double>		detrender;
		private Series<double>	    i1;
		private Series<double>	    i2;
		private Series<double>	    im;
		private Series<double>		period;
		private Series<double>	    phase;
		private Series<double>		q1;
		private Series<double>		q2;
		private Series<double>	    re;
		private Series<double>		smooth;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMAMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMAMA;
				FastLimit					= 0.5;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				SlowLimit					= 0.05;

				AddPlot(Brushes.Goldenrod,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorDefault);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.MAMAFAMA);
			}
			else if (State == State.DataLoaded)
			{
				detrender	= new Series<double>(this);
				period		= new Series<double>(this);
				smooth		= new Series<double>(this);
				i1			= new Series<double>(this);
				i2			= new Series<double>(this);
				im			= new Series<double>(this);
				q1			= new Series<double>(this);
				q2			= new Series<double>(this);
				re			= new Series<double>(this);
				phase		= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < 6)
				return;
			if (CurrentBar == 6)
			{
				Default[0]	= (High[0] + Low[0]) / 2;
				Fama[0]		= Input[0];
				return;
			}

			double period1	= period[1];
			smooth[0]		= (4 * Median[0] + 3 * Median[1] + 2 * Median[2] + Median[3]) / 10;
			detrender[0]	= (0.0962 * smooth[0] + 0.5769 * smooth[2]
								- 0.5769 * smooth[4] - 0.0962 * smooth[6]) * (0.075 * period1 + 0.54);

			// Compute InPhase and Quadrature components
			q1[0]			= (0.0962 * detrender[0] + 0.5769 * detrender[2]
								- 0.5769 * detrender[4] - 0.0962 * detrender[6]) * (0.075 * period1 + 0.54);
			i1[0]			= detrender[3];
			double i10		= i1[0];

			// Advance the phase of i1 and q1 by 90
			double jI		= (0.0962 * i10 + 0.5769 * i1[2] - 0.5769 * i1[4] - 0.0962 * i1[6]) * (0.075 * period1 + 0.54);
			double jQ		= (0.0962 * q1[0] + 0.5769 * q1[2] - 0.5769 * q1[4] - 0.0962 * q1[6]) * (0.075 * period1 + 0.54);

			// Phasor addition for 3 bar averaging
			i2[0]			= i10 - jQ;
			q2[0]			= q1[0] + jI;

			// Smooth the I and Q components before applying the discriminator
			i2[0]			= 0.2 * i2[0] + 0.8 * i2[1];
			q2[0]			= 0.2 * q2[0] + 0.8 * q2[1];

			double i20		= i2[0];
			double q21		= q2[1];
			double i21		= i2[1];
			double q20		= q2[0];
			double period0	= period[0];

			// Homodyne Discriminator
			re[0]			= i20 * i21 + q20 * q21;
			im[0]			= i20 * q21 - q20 * i21;
			re[0]			= 0.2 * re[0] + 0.8 * re[1];
			im[0]			= 0.2 * im[0] + 0.8 * im[1];

			if (im[0] != 0.0 && re[0] != 0.0)	period0 = 360 / ((180 / Math.PI) * System.Math.Atan(im[0] / re[0]));
			if (period0 > 1.5  * period1)		period0 = 1.5  * period1;
			if (period0 < 0.67 * period1)		period0 = 0.67 * period1;
			if (period0 < 6)					period0 = 6;
			if (period0 > 50)					period0 = 50;

			period[0] = 0.2 * period0 + 0.8 * period1;

			if (i1[0] != 0.0) phase[0] = (180 / Math.PI) * System.Math.Atan(q1[0] / i1[0]);

			double deltaPhase = phase[1] - phase[0];
			if (deltaPhase < 1)	deltaPhase = 1;

			double alpha = FastLimit / deltaPhase;
			if (alpha < SlowLimit) alpha = SlowLimit;

			// MAMA
			Default[0]	= alpha * Median[0] + (1 - alpha) * Default[1];
			// FAMA
			Fama[0]		= 0.5 * alpha * Default[0] + (1 - 0.5 * alpha) * Fama[1];
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Default
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Fama
		{
			get { return Values[1]; }
		}

		[Range(0.05, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "FastLimit", GroupName = "NinjaScriptParameters", Order = 0)]
		public double FastLimit
		{ get; set; }

		[Range(0.005, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "SlowLimit", GroupName = "NinjaScriptParameters", Order = 1)]
		public double SlowLimit
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MAMA[] cacheMAMA;
		public MAMA MAMA(double fastLimit, double slowLimit)
		{
			return MAMA(Input, fastLimit, slowLimit);
		}

		public MAMA MAMA(ISeries<double> input, double fastLimit, double slowLimit)
		{
			if (cacheMAMA != null)
				for (int idx = 0; idx < cacheMAMA.Length; idx++)
					if (cacheMAMA[idx] != null && cacheMAMA[idx].FastLimit == fastLimit && cacheMAMA[idx].SlowLimit == slowLimit && cacheMAMA[idx].EqualsInput(input))
						return cacheMAMA[idx];
			return CacheIndicator<MAMA>(new MAMA(){ FastLimit = fastLimit, SlowLimit = slowLimit }, input, ref cacheMAMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MAMA MAMA(double fastLimit, double slowLimit)
		{
			return indicator.MAMA(Input, fastLimit, slowLimit);
		}

		public Indicators.MAMA MAMA(ISeries<double> input , double fastLimit, double slowLimit)
		{
			return indicator.MAMA(input, fastLimit, slowLimit);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MAMA MAMA(double fastLimit, double slowLimit)
		{
			return indicator.MAMA(Input, fastLimit, slowLimit);
		}

		public Indicators.MAMA MAMA(ISeries<double> input , double fastLimit, double slowLimit)
		{
			return indicator.MAMA(input, fastLimit, slowLimit);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Maximum shows the maximum of the last n bars.
	/// </summary>
	public class MAX : Indicator
	{
		private int		lastBar;
		private double	lastMax;
		private double	runningMax;
		private int		runningBar;
		private int		thisBar;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMAX;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMAX;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.DarkCyan, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMAX);
			}
			else if (State == State.Configure)
			{
				lastBar		= 0;
				lastMax		= 0;
				runningMax	= 0;
				runningBar	= 0;
				thisBar		= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				runningMax	= Input[0];
				lastMax		= Input[0];
				runningBar	= 0;
				lastBar		= 0;
				thisBar		= 0;
				Value[0]	= Input[0];
				return;
			}

			if (CurrentBar - runningBar >= Period || CurrentBar < thisBar)
			{
				runningMax = double.MinValue;
				for (int barsBack = Math.Min(CurrentBar, Period - 1); barsBack > 0; barsBack--)
					if (Input[barsBack] >= runningMax)
					{
						runningMax = Input[barsBack];
						runningBar = CurrentBar - barsBack;
					}
			}

			if (thisBar != CurrentBar)
			{
				lastMax = runningMax;
				lastBar = runningBar;
				thisBar = CurrentBar;
			}

			if (Input[0] >= lastMax)
			{
				runningMax = Input[0];
				runningBar = CurrentBar;
			}
			else
			{
				runningMax = lastMax;
				runningBar = lastBar;
			}

			Value[0] = runningMax;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MAX[] cacheMAX;
		public MAX MAX(int period)
		{
			return MAX(Input, period);
		}

		public MAX MAX(ISeries<double> input, int period)
		{
			if (cacheMAX != null)
				for (int idx = 0; idx < cacheMAX.Length; idx++)
					if (cacheMAX[idx] != null && cacheMAX[idx].Period == period && cacheMAX[idx].EqualsInput(input))
						return cacheMAX[idx];
			return CacheIndicator<MAX>(new MAX(){ Period = period }, input, ref cacheMAX);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MAX MAX(int period)
		{
			return indicator.MAX(Input, period);
		}

		public Indicators.MAX MAX(ISeries<double> input , int period)
		{
			return indicator.MAX(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MAX MAX(int period)
		{
			return indicator.MAX(Input, period);
		}

		public Indicators.MAX MAX(ISeries<double> input , int period)
		{
			return indicator.MAX(input, period);
		}
	}
}

#endregion


#########################

﻿//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// McClellan Oscillator is the difference between two exponential moving averages of the NYSE advance decline spread. This indicator require ADV and DECL index data.
	/// </summary>
	public class McClellanOscillator : Indicator
	{
		private Series<double> subtractADVDECL;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMcClellanOscillator;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMcClellanOscillator;
				Calculate					= Calculate.OnBarClose;
				IsOverlay					= false;
				DrawOnPricePanel			= false;
				IsSuspendedWhileInactive	= true;
				FastPeriod					= 19;
				SlowPeriod					= 39;
				NegativeColor				= Brushes.Red;

				AddPlot(new Stroke(Brushes.LimeGreen, DashStyleHelper.Solid, 1), PlotStyle.Line, NinjaTrader.Custom.Resource.NinjaScriptIndicatorMcClellanOscillatorLine);

				AddLine(Brushes.DarkCyan, 70,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorOverBoughtLine);
				AddLine(Brushes.DarkCyan, -70,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorOverSoldLine);
				AddLine(Brushes.DarkGray, 0,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.Configure)
			{
				AddDataSeries("^ADV");
				AddDataSeries("^DECL");
			}
			else if (State == State.DataLoaded)
				subtractADVDECL = new Series<double>(this);
		}

		protected override void OnBarUpdate()
		{
			if (BarsInProgress == 0 && CurrentBars[0] >= 0 && CurrentBars[1] >= 0 && CurrentBars[2] >= 0)
			{
				subtractADVDECL[0]	= Closes[1][0] - Closes[2][0];
				Value[0]			= EMA(subtractADVDECL, FastPeriod)[0] - EMA(subtractADVDECL, SlowPeriod)[0];

				if (Value[0] < 0)
					PlotBrushes[0][0] = NegativeColor;
			}
		}
		
		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "FastPeriod", GroupName = "NinjaScriptParameters", Order = 0)]
		public int FastPeriod { get; set; }
		
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "SlowPeriod", GroupName = "NinjaScriptParameters", Order = 1)]
		public int SlowPeriod { get; set; }
		
		[XmlIgnore]
		[Display(ResourceType = typeof(Custom.Resource), Name = "NegativeColor", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 1800)]
		public Brush NegativeColor { get; set; }
		
		[Browsable(false)]
		public string NegativeColorSerialize
		{
			get { return Serialize.BrushToString(NegativeColor); }
			set { NegativeColor = Serialize.StringToBrush(value); }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private McClellanOscillator[] cacheMcClellanOscillator;
		public McClellanOscillator McClellanOscillator(int fastPeriod, int slowPeriod)
		{
			return McClellanOscillator(Input, fastPeriod, slowPeriod);
		}

		public McClellanOscillator McClellanOscillator(ISeries<double> input, int fastPeriod, int slowPeriod)
		{
			if (cacheMcClellanOscillator != null)
				for (int idx = 0; idx < cacheMcClellanOscillator.Length; idx++)
					if (cacheMcClellanOscillator[idx] != null && cacheMcClellanOscillator[idx].FastPeriod == fastPeriod && cacheMcClellanOscillator[idx].SlowPeriod == slowPeriod && cacheMcClellanOscillator[idx].EqualsInput(input))
						return cacheMcClellanOscillator[idx];
			return CacheIndicator<McClellanOscillator>(new McClellanOscillator(){ FastPeriod = fastPeriod, SlowPeriod = slowPeriod }, input, ref cacheMcClellanOscillator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.McClellanOscillator McClellanOscillator(int fastPeriod, int slowPeriod)
		{
			return indicator.McClellanOscillator(Input, fastPeriod, slowPeriod);
		}

		public Indicators.McClellanOscillator McClellanOscillator(ISeries<double> input , int fastPeriod, int slowPeriod)
		{
			return indicator.McClellanOscillator(input, fastPeriod, slowPeriod);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.McClellanOscillator McClellanOscillator(int fastPeriod, int slowPeriod)
		{
			return indicator.McClellanOscillator(Input, fastPeriod, slowPeriod);
		}

		public Indicators.McClellanOscillator McClellanOscillator(ISeries<double> input , int fastPeriod, int slowPeriod)
		{
			return indicator.McClellanOscillator(input, fastPeriod, slowPeriod);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The MFI (Money Flow Index) is a momentum indicator that measures the strength of money flowing in and out of a security.
	/// </summary>
	public class MFI : Indicator
	{
		private	Series<double>		negative;
		private	Series<double>		positive;
		private	SUM					sumNegative;
		private SUM					sumPositive;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMFI;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMFI;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				DrawOnPricePanel			= false;

				AddPlot(Brushes.DarkCyan,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMFI);
				AddLine(Brushes.SlateBlue,	20,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.Goldenrod,	80,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
			else if (State == State.DataLoaded)
			{
				negative		= new Series<double>(this);
				positive		= new Series<double>(this);
				sumNegative		= SUM(negative, Period);
				sumPositive		= SUM(positive, Period);
			}
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
				Value[0] = 50;
			else
			{
				double typical0		= Typical[0];
				double typical1		= Typical[1];
				double volume0		= Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0];
				negative[0]			= typical0 < typical1 ? typical0 * volume0 : 0;
				positive[0]			= typical0 > typical1 ? typical0 * volume0 : 0;

				double sumNegative0	= sumNegative[0];
				Value[0]			= sumNegative0 == 0 ? 50 : 100.0 - (100.0 / (1 + sumPositive[0] / sumNegative0));
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MFI[] cacheMFI;
		public MFI MFI(int period)
		{
			return MFI(Input, period);
		}

		public MFI MFI(ISeries<double> input, int period)
		{
			if (cacheMFI != null)
				for (int idx = 0; idx < cacheMFI.Length; idx++)
					if (cacheMFI[idx] != null && cacheMFI[idx].Period == period && cacheMFI[idx].EqualsInput(input))
						return cacheMFI[idx];
			return CacheIndicator<MFI>(new MFI(){ Period = period }, input, ref cacheMFI);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MFI MFI(int period)
		{
			return indicator.MFI(Input, period);
		}

		public Indicators.MFI MFI(ISeries<double> input , int period)
		{
			return indicator.MFI(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MFI MFI(int period)
		{
			return indicator.MFI(Input, period);
		}

		public Indicators.MFI MFI(ISeries<double> input , int period)
		{
			return indicator.MFI(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Minimum shows the minimum of the last n bars.
	/// </summary>
	public class MIN : Indicator
	{
		private int		lastBar;
		private double	lastMin;
		private double	runningMin;
		private int		runningBar;
		private int		thisBar;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMIN;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMIN;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.DarkCyan, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMIN);
			}
			else if (State == State.Configure)
			{
				lastBar		= 0;
				lastMin		= 0;
				runningMin	= 0;
				runningBar	= 0;
				thisBar		= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				runningMin  = Input[0];
				lastMin     = Input[0];
				runningBar  = 0;
				lastBar		= 0;
				thisBar		= 0;
				Value[0]	= Input[0];
				return;
			}

			if (CurrentBar - runningBar >= Period || CurrentBar < thisBar)
			{
				runningMin = double.MaxValue;
				for (int barsBack = Math.Min(CurrentBar, Period - 1); barsBack > 0; barsBack--)
					if (Input[barsBack] <= runningMin)
					{
						runningMin  = Input[barsBack];
						runningBar  = CurrentBar - barsBack;
					}
			}

			if (thisBar != CurrentBar)
			{
				lastMin = runningMin;
				lastBar = runningBar;
				thisBar = CurrentBar;
			}

			if (Input[0] <= lastMin)
			{
				runningMin = Input[0];
				runningBar = CurrentBar;
			}
			else
			{
				runningMin = lastMin;
				runningBar = lastBar;
			}

			Value[0] = runningMin;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MIN[] cacheMIN;
		public MIN MIN(int period)
		{
			return MIN(Input, period);
		}

		public MIN MIN(ISeries<double> input, int period)
		{
			if (cacheMIN != null)
				for (int idx = 0; idx < cacheMIN.Length; idx++)
					if (cacheMIN[idx] != null && cacheMIN[idx].Period == period && cacheMIN[idx].EqualsInput(input))
						return cacheMIN[idx];
			return CacheIndicator<MIN>(new MIN(){ Period = period }, input, ref cacheMIN);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MIN MIN(int period)
		{
			return indicator.MIN(Input, period);
		}

		public Indicators.MIN MIN(ISeries<double> input , int period)
		{
			return indicator.MIN(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MIN MIN(int period)
		{
			return indicator.MIN(Input, period);
		}

		public Indicators.MIN MIN(ISeries<double> input , int period)
		{
			return indicator.MIN(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Momentum indicator measures the amount that a security's price has changed over a given time span.
	/// </summary>
	public class Momentum : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMomentum;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMomentum;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.DarkCyan,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMomentum);
				AddLine(Brushes.SlateBlue,	0,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = CurrentBar == 0 ? 0 : Input[0] - Input[Math.Min(CurrentBar, Period)];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Momentum[] cacheMomentum;
		public Momentum Momentum(int period)
		{
			return Momentum(Input, period);
		}

		public Momentum Momentum(ISeries<double> input, int period)
		{
			if (cacheMomentum != null)
				for (int idx = 0; idx < cacheMomentum.Length; idx++)
					if (cacheMomentum[idx] != null && cacheMomentum[idx].Period == period && cacheMomentum[idx].EqualsInput(input))
						return cacheMomentum[idx];
			return CacheIndicator<Momentum>(new Momentum(){ Period = period }, input, ref cacheMomentum);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Momentum Momentum(int period)
		{
			return indicator.Momentum(Input, period);
		}

		public Indicators.Momentum Momentum(ISeries<double> input , int period)
		{
			return indicator.Momentum(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Momentum Momentum(int period)
		{
			return indicator.Momentum(Input, period);
		}

		public Indicators.Momentum Momentum(ISeries<double> input , int period)
		{
			return indicator.Momentum(input, period);
		}
	}
}

#endregion


#########################

﻿//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Windows.Media;
using System.Xml.Serialization;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Money Flow Oscillator measures the amount of money flow volume over a specific period. A move into positive territory indicates buying pressure while a move into negative territory indicates selling pressure.
	/// </summary>
	public class MoneyFlowOscillator : Indicator
	{
		private Series<double> mfv;
		private double dvs, mltp;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMoneyFlowOscillator;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMoneyFlowOscillator;
				IsOverlay					= false;
				DrawOnPricePanel			= false;
				IsSuspendedWhileInactive	= true;
				Period						= 20;
				
				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.NinjaScriptIndicatorMoneyFlowLine);
				AddLine(Brushes.DarkGray, 0, NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.DataLoaded)
			{				
				mfv = new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			if(CurrentBar > 0)
			{
				dvs 	= (High[0] - Low[1]) + (High[1] - Low[0]) == 0 ? 0.00001 : (High[0] - Low[1]) + (High[1] - Low[0]);
				mltp 	= Math.Round(High[0] < Low[1] ? -1: Low[0] > High[1] ? 1 : ((High[0] - Low[1]) - (High[1] - Low[0])) / dvs, 2);
				mfv[0] 	= mltp * (Instrument.MasterInstrument.InstrumentType == Cbi.InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0]);

				if (CurrentBar >= Period)
				{
					double sumVolume = SUM(Volume, Period)[0];
					if (Instrument.MasterInstrument.InstrumentType == Cbi.InstrumentType.CryptoCurrency)
						sumVolume = Core.Globals.ToCryptocurrencyVolume((long)sumVolume);
					Values[0][0] = Math.Round(SUM(mfv, Period)[0] / sumVolume, 3);
				}
			}
			else
				mfv[0] = 0;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period { get; set; }

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> MoneyFlow { get { return Values[0]; } }
		#endregion

	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MoneyFlowOscillator[] cacheMoneyFlowOscillator;
		public MoneyFlowOscillator MoneyFlowOscillator(int period)
		{
			return MoneyFlowOscillator(Input, period);
		}

		public MoneyFlowOscillator MoneyFlowOscillator(ISeries<double> input, int period)
		{
			if (cacheMoneyFlowOscillator != null)
				for (int idx = 0; idx < cacheMoneyFlowOscillator.Length; idx++)
					if (cacheMoneyFlowOscillator[idx] != null && cacheMoneyFlowOscillator[idx].Period == period && cacheMoneyFlowOscillator[idx].EqualsInput(input))
						return cacheMoneyFlowOscillator[idx];
			return CacheIndicator<MoneyFlowOscillator>(new MoneyFlowOscillator(){ Period = period }, input, ref cacheMoneyFlowOscillator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MoneyFlowOscillator MoneyFlowOscillator(int period)
		{
			return indicator.MoneyFlowOscillator(Input, period);
		}

		public Indicators.MoneyFlowOscillator MoneyFlowOscillator(ISeries<double> input , int period)
		{
			return indicator.MoneyFlowOscillator(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MoneyFlowOscillator MoneyFlowOscillator(int period)
		{
			return indicator.MoneyFlowOscillator(Input, period);
		}

		public Indicators.MoneyFlowOscillator MoneyFlowOscillator(ISeries<double> input , int period)
		{
			return indicator.MoneyFlowOscillator(input, period);
		}
	}
}

#endregion


#########################

﻿//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Gui;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Moving Average Ribbon is a series of incrementing moving averages.
	/// </summary>
	public class MovingAverageRibbon : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMovingAverageRibbon;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMovingAverageRibbon;
				Calculate					= Calculate.OnBarClose;
				IsOverlay					= true;
				DrawOnPricePanel			= true;
				IsSuspendedWhileInactive	= true;
				MovingAverage 				= RibbonMAType.Exponential;
				BasePeriod 					= 10;
				IncrementalPeriod 			= 10;
				
				AddPlot(new Stroke(Brushes.Yellow, 		DashStyleHelper.Solid, 1), PlotStyle.Line, NinjaTrader.Custom.Resource.MovingAverageRibbonPlot1);
				AddPlot(new Stroke(Brushes.Gold, 		DashStyleHelper.Solid, 1), PlotStyle.Line, NinjaTrader.Custom.Resource.MovingAverageRibbonPlot2);
				AddPlot(new Stroke(Brushes.Goldenrod, 	DashStyleHelper.Solid, 1), PlotStyle.Line, NinjaTrader.Custom.Resource.MovingAverageRibbonPlot3);
				AddPlot(new Stroke(Brushes.Orange, 		DashStyleHelper.Solid, 1), PlotStyle.Line, NinjaTrader.Custom.Resource.MovingAverageRibbonPlot4);
				AddPlot(new Stroke(Brushes.DarkOrange, 	DashStyleHelper.Solid, 1), PlotStyle.Line, NinjaTrader.Custom.Resource.MovingAverageRibbonPlot5);
				AddPlot(new Stroke(Brushes.Chocolate, 	DashStyleHelper.Solid, 1), PlotStyle.Line, NinjaTrader.Custom.Resource.MovingAverageRibbonPlot6);
				AddPlot(new Stroke(Brushes.OrangeRed, 	DashStyleHelper.Solid, 1), PlotStyle.Line, NinjaTrader.Custom.Resource.MovingAverageRibbonPlot7);
				AddPlot(new Stroke(Brushes.Red, 		DashStyleHelper.Solid, 1), PlotStyle.Line, NinjaTrader.Custom.Resource.MovingAverageRibbonPlot8);
			}
		}

		protected override void OnBarUpdate()
		{
			for (int i = 0; i < 8; i++)
			{
				switch (MovingAverage)
				{
					case RibbonMAType.Exponential:
						Values[i][0] = EMA(Input, BasePeriod + IncrementalPeriod * i)[0];
						break;
					case RibbonMAType.Hull:
						Values[i][0] = HMA(Input, BasePeriod + IncrementalPeriod * i)[0];
						break;
					case RibbonMAType.Simple:
						Values[i][0] = SMA(Input, BasePeriod + IncrementalPeriod * i)[0];
						break;
					case RibbonMAType.Weighted:
						Values[i][0] = WMA(Input, BasePeriod + IncrementalPeriod * i)[0];
						break;
				}
			}
		}
		
		#region Properties
		[XmlIgnore]
		[Browsable(false)]
		public Series<double> MovingAverage1 {  get { return Values[0]; } }

		[XmlIgnore]
		[Browsable(false)]
		public Series<double> MovingAverage2 {  get { return Values[1]; } }

		[XmlIgnore]
		[Browsable(false)]
		public Series<double> MovingAverage3 {  get { return Values[2]; } }

		[XmlIgnore]
		[Browsable(false)]
		public Series<double> MovingAverage4 {  get { return Values[3]; } }

		[XmlIgnore]
		[Browsable(false)]
		public Series<double> MovingAverage5 {  get { return Values[4]; } }

		[XmlIgnore]
		[Browsable(false)]
		public Series<double> MovingAverage6 {  get { return Values[5]; } }

		[XmlIgnore]
		[Browsable(false)]
		public Series<double> MovingAverage7 {  get { return Values[6]; } }

		[XmlIgnore]
		[Browsable(false)]
		public Series<double> MovingAverage8 {  get { return Values[7]; } }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "MovingAverage", GroupName = "NinjaScriptParameters", Order = 0)]
		public RibbonMAType MovingAverage { get; set; }
		
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "BasePeriod", GroupName = "NinjaScriptParameters", Order = 1)]
		public int BasePeriod { get; set; }
		
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "IncrementalPeriod", GroupName = "NinjaScriptParameters", Order = 2)]
		public int IncrementalPeriod { get; set; }
		#endregion

	}
}

public enum RibbonMAType
{
	Exponential = 0,
	Hull 		= 1,
	Simple 		= 2,
	Weighted 	= 3,
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MovingAverageRibbon[] cacheMovingAverageRibbon;
		public MovingAverageRibbon MovingAverageRibbon(RibbonMAType movingAverage, int basePeriod, int incrementalPeriod)
		{
			return MovingAverageRibbon(Input, movingAverage, basePeriod, incrementalPeriod);
		}

		public MovingAverageRibbon MovingAverageRibbon(ISeries<double> input, RibbonMAType movingAverage, int basePeriod, int incrementalPeriod)
		{
			if (cacheMovingAverageRibbon != null)
				for (int idx = 0; idx < cacheMovingAverageRibbon.Length; idx++)
					if (cacheMovingAverageRibbon[idx] != null && cacheMovingAverageRibbon[idx].MovingAverage == movingAverage && cacheMovingAverageRibbon[idx].BasePeriod == basePeriod && cacheMovingAverageRibbon[idx].IncrementalPeriod == incrementalPeriod && cacheMovingAverageRibbon[idx].EqualsInput(input))
						return cacheMovingAverageRibbon[idx];
			return CacheIndicator<MovingAverageRibbon>(new MovingAverageRibbon(){ MovingAverage = movingAverage, BasePeriod = basePeriod, IncrementalPeriod = incrementalPeriod }, input, ref cacheMovingAverageRibbon);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MovingAverageRibbon MovingAverageRibbon(RibbonMAType movingAverage, int basePeriod, int incrementalPeriod)
		{
			return indicator.MovingAverageRibbon(Input, movingAverage, basePeriod, incrementalPeriod);
		}

		public Indicators.MovingAverageRibbon MovingAverageRibbon(ISeries<double> input , RibbonMAType movingAverage, int basePeriod, int incrementalPeriod)
		{
			return indicator.MovingAverageRibbon(input, movingAverage, basePeriod, incrementalPeriod);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MovingAverageRibbon MovingAverageRibbon(RibbonMAType movingAverage, int basePeriod, int incrementalPeriod)
		{
			return indicator.MovingAverageRibbon(Input, movingAverage, basePeriod, incrementalPeriod);
		}

		public Indicators.MovingAverageRibbon MovingAverageRibbon(ISeries<double> input , RibbonMAType movingAverage, int basePeriod, int incrementalPeriod)
		{
			return indicator.MovingAverageRibbon(input, movingAverage, basePeriod, incrementalPeriod);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// This indicator returns 1 when we have n of consecutive bars down, otherwise returns 0.
	/// A down bar is defined as a bar where the close is below the open and the bars makes a
	/// lower high and a lower low. You can adjust the specific requirements with the indicator options.
	/// </summary>
	public class NBarsDown : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionNBarsDown;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameNBarsDown;
				BarCount					= 3;
				BarDown						= true;
				LowerHigh					= true;
				LowerLow					= true;
				IsSuspendedWhileInactive	= true;

				AddPlot(new Stroke(Brushes.Crimson, 2), PlotStyle.Bar, NinjaTrader.Custom.Resource.NBarsDownTrigger);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < BarCount)
			{
				Value[0] = 0;
			}
			else
			{
				bool gotBars = false;

				for (int i = 0; i < BarCount + 1; i++)
				{
					if (i == BarCount)
					{
						gotBars = true;
						break;
					}

					if (!(Close[i] < Close[i + 1]))
						break;

					if (BarDown && !(Close[i] < Open[i]))
						break;

					if (LowerHigh && !(High[i] < High[i + 1]))
						break;

					if (LowerLow && !(Low[i] < Low[i + 1]))
						break;
				}

				Value[0] = gotBars ? 1 : 0;
			}
		}

		#region Properties
		[Range(2, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "BarCount", GroupName = "NinjaScriptParameters", Order = 0)]
		public int BarCount
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "BarDown", GroupName = "NinjaScriptParameters", Order = 1)]
		public bool BarDown
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "LowerHigh", GroupName = "NinjaScriptParameters", Order = 2)]
		public bool LowerHigh
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "LowerLow", GroupName = "NinjaScriptParameters", Order = 3)]
		public bool LowerLow
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private NBarsDown[] cacheNBarsDown;
		public NBarsDown NBarsDown(int barCount, bool barDown, bool lowerHigh, bool lowerLow)
		{
			return NBarsDown(Input, barCount, barDown, lowerHigh, lowerLow);
		}

		public NBarsDown NBarsDown(ISeries<double> input, int barCount, bool barDown, bool lowerHigh, bool lowerLow)
		{
			if (cacheNBarsDown != null)
				for (int idx = 0; idx < cacheNBarsDown.Length; idx++)
					if (cacheNBarsDown[idx] != null && cacheNBarsDown[idx].BarCount == barCount && cacheNBarsDown[idx].BarDown == barDown && cacheNBarsDown[idx].LowerHigh == lowerHigh && cacheNBarsDown[idx].LowerLow == lowerLow && cacheNBarsDown[idx].EqualsInput(input))
						return cacheNBarsDown[idx];
			return CacheIndicator<NBarsDown>(new NBarsDown(){ BarCount = barCount, BarDown = barDown, LowerHigh = lowerHigh, LowerLow = lowerLow }, input, ref cacheNBarsDown);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.NBarsDown NBarsDown(int barCount, bool barDown, bool lowerHigh, bool lowerLow)
		{
			return indicator.NBarsDown(Input, barCount, barDown, lowerHigh, lowerLow);
		}

		public Indicators.NBarsDown NBarsDown(ISeries<double> input , int barCount, bool barDown, bool lowerHigh, bool lowerLow)
		{
			return indicator.NBarsDown(input, barCount, barDown, lowerHigh, lowerLow);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.NBarsDown NBarsDown(int barCount, bool barDown, bool lowerHigh, bool lowerLow)
		{
			return indicator.NBarsDown(Input, barCount, barDown, lowerHigh, lowerLow);
		}

		public Indicators.NBarsDown NBarsDown(ISeries<double> input , int barCount, bool barDown, bool lowerHigh, bool lowerLow)
		{
			return indicator.NBarsDown(input, barCount, barDown, lowerHigh, lowerLow);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// This indicator returns 1 when we have n of consecutive bars up, otherwise returns 0.
	/// An up bar is defined as a bar where the close is above the open and the bars makes a higher
	/// high and a higher low. You can adjust the specific requirements with the indicator options.
	/// </summary>
	public class NBarsUp : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionNBarsUp;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameNBarsUp;
				BarCount					= 3;
				BarUp						= true;
				HigherHigh					= true;
				HigherLow					= true;
				IsSuspendedWhileInactive	= true;

				AddPlot(new Stroke(Brushes.DarkCyan, 2), PlotStyle.Bar, NinjaTrader.Custom.Resource.NinjaScriptIndicatorDiff);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < BarCount)
			{
				Value[0] = 0;
			}
			else
			{
				bool gotBars = false;

				for (int i = 0; i < BarCount + 1; i++)
				{
					if (i == BarCount)
					{
						gotBars = true;
						break;
					}

					if (!(Close[i] > Close[i + 1]))
						break;

					if (BarUp && !(Close[i] > Open[i]))
						break;

					if (HigherHigh && !(High[i] > High[i + 1]))
						break;

					if (HigherLow && !(Low[i] > Low[i + 1]))
						break;
				}

				Value[0] = gotBars ? 1 : 0;
			}
		}


		#region Properties
		[Range(2, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "BarCount", GroupName = "NinjaScriptParameters", Order = 0)]
		public int BarCount
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "BarUp", GroupName = "NinjaScriptParameters", Order = 1)]
		public bool BarUp
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "HigherHigh", GroupName = "NinjaScriptParameters", Order = 2)]
		public bool HigherHigh
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "HigherLow", GroupName = "NinjaScriptParameters", Order = 3)]
		public bool HigherLow
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private NBarsUp[] cacheNBarsUp;
		public NBarsUp NBarsUp(int barCount, bool barUp, bool higherHigh, bool higherLow)
		{
			return NBarsUp(Input, barCount, barUp, higherHigh, higherLow);
		}

		public NBarsUp NBarsUp(ISeries<double> input, int barCount, bool barUp, bool higherHigh, bool higherLow)
		{
			if (cacheNBarsUp != null)
				for (int idx = 0; idx < cacheNBarsUp.Length; idx++)
					if (cacheNBarsUp[idx] != null && cacheNBarsUp[idx].BarCount == barCount && cacheNBarsUp[idx].BarUp == barUp && cacheNBarsUp[idx].HigherHigh == higherHigh && cacheNBarsUp[idx].HigherLow == higherLow && cacheNBarsUp[idx].EqualsInput(input))
						return cacheNBarsUp[idx];
			return CacheIndicator<NBarsUp>(new NBarsUp(){ BarCount = barCount, BarUp = barUp, HigherHigh = higherHigh, HigherLow = higherLow }, input, ref cacheNBarsUp);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.NBarsUp NBarsUp(int barCount, bool barUp, bool higherHigh, bool higherLow)
		{
			return indicator.NBarsUp(Input, barCount, barUp, higherHigh, higherLow);
		}

		public Indicators.NBarsUp NBarsUp(ISeries<double> input , int barCount, bool barUp, bool higherHigh, bool higherLow)
		{
			return indicator.NBarsUp(input, barCount, barUp, higherHigh, higherLow);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.NBarsUp NBarsUp(int barCount, bool barUp, bool higherHigh, bool higherLow)
		{
			return indicator.NBarsUp(Input, barCount, barUp, higherHigh, higherLow);
		}

		public Indicators.NBarsUp NBarsUp(ISeries<double> input , int barCount, bool barUp, bool higherHigh, bool higherLow)
		{
			return indicator.NBarsUp(input, barCount, barUp, higherHigh, higherLow);
		}
	}
}

#endregion


#########################

﻿//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Displays net change on the chart.
	/// </summary>
	public class NetChangeDisplay : Indicator
	{
		private Cbi.Account 	account;
		private Cbi.Instrument 	instrument;
		private double 			currentValue;
		private double 			lastValue;
		
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionNetChangeDisplay;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameNetChangeDisplay;
				Calculate					= Calculate.OnPriceChange;
				IsOverlay					= true;
				DrawOnPricePanel			= true;
				IsSuspendedWhileInactive	= true;
				Unit 						= Cbi.PerformanceUnit.Percent;
				PositiveBrush 				= Brushes.LimeGreen;
				NegativeBrush 				= Brushes.Red;
				Location 					= NetChangePosition.TopRight;
				Font 						= new SimpleFont("Arial", 18);
			}
			else if (State == State.Configure)
			{
				instrument = Instruments[0];
			}
		}

		private TextPosition GetTextPosition(NetChangePosition ncp)
		{
			switch(ncp)
			{
				case NetChangePosition.BottomLeft:
					return TextPosition.BottomLeft;
				case NetChangePosition.BottomRight:
					return TextPosition.BottomRight;
				case NetChangePosition.TopLeft:
					return TextPosition.TopLeft;
				case NetChangePosition.TopRight:
					return TextPosition.TopRight;
			}

			return TextPosition.TopRight;
		}

		protected override void OnBarUpdate() { }
		
		protected override void OnConnectionStatusUpdate(Cbi.ConnectionStatusEventArgs connectionStatusUpdate)
		{
			if (connectionStatusUpdate.PriceStatus == Cbi.ConnectionStatus.Connected && connectionStatusUpdate.PreviousStatus == Cbi.ConnectionStatus.Connecting
					&& connectionStatusUpdate.Connection.Accounts.Count > 0
					&& account == null)
				account = connectionStatusUpdate.Connection.Accounts[0];
			else if (connectionStatusUpdate.Status == Cbi.ConnectionStatus.Disconnected && connectionStatusUpdate.PreviousStatus == Cbi.ConnectionStatus.Disconnecting
					&& account != null && account.Connection == connectionStatusUpdate.Connection)
				account = null;
		}

		protected override void OnMarketData(Data.MarketDataEventArgs marketDataUpdate)
		{
			if (marketDataUpdate.IsReset)
			{
				currentValue = double.MinValue;
				
				if (lastValue != currentValue)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", FormatValue(currentValue), GetTextPosition(Location), currentValue >= 0 ? PositiveBrush : NegativeBrush, Font, Brushes.Transparent, Brushes.Transparent, 0);
					lastValue = currentValue;
				}
				return;
			}

			if (marketDataUpdate.MarketDataType != Data.MarketDataType.Last || marketDataUpdate.Instrument.MarketData.LastClose == null)
				return;

			bool 	tryAgainLater 	= false;
			double 	rate 			= 0;
			
			if (account != null)
				rate = marketDataUpdate.Instrument.GetConversionRate(Data.MarketDataType.Bid, account.Denomination, out tryAgainLater);

			switch (Unit)
			{
				case Cbi.PerformanceUnit.Percent:
					currentValue = (marketDataUpdate.Price - marketDataUpdate.Instrument.MarketData.LastClose.Price) / marketDataUpdate.Instrument.MarketData.LastClose.Price;
					break;
				case Cbi.PerformanceUnit.Pips:
					currentValue = ((marketDataUpdate.Price - marketDataUpdate.Instrument.MarketData.LastClose.Price) / Instrument.MasterInstrument.TickSize) * (Instrument.MasterInstrument.InstrumentType == Cbi.InstrumentType.Forex ? 0.1 : 1);
					break;
				case Cbi.PerformanceUnit.Ticks:
					currentValue = (marketDataUpdate.Price - marketDataUpdate.Instrument.MarketData.LastClose.Price) / Instrument.MasterInstrument.TickSize;
					break;
				case Cbi.PerformanceUnit.Currency:
					currentValue = (marketDataUpdate.Price - marketDataUpdate.Instrument.MarketData.LastClose.Price) * Instrument.MasterInstrument.PointValue * rate * (Instrument.MasterInstrument.InstrumentType == Cbi.InstrumentType.Forex ? (account != null ? account.ForexLotSize : Cbi.Account.DefaultLotSize) : 1);
					break;
				case Cbi.PerformanceUnit.Points:
					currentValue = (marketDataUpdate.Price - marketDataUpdate.Instrument.MarketData.LastClose.Price);
					break;
			}
			
			if (lastValue != currentValue)
			{
				Draw.TextFixed(this, "NinjaScriptInfo", FormatValue(currentValue), GetTextPosition(Location), currentValue >= 0 ? PositiveBrush : NegativeBrush, Font, Brushes.Transparent, Brushes.Transparent, 0);
				lastValue = currentValue;
			}
		}
		
		public string FormatValue(double value)
		{
			if (value == double.MinValue)
				return string.Empty;

			switch (Unit)
			{
				case Cbi.PerformanceUnit.Currency:
					{
                        Cbi.Currency formatCurrency;
                        if (account != null)
                            formatCurrency = account.Denomination;
                        else
                            formatCurrency = Instrument.MasterInstrument.Currency;
                        return Core.Globals.FormatCurrency(value, formatCurrency);
                    }
				case Cbi.PerformanceUnit.Points: return value.ToString(Core.Globals.GetTickFormatString(Instrument.MasterInstrument.TickSize), Core.Globals.GeneralOptions.CurrentCulture);
				case Cbi.PerformanceUnit.Percent: return (value).ToString("P", Core.Globals.GeneralOptions.CurrentCulture);
				case Cbi.PerformanceUnit.Pips:
					{
						System.Globalization.CultureInfo forexCulture = Core.Globals.GeneralOptions.CurrentCulture.Clone() as System.Globalization.CultureInfo;
						if (forexCulture != null)
							forexCulture.NumberFormat.NumberDecimalSeparator = "'";
						return (Math.Round(value * 10) / 10.0).ToString("0.0", forexCulture);
					}
				case Cbi.PerformanceUnit.Ticks: return Math.Round(value).ToString(Core.Globals.GeneralOptions.CurrentCulture);
				default: return "0";
			}
		}
		
		#region Properties
		[XmlIgnore]
		[Browsable(false)]
		public double NetChange {  get { return currentValue; } }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Unit", GroupName = "NinjaScriptParameters", Order = 0)]
		public Cbi.PerformanceUnit Unit { get; set; }
		
		[XmlIgnore]
		[Display(ResourceType = typeof(Custom.Resource), Name = "PositiveColor", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 1810)]
		public Brush PositiveBrush { get; set; }
		
		[Browsable(false)]
		public string PositiveBrushSerialize
		{
			get { return Serialize.BrushToString(PositiveBrush); }
		   	set { PositiveBrush = Serialize.StringToBrush(value); }
		}
		
		[XmlIgnore]
		[Display(ResourceType = typeof(Custom.Resource), Name = "NegativeColor", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 1820)]
		public Brush NegativeBrush { get; set; }
		
		[Browsable(false)]
		public string NegativeBrushSerialize
		{
			get { return Serialize.BrushToString(NegativeBrush); }
		   	set { NegativeBrush = Serialize.StringToBrush(value); }
		}
		
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Location", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 1830)]
		public NetChangePosition Location { get; set; }
		
		[Display(ResourceType = typeof(Custom.Resource), Name = "Font", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 1800)]
		public SimpleFont Font { get; set; }
		#endregion
	}
}

[TypeConverter("NinjaTrader.Custom.ResourceEnumConverter")]
public enum NetChangePosition
{
	BottomLeft,
	BottomRight,
	TopLeft,
	TopRight,
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private NetChangeDisplay[] cacheNetChangeDisplay;
		public NetChangeDisplay NetChangeDisplay(Cbi.PerformanceUnit unit, NetChangePosition location)
		{
			return NetChangeDisplay(Input, unit, location);
		}

		public NetChangeDisplay NetChangeDisplay(ISeries<double> input, Cbi.PerformanceUnit unit, NetChangePosition location)
		{
			if (cacheNetChangeDisplay != null)
				for (int idx = 0; idx < cacheNetChangeDisplay.Length; idx++)
					if (cacheNetChangeDisplay[idx] != null && cacheNetChangeDisplay[idx].Unit == unit && cacheNetChangeDisplay[idx].Location == location && cacheNetChangeDisplay[idx].EqualsInput(input))
						return cacheNetChangeDisplay[idx];
			return CacheIndicator<NetChangeDisplay>(new NetChangeDisplay(){ Unit = unit, Location = location }, input, ref cacheNetChangeDisplay);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.NetChangeDisplay NetChangeDisplay(Cbi.PerformanceUnit unit, NetChangePosition location)
		{
			return indicator.NetChangeDisplay(Input, unit, location);
		}

		public Indicators.NetChangeDisplay NetChangeDisplay(ISeries<double> input , Cbi.PerformanceUnit unit, NetChangePosition location)
		{
			return indicator.NetChangeDisplay(input, unit, location);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.NetChangeDisplay NetChangeDisplay(Cbi.PerformanceUnit unit, NetChangePosition location)
		{
			return indicator.NetChangeDisplay(Input, unit, location);
		}

		public Indicators.NetChangeDisplay NetChangeDisplay(ISeries<double> input , Cbi.PerformanceUnit unit, NetChangePosition location)
		{
			return indicator.NetChangeDisplay(input, unit, location);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// OBV (On Balance Volume) is a running total of volume. It shows if volume is flowing into
	/// or out of a security. When the security closes higher than the previous close, all
	/// of the day's volume is considered up-volume. When the security closes lower than the
	/// previous close, all of the day's volume is considered down-volume.
	/// </summary>
	public class OBV : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionOBV;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameOBV;
				IsSuspendedWhileInactive	= true;
				DrawOnPricePanel			= false;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameOBV);
			}
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
				Value[0] = 0;
			else
			{
				double close0	= Close[0];
				double close1	= Close[1];
				double volume0	= Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0];

				if (close0 > close1)
					Value[0] = Value[1] + volume0;
				else if (close0  < close1)
					Value[0] = Value[1] - volume0;
				else
					Value[0] = Value[1];
			}
		}
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private OBV[] cacheOBV;
		public OBV OBV()
		{
			return OBV(Input);
		}

		public OBV OBV(ISeries<double> input)
		{
			if (cacheOBV != null)
				for (int idx = 0; idx < cacheOBV.Length; idx++)
					if (cacheOBV[idx] != null &&  cacheOBV[idx].EqualsInput(input))
						return cacheOBV[idx];
			return CacheIndicator<OBV>(new OBV(), input, ref cacheOBV);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.OBV OBV()
		{
			return indicator.OBV(Input);
		}

		public Indicators.OBV OBV(ISeries<double> input )
		{
			return indicator.OBV(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.OBV OBV()
		{
			return indicator.OBV(Input);
		}

		public Indicators.OBV OBV(ISeries<double> input )
		{
			return indicator.OBV(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Parabolic SAR according to Stocks and Commodities magazine V 11:11 (477-479).
	/// </summary>
	public class ParabolicSAR : Indicator
	{
		private double			af;				// Acceleration factor
		private bool			afIncreased;
		private bool			longPosition;
		private int				prevBar;
		private double			prevSAR;
		private int				reverseBar;
		private double			reverseValue;
		private double			todaySAR;		// SAR value
		private double			xp;				// Extreme Price

		private Series<double>	afSeries;
		private Series<bool>	afIncreasedSeries;
		private Series<bool>	longPositionSeries;
		private Series<int>		prevBarSeries;
		private Series<double>	prevSARSeries;
		private Series<int>		reverseBarSeries;
		private Series<double>	reverseValueSeries;
		private Series<double>	todaySARSeries;
		private Series<double>	xpSeries;

		private ISeries<double>	high;
		private ISeries<double>	low;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= Custom.Resource.NinjaScriptIndicatorDescriptionParabolicSAR;
				Name						= Custom.Resource.NinjaScriptIndicatorNameParabolicSAR;
				Acceleration				= 0.02;
				AccelerationStep			= 0.02;
				AccelerationMax				= 0.2;
				Calculate 					= Calculate.OnPriceChange;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;

				AddPlot(new Stroke(Brushes.Goldenrod, 2), PlotStyle.Dot, Custom.Resource.NinjaScriptIndicatorNameParabolicSAR);
			}

			else if (State == State.Configure)
			{
				xp				= 0.0;
				af				= 0;
				todaySAR		= 0;
				prevSAR			= 0;
				reverseBar		= 0;
				reverseValue	= 0;
				prevBar			= 0;
				afIncreased		= false;
			}
			else if (State == State.DataLoaded)
			{
				if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
				{
					afSeries			= new Series<double>(this);
					afIncreasedSeries	= new Series<bool>(this);
					longPositionSeries	= new Series<bool>(this);
					prevBarSeries		= new Series<int>(this);
					prevSARSeries		= new Series<double>(this);
					reverseBarSeries	= new Series<int>(this);
					reverseValueSeries	= new Series<double>(this);
					todaySARSeries		= new Series<double>(this);
					xpSeries			= new Series<double>(this);
				}

				high	= Input is NinjaScriptBase ? Input : High;
				low		= Input is NinjaScriptBase ? Input : Low;
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < 3)
				return;

			if (CurrentBar == 3)
			{
				// Determine initial position
				longPosition	= high[0] > high[1];
				xp				= longPosition ? MAX(high, CurrentBar)[0] : MIN(low, CurrentBar)[0];
				af				= Acceleration;
				Value[0]		= xp + (longPosition ? -1 : 1) * ((MAX(high, CurrentBar)[0] - MIN(low, CurrentBar)[0]) * af);
				return;
			}
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported && CurrentBar < prevBar)
			{
				af				= afSeries[0];
				afIncreased		= afIncreasedSeries[0];
				longPosition	= longPositionSeries[0];
				prevBar			= prevBarSeries[0];
				prevSAR			= prevSARSeries[0];
				reverseBar		= reverseBarSeries[0];
				reverseValue	= reverseValueSeries[0];
				todaySAR		= todaySARSeries[0];
				xp				= xpSeries[0];
			}

			// Reset accelerator increase limiter on new bars
			if (afIncreased && prevBar != CurrentBar)
				afIncreased = false;

			// Current event is on a bar not marked as a reversal bar yet
			if (reverseBar != CurrentBar)
			{
				// SAR = SAR[1] + af * (xp - SAR[1])
				todaySAR = TodaySAR(Value[1] + af * (xp - Value[1]));
				for (int x = 1; x <= 2; x++)
				{
					if (longPosition)
					{
						if (todaySAR > low[x])
							todaySAR = low[x];
					}
					else
					{
						if (todaySAR < high[x])
							todaySAR = high[x];
					}
				}

				// Holding long position
				if (longPosition)
				{
					// Process a new SAR value only on a new bar or if SAR value was penetrated.
					if (prevBar != CurrentBar || low[0] < prevSAR)
					{
						Value[0] = todaySAR;
						prevSAR = todaySAR;
					}
					else
						Value[0] = prevSAR;

					if (high[0] > xp)
					{
						xp = high[0];
						AfIncrease();
					}
				}

				// Holding short position
				else if (!longPosition)
				{
					// Process a new SAR value only on a new bar or if SAR value was penetrated.
					if (prevBar != CurrentBar || high[0] > prevSAR)
					{
						Value[0] = todaySAR;
						prevSAR = todaySAR;
					}
					else
						Value[0] = prevSAR;

					if (low[0] < xp)
					{
						xp = low[0];
						AfIncrease();
					}
				}
			}

			// Current event is on the same bar as the reversal bar
			else
			{
				// Only set new xp values. No increasing af since this is the first bar.
				if (longPosition && high[0] > xp)
					xp = high[0];
				else if (!longPosition && low[0] < xp)
					xp = low[0];

				Value[0] = prevSAR;

				// SAR = SAR[1] + af * (xp - SAR[1])
				todaySAR = TodaySAR(longPosition ? Math.Min(reverseValue, low[0]) : Math.Max(reverseValue, high[0]));
			}

			prevBar = CurrentBar;

			// Reverse position
			if ((longPosition && (low[0] < todaySAR || low[1] < todaySAR))
				|| (!longPosition && (high[0] > todaySAR || high[1] > todaySAR)))
				Value[0] = Reverse();

			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				afSeries[0]				= af;
				afIncreasedSeries[0]	= afIncreased;
				longPositionSeries[0]	= longPosition;
				prevBarSeries[0]		= prevBar;
				prevSARSeries[0]		= prevSAR;
				reverseBarSeries[0]		= reverseBar;
				reverseValueSeries[0]	= reverseValue;
				todaySARSeries[0]		= todaySAR;
				xpSeries[0]				= xp;
			}
		}

		#region Miscellaneous
		// Only raise accelerator if not raised for current bar yet
		private void AfIncrease()
		{
			if (!afIncreased)
			{
				af			= Math.Min(AccelerationMax, af + AccelerationStep);
				afIncreased	= true;
			}
		}

		// Additional rule. SAR for today can't be placed inside the bar of day - 1 or day - 2.
		private double TodaySAR(double tSAR)
		{
			if (longPosition)
			{
				double lowestSAR = Math.Min(Math.Min(tSAR, low[0]), low[1]);
				if (low[0] > lowestSAR)
					tSAR = lowestSAR;
			}
			else
			{
				double highestSAR = Math.Max(Math.Max(tSAR, high[0]), high[1]);
				if (high[0] < highestSAR)
					tSAR = highestSAR;
			}
			return tSAR;
		}

		private double Reverse()
		{
			double tSAR = xp;

			if ((longPosition && prevSAR > low[0]) || (!longPosition && prevSAR < high[0]) || prevBar != CurrentBar)
			{
				longPosition	= !longPosition;
				reverseBar		= CurrentBar;
				reverseValue	= xp;
				af				= Acceleration;
				xp				= longPosition ? high[0] : low[0];
				prevSAR			= tSAR;
			}
			else
				tSAR = prevSAR;
			return tSAR;
		}
		#endregion

		#region Properties
		[Range(0.00, double.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Acceleration", GroupName = "NinjaScriptParameters", Order = 0)]
		public double Acceleration
		{ get; set; }

		[Range(0.001, double.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "AccelerationMax", GroupName = "NinjaScriptParameters", Order = 1)]
		public double AccelerationMax
		{ get; set; }

		[Range(0.001, double.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "AccelerationStep", GroupName = "NinjaScriptParameters", Order = 2)]
		public double AccelerationStep
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ParabolicSAR[] cacheParabolicSAR;
		public ParabolicSAR ParabolicSAR(double acceleration, double accelerationMax, double accelerationStep)
		{
			return ParabolicSAR(Input, acceleration, accelerationMax, accelerationStep);
		}

		public ParabolicSAR ParabolicSAR(ISeries<double> input, double acceleration, double accelerationMax, double accelerationStep)
		{
			if (cacheParabolicSAR != null)
				for (int idx = 0; idx < cacheParabolicSAR.Length; idx++)
					if (cacheParabolicSAR[idx] != null && cacheParabolicSAR[idx].Acceleration == acceleration && cacheParabolicSAR[idx].AccelerationMax == accelerationMax && cacheParabolicSAR[idx].AccelerationStep == accelerationStep && cacheParabolicSAR[idx].EqualsInput(input))
						return cacheParabolicSAR[idx];
			return CacheIndicator<ParabolicSAR>(new ParabolicSAR(){ Acceleration = acceleration, AccelerationMax = accelerationMax, AccelerationStep = accelerationStep }, input, ref cacheParabolicSAR);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ParabolicSAR ParabolicSAR(double acceleration, double accelerationMax, double accelerationStep)
		{
			return indicator.ParabolicSAR(Input, acceleration, accelerationMax, accelerationStep);
		}

		public Indicators.ParabolicSAR ParabolicSAR(ISeries<double> input , double acceleration, double accelerationMax, double accelerationStep)
		{
			return indicator.ParabolicSAR(input, acceleration, accelerationMax, accelerationStep);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ParabolicSAR ParabolicSAR(double acceleration, double accelerationMax, double accelerationStep)
		{
			return indicator.ParabolicSAR(Input, acceleration, accelerationMax, accelerationStep);
		}

		public Indicators.ParabolicSAR ParabolicSAR(ISeries<double> input , double acceleration, double accelerationMax, double accelerationStep)
		{
			return indicator.ParabolicSAR(input, acceleration, accelerationMax, accelerationStep);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The PFE (Polarized Fractal Efficiency) is an indicator that uses fractal
	///  geometry to determine how efficiently the price is moving.
	/// </summary>
	public class PFE : Indicator
	{
		private Series<double>	div;
		private EMA				ema;
		private Series<double>	pfeSeries;
		private Series<double>	singlePfeSeries;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionPFE;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNamePFE;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				Smooth						= 10;

				AddPlot(Brushes.DodgerBlue,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNamePFE);
				AddLine(Brushes.DarkGray,	0,	NinjaTrader.Custom.Resource.PFEZero);
			}

			else if (State == State.DataLoaded)
			{
				div				= new Series<double>(this);
				pfeSeries		= new Series<double>(this);
				singlePfeSeries	= new Series<double>(this);
				ema				= EMA(pfeSeries, Smooth);
			}
		}

		protected override void OnBarUpdate()
		{
			double input0 = Input[0];

			if (CurrentBar < Period)
			{
				singlePfeSeries[0]	= CurrentBar == 0 ? 1 : Math.Sqrt(Math.Pow((Input[1] - input0), 2) + 1);
				div[0]				= singlePfeSeries[0] + (CurrentBar > 0 ? div[1] : 0);
				return;
			}

			double input1		= Input[1];
			double inputPeriod	= Input[Period];

			singlePfeSeries[0]	= Math.Sqrt(Math.Pow((input1 - input0), 2) + 1);
			div[0]				= singlePfeSeries[0] + div[1] - singlePfeSeries[Period];
			pfeSeries[0] 		= (input0 < inputPeriod ? -1 : 1) * (Math.Sqrt(Math.Pow(input0 - inputPeriod, 2) + Math.Pow(Period, 2)) / div[0]);
			Value[0]			= ema[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private PFE[] cachePFE;
		public PFE PFE(int period, int smooth)
		{
			return PFE(Input, period, smooth);
		}

		public PFE PFE(ISeries<double> input, int period, int smooth)
		{
			if (cachePFE != null)
				for (int idx = 0; idx < cachePFE.Length; idx++)
					if (cachePFE[idx] != null && cachePFE[idx].Period == period && cachePFE[idx].Smooth == smooth && cachePFE[idx].EqualsInput(input))
						return cachePFE[idx];
			return CacheIndicator<PFE>(new PFE(){ Period = period, Smooth = smooth }, input, ref cachePFE);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.PFE PFE(int period, int smooth)
		{
			return indicator.PFE(Input, period, smooth);
		}

		public Indicators.PFE PFE(ISeries<double> input , int period, int smooth)
		{
			return indicator.PFE(input, period, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.PFE PFE(int period, int smooth)
		{
			return indicator.PFE(Input, period, smooth);
		}

		public Indicators.PFE PFE(ISeries<double> input , int period, int smooth)
		{
			return indicator.PFE(input, period, smooth);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Core;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX.DirectWrite;

#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	[TypeConverter("NinjaTrader.NinjaScript.Indicators.PivotsTypeConverter")]
	public class Pivots : Indicator
	{
		private DateTime				cacheMonthlyEndDate		= Globals.MinDate;
		private DateTime				cacheSessionDate		= Globals.MinDate;
		private DateTime				cacheSessionEnd			= Globals.MinDate;
		private DateTime				cacheTime;
		private DateTime				cacheWeeklyEndDate		= Globals.MinDate;
		private DateTime				currentDate				= Globals.MinDate;
		private DateTime				currentMonth			= Globals.MinDate;
		private DateTime				currentWeek				= Globals.MinDate;
		private DateTime				sessionDateTmp			= Globals.MinDate;
		private HLCCalculationMode		priorDayHlc;
		private PivotRange				pivotRangeType;
		private SessionIterator			storedSession;
		private double					currentClose;
		private double					currentHigh				= double.MinValue;
		private double					currentLow				= double.MaxValue;
		private double					dailyBarClose			= double.MinValue;
		private double					dailyBarHigh			= double.MinValue;
		private double					dailyBarLow				= double.MinValue;
		private double					pp;
		private double					r1;
		private double					r2;
		private double					r3;
		private double					s1;
		private double					s2;
		private double					s3;
		private double					userDefinedClose;
		private double					userDefinedHigh;
		private double					userDefinedLow;
		private int						cacheBar;
		private int						width					= 20;
		private readonly List<int>		newSessionBarIdxArr		= new List<int>();

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description				= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionPivots;
				Name					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNamePivots;
				Calculate				= Calculate.OnBarClose;
				DisplayInDataBox		= true;
				DrawOnPricePanel		= false;
				IsAutoScale				= false;
				IsOverlay				= true;
				PaintPriceMarkers		= true;
				ScaleJustification		= ScaleJustification.Right;

				AddPlot(Brushes.Goldenrod,	NinjaTrader.Custom.Resource.PivotsPP);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.PivotsR1);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.PivotsR2);
				AddPlot(Brushes.DodgerBlue,	NinjaTrader.Custom.Resource.PivotsR3);
				AddPlot(Brushes.Crimson,	NinjaTrader.Custom.Resource.PivotsS1);
				AddPlot(Brushes.Crimson,	NinjaTrader.Custom.Resource.PivotsS2);
				AddPlot(Brushes.Crimson,	NinjaTrader.Custom.Resource.PivotsS3);
			}
			else if (State == State.Configure)
			{
				if (priorDayHlc == HLCCalculationMode.DailyBars)
					AddDataSeries(BarsPeriodType.Day, 1);
			}
			else if (State == State.DataLoaded)
			{
				storedSession = new SessionIterator(Bars);
			}
			else if (State == State.Historical)
			{

				if (BarsArray == null || BarsArray.Length < 2)
				return;

				if (priorDayHlc == HLCCalculationMode.DailyBars && BarsArray[1].DayCount <= 0)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsDailyDataError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsDailyDataError, LogLevel.Error);
					return;
				}

				if (!Bars.BarsType.IsIntraday && BarsPeriod.BarsPeriodType != BarsPeriodType.Day && (BarsPeriod.BarsPeriodType != BarsPeriodType.HeikenAshi && BarsPeriod.BarsPeriodType != BarsPeriodType.Volumetric || BarsPeriod.BaseBarsPeriodType != BarsPeriodType.Day))
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsDailyBarsError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsDailyBarsError, LogLevel.Error);
				}
				if ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && pivotRangeType == PivotRange.Daily)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsWeeklyBarsError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsWeeklyBarsError, LogLevel.Error);
				}
				if ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && BarsPeriod.Value > 1)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsPeriodTypeError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsPeriodTypeError, LogLevel.Error);
				}
				if ((priorDayHlc == HLCCalculationMode.DailyBars &&
					(pivotRangeType == PivotRange.Monthly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddMonths(-1)
					|| pivotRangeType == PivotRange.Weekly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-7)
					|| pivotRangeType == PivotRange.Daily && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-1)))
					|| pivotRangeType == PivotRange.Monthly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddMonths(-1)
					|| pivotRangeType == PivotRange.Weekly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-7)
					|| pivotRangeType == PivotRange.Daily && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-1)
					)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PiviotsInsufficentDataError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PiviotsInsufficentDataError, LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsInProgress != 0)
				return;

			if ((priorDayHlc == HLCCalculationMode.DailyBars && BarsArray[1].DayCount <= 0)
				|| (!Bars.BarsType.IsIntraday && BarsPeriod.BarsPeriodType != BarsPeriodType.Day && (BarsPeriod.BarsPeriodType != BarsPeriodType.HeikenAshi && BarsPeriod.BarsPeriodType != BarsPeriodType.Volumetric || BarsPeriod.BaseBarsPeriodType != BarsPeriodType.Day))
				|| ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && pivotRangeType == PivotRange.Daily)
				|| ((BarsPeriod.BarsPeriodType == BarsPeriodType.Day || ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Day)) && BarsPeriod.Value > 1)
				|| ((priorDayHlc == HLCCalculationMode.DailyBars && (pivotRangeType == PivotRange.Monthly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddMonths(-1)
				|| pivotRangeType == PivotRange.Weekly && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-7)
				|| pivotRangeType == PivotRange.Daily && BarsArray[1].GetTime(0).Date >= BarsArray[1].GetTime(BarsArray[1].Count - 1).Date.AddDays(-1)))
				|| pivotRangeType == PivotRange.Monthly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddMonths(-1)
				|| pivotRangeType == PivotRange.Weekly && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-7)
				|| pivotRangeType == PivotRange.Daily && BarsArray[0].GetTime(0).Date >= BarsArray[0].GetTime(BarsArray[0].Count - 1).Date.AddDays(-1)))
				return;

			RemoveDrawObject("NinjaScriptInfo");

			if (PriorDayHlc == HLCCalculationMode.DailyBars && CurrentBars[1] >= 0)
			{
				// Get daily bars like this to avoid situation where primary series moves to next session before previous day OHLC are added
				if (cacheTime != Times[0][0])
				{
					cacheTime	= Times[0][0];
					cacheBar	= BarsArray[1].GetBar(Times[0][0]);
				}
				dailyBarHigh	= BarsArray[1].GetHigh(cacheBar);
				dailyBarLow		= BarsArray[1].GetLow(cacheBar);
				dailyBarClose	= BarsArray[1].GetClose(cacheBar);
			}
			else
			{
				dailyBarHigh	= double.MinValue;
				dailyBarLow		= double.MinValue;
				dailyBarClose	= double.MinValue;
			}

			double high		= (dailyBarHigh == double.MinValue)		? Highs[0][0]	: dailyBarHigh;
			double low		= (dailyBarLow == double.MinValue)		? Lows[0][0]	: dailyBarLow;
			double close	= (dailyBarClose == double.MinValue)	? Closes[0][0]	: dailyBarClose;

			DateTime lastBarTimeStamp = GetLastBarSessionDate(Times[0][0], pivotRangeType);

			if ((currentDate != Globals.MinDate && pivotRangeType == PivotRange.Daily && lastBarTimeStamp != currentDate)
				|| (currentWeek != Globals.MinDate && pivotRangeType == PivotRange.Weekly && lastBarTimeStamp != currentWeek)
				|| (currentMonth != Globals.MinDate && pivotRangeType == PivotRange.Monthly && lastBarTimeStamp != currentMonth))
			{
				pp				= (currentHigh + currentLow + currentClose) / 3;
				s1				= 2 * pp - currentHigh;
				r1				= 2 * pp - currentLow;
				s2				= pp - (currentHigh - currentLow);
				r2				= pp + (currentHigh - currentLow);
				s3				= pp - 2 * (currentHigh - currentLow);
				r3				= pp + 2 * (currentHigh - currentLow);
				currentClose	= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedClose	: close;
				currentHigh		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedHigh	: high;
				currentLow		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedLow	: low;
			}
			else
			{
				currentClose	= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedClose	: close;
				currentHigh		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedHigh	: Math.Max(currentHigh, high);
				currentLow		= (priorDayHlc == HLCCalculationMode.UserDefinedValues) ? UserDefinedLow	: Math.Min(currentLow, low);
			}


			if (pivotRangeType == PivotRange.Daily)
				currentDate = lastBarTimeStamp;
			if (pivotRangeType == PivotRange.Weekly)
				currentWeek = lastBarTimeStamp;
			if (pivotRangeType == PivotRange.Monthly)
				currentMonth = lastBarTimeStamp;

			if ((pivotRangeType == PivotRange.Daily && currentDate != Globals.MinDate)
				|| (pivotRangeType == PivotRange.Weekly && currentWeek != Globals.MinDate)
				|| (pivotRangeType == PivotRange.Monthly && currentMonth != Globals.MinDate))
			{
				Pp[0] = pp;
				R1[0] = r1;
				R2[0] = r2;
				R3[0] = r3;
				S1[0] = s1;
				S2[0] = s2;
				S3[0] = s3;
			}
		}

		#region Misc
		private DateTime GetLastBarSessionDate(DateTime time, PivotRange pivotRange)
		{
			// Check the time[0] against the previous session end
			if (time > cacheSessionEnd)
			{
				if (Bars.BarsType.IsIntraday)
				{
					// Make use of the stored session iterator to find the next session...
					storedSession.GetNextSession(time, true);
					// Store the actual session's end datetime as the session
					cacheSessionEnd = storedSession.ActualSessionEnd;
					// We need to convert that time from the session to the users time zone settings
					sessionDateTmp = TimeZoneInfo.ConvertTime(cacheSessionEnd.AddSeconds(-1), Globals.GeneralOptions.TimeZoneInfo, Bars.TradingHours.TimeZoneInfo).Date;
				}
				else
					sessionDateTmp = time.Date;
			}

			if (pivotRange == PivotRange.Daily)
			{
				if (sessionDateTmp != cacheSessionDate)
				{
					if (newSessionBarIdxArr.Count == 0 || newSessionBarIdxArr.Count > 0 && CurrentBar > newSessionBarIdxArr[newSessionBarIdxArr.Count - 1])
						newSessionBarIdxArr.Add(CurrentBar);
					cacheSessionDate = sessionDateTmp;
				}
				return sessionDateTmp;
			}

			DateTime tmpWeeklyEndDate = RoundUpTimeToPeriodTime(sessionDateTmp, PivotRange.Weekly);
			if (pivotRange == PivotRange.Weekly)
			{
				if (tmpWeeklyEndDate != cacheWeeklyEndDate)
				{
					if (newSessionBarIdxArr.Count == 0 || newSessionBarIdxArr.Count > 0 && CurrentBar > newSessionBarIdxArr[newSessionBarIdxArr.Count - 1])
						newSessionBarIdxArr.Add(CurrentBar);
					cacheWeeklyEndDate = tmpWeeklyEndDate;
				}
				return tmpWeeklyEndDate;
			}

			DateTime tmpMonthlyEndDate = RoundUpTimeToPeriodTime(sessionDateTmp, PivotRange.Monthly);
			if (tmpMonthlyEndDate != cacheMonthlyEndDate)
			{
				if (newSessionBarIdxArr.Count == 0 || newSessionBarIdxArr.Count > 0 && CurrentBar > newSessionBarIdxArr[newSessionBarIdxArr.Count - 1])
					newSessionBarIdxArr.Add(CurrentBar);
				cacheMonthlyEndDate = tmpMonthlyEndDate;
			}
			return tmpMonthlyEndDate;
		}

		private DateTime RoundUpTimeToPeriodTime(DateTime time, PivotRange pivotRange)
		{
			if (pivotRange == PivotRange.Weekly)
				return Gui.Tools.Extensions.GetEndOfWeekTime(time);
			if (pivotRange == PivotRange.Monthly)
				return Gui.Tools.Extensions.GetEndOfMonthTime(time);
			return time;
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
		{
			// Set text to chart label color and font
			TextFormat	textFormat			= chartControl.Properties.LabelFont.ToDirectWriteTextFormat();

			// Loop through each Plot Values on the chart
			for (int seriesCount = 0; seriesCount < Values.Length; seriesCount++)
			{
				double	y					= -1;
				double	startX				= -1;
				double	endX				= -1;
				int		firstBarIdxToPaint	= -1;
				int		firstBarPainted		= ChartBars.FromIndex;
				int		lastBarPainted		= ChartBars.ToIndex;
				Plot	plot				= Plots[seriesCount];

				for (int i = newSessionBarIdxArr.Count - 1; i >= 0; i--)
				{
					int prevSessionBreakIdx = newSessionBarIdxArr[i];
					if (prevSessionBreakIdx <= lastBarPainted)
					{
						firstBarIdxToPaint = prevSessionBreakIdx;
						break;
					}
				}

				// Loop through visble bars to render plot values
				for (int idx = lastBarPainted; idx >= Math.Max(firstBarPainted, lastBarPainted - width); idx--)
				{
					if (idx < firstBarIdxToPaint)
						break;

					startX		= chartControl.GetXByBarIndex(ChartBars, idx);
					endX		= chartControl.GetXByBarIndex(ChartBars, lastBarPainted);
					double val	= Values[seriesCount].GetValueAt(idx);
					y			= chartScale.GetYByValue(val);
				}

				// Draw pivot lines
				Point startPoint	= new Point(startX, y);
				Point endPoint		= new Point(endX, y);
				RenderTarget.DrawLine(startPoint.ToVector2(), endPoint.ToVector2(), plot.BrushDX, plot.Width, plot.StrokeStyle);

				// Draw pivot text
				TextLayout textLayout = new TextLayout(Globals.DirectWriteFactory, plot.Name, textFormat, ChartPanel.W, textFormat.FontSize);
				RenderTarget.DrawTextLayout(startPoint.ToVector2(), textLayout, plot.BrushDX);
				textLayout.Dispose();
			}
			textFormat.Dispose();
		}
		#endregion

		#region Properties

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "PivotRange", GroupName = "NinjaScriptParameters", Order = 0)]
		public PivotRange PivotRangeType
		{
			get { return pivotRangeType; }
			set { pivotRangeType = value; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Pp
		{
			get { return Values[0]; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "HLCCalculationMode", GroupName = "NinjaScriptParameters", Order = 1)]
		[RefreshProperties(RefreshProperties.All)] // Update UI when value is changed
		public HLCCalculationMode PriorDayHlc
		{
			get { return priorDayHlc; }
			set { priorDayHlc = value; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> R1
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> R2
		{
			get { return Values[2]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> R3
		{
			get { return Values[3]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> S1
		{
			get { return Values[4]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> S2
		{
			get { return Values[5]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> S3
		{
			get { return Values[6]; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UserDefinedClose", GroupName = "NinjaScriptParameters", Order = 2)]
		public double UserDefinedClose
		{
			get { return userDefinedClose; }
			set { userDefinedClose = value; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UserDefinedHigh", GroupName = "NinjaScriptParameters", Order = 3)]
		public double UserDefinedHigh
		{
			get { return userDefinedHigh; }
			set { userDefinedHigh = value; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UserDefinedLow", GroupName = "NinjaScriptParameters", Order = 4)]
		public double UserDefinedLow
		{
			get { return userDefinedLow; }
			set { userDefinedLow = value; }
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Width", GroupName = "NinjaScriptParameters", Order = 5)]
		public int Width
		{
			get { return width; }
			set { width = value; }
		}

		#endregion
	}

	// Hide UserDefinedValues properties when not in use by the HLCCalculationMode.UserDefinedValues
	// When creating a custom type converter for indicators it must inherit from NinjaTrader.NinjaScript.IndicatorBaseConverter to work correctly with indicators
	public class PivotsTypeConverter : NinjaTrader.NinjaScript.IndicatorBaseConverter
	{
		public override bool GetPropertiesSupported(ITypeDescriptorContext context) { return true; }

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection propertyDescriptorCollection = base.GetPropertiesSupported(context) ? base.GetProperties(context, value, attributes) : TypeDescriptor.GetProperties(value, attributes);

			Pivots						thisPivotsInstance			= (Pivots) value;
			HLCCalculationMode	selectedHLCCalculationMode	= thisPivotsInstance.PriorDayHlc;
			if (selectedHLCCalculationMode == HLCCalculationMode.UserDefinedValues)
				return propertyDescriptorCollection;

			PropertyDescriptorCollection adjusted = new PropertyDescriptorCollection(null);
			foreach (PropertyDescriptor thisDescriptor in propertyDescriptorCollection)
			{
				if (thisDescriptor.Name == "UserDefinedClose" || thisDescriptor.Name == "UserDefinedHigh" || thisDescriptor.Name == "UserDefinedLow")
					adjusted.Add(new PropertyDescriptorExtended(thisDescriptor, o => value, null, new Attribute[] {new BrowsableAttribute(false), }));
				else
					adjusted.Add(thisDescriptor);
			}
			return adjusted;
		}
	}
}

[TypeConverter("NinjaTrader.Custom.ResourceEnumConverter")]
public enum HLCCalculationMode
{
	CalcFromIntradayData,
	DailyBars,
	UserDefinedValues
}

[TypeConverter("NinjaTrader.Custom.ResourceEnumConverter")]
public enum PivotRange
{
	Daily,
	Weekly,
	Monthly,
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Pivots[] cachePivots;
		public Pivots Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return Pivots(Input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}

		public Pivots Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			if (cachePivots != null)
				for (int idx = 0; idx < cachePivots.Length; idx++)
					if (cachePivots[idx] != null && cachePivots[idx].PivotRangeType == pivotRangeType && cachePivots[idx].PriorDayHlc == priorDayHlc && cachePivots[idx].UserDefinedClose == userDefinedClose && cachePivots[idx].UserDefinedHigh == userDefinedHigh && cachePivots[idx].UserDefinedLow == userDefinedLow && cachePivots[idx].Width == width && cachePivots[idx].EqualsInput(input))
						return cachePivots[idx];
			return CacheIndicator<Pivots>(new Pivots(){ PivotRangeType = pivotRangeType, PriorDayHlc = priorDayHlc, UserDefinedClose = userDefinedClose, UserDefinedHigh = userDefinedHigh, UserDefinedLow = userDefinedLow, Width = width }, input, ref cachePivots);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Pivots Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.Pivots(Input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}

		public Indicators.Pivots Pivots(ISeries<double> input , PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.Pivots(input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Pivots Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.Pivots(Input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}

		public Indicators.Pivots Pivots(ISeries<double> input , PivotRange pivotRangeType, HLCCalculationMode priorDayHlc, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
		{
			return indicator.Pivots(input, pivotRangeType, priorDayHlc, userDefinedClose, userDefinedHigh, userDefinedLow, width);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The PPO (Percentage Price Oscillator) is based on two moving averages expressed as
	/// a percentage. The PPO is found by subtracting the longer MA from the shorter MA and
	/// then dividing the difference by the longer MA.
	/// </summary>
	public class PPO : Indicator
	{
		private EMA emaFast;
		private EMA emaSlow;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionPPO;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNamePPO;
				IsSuspendedWhileInactive	= true;
				Fast						= 12;
				Slow						= 26;
				Smooth						= 9;

				AddPlot(Brushes.DimGray,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorDefault);
				AddPlot(Brushes.Crimson,		NinjaTrader.Custom.Resource.PPOSmoothed);
				AddLine(Brushes.DarkGray,	0,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.DataLoaded)
			{
				emaFast = EMA(Fast);
				emaSlow = EMA(Slow);
			}
		}

		protected override void OnBarUpdate()
		{
			double emaSlow0		= emaSlow[0];
			Default[0] 			= 100 * ((emaFast[0] - emaSlow0) / emaSlow0);
			Smoothed[0]			= EMA(Values[0], Smooth)[0];
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Default
		{
			get { return Values[0]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Fast", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Fast
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Slow", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Slow
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 2)]
		public int Smooth
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Smoothed
		{
			get { return Values[1]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private PPO[] cachePPO;
		public PPO PPO(int fast, int slow, int smooth)
		{
			return PPO(Input, fast, slow, smooth);
		}

		public PPO PPO(ISeries<double> input, int fast, int slow, int smooth)
		{
			if (cachePPO != null)
				for (int idx = 0; idx < cachePPO.Length; idx++)
					if (cachePPO[idx] != null && cachePPO[idx].Fast == fast && cachePPO[idx].Slow == slow && cachePPO[idx].Smooth == smooth && cachePPO[idx].EqualsInput(input))
						return cachePPO[idx];
			return CacheIndicator<PPO>(new PPO(){ Fast = fast, Slow = slow, Smooth = smooth }, input, ref cachePPO);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.PPO PPO(int fast, int slow, int smooth)
		{
			return indicator.PPO(Input, fast, slow, smooth);
		}

		public Indicators.PPO PPO(ISeries<double> input , int fast, int slow, int smooth)
		{
			return indicator.PPO(input, fast, slow, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.PPO PPO(int fast, int slow, int smooth)
		{
			return indicator.PPO(Input, fast, slow, smooth);
		}

		public Indicators.PPO PPO(ISeries<double> input , int fast, int slow, int smooth)
		{
			return indicator.PPO(input, fast, slow, smooth);
		}
	}
}

#endregion


#########################

﻿//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Data;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Displays ask, bid, and/or last lines on the chart.
	/// </summary>
	public class PriceLine : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description						= Custom.Resource.NinjaScriptIndicatorDescriptionPriceLine;
				Name							= Custom.Resource.NinjaScriptIndicatorNamePriceLine;
				Calculate						= Calculate.OnPriceChange;
				IsOverlay						= true;
				ShowTransparentPlotsInDataBox	= false;
				DrawOnPricePanel				= true;
				IsSuspendedWhileInactive 		= true;
				ShowAskLine 					= false;
				ShowBidLine 					= false;
				ShowLastLine 					= true;
				AskLineLength 					= 100;
				BidLineLength 					= 100;
				LastLineLength 					= 100;
				AskStroke						= new Stroke(Brushes.DarkGreen, DashStyleHelper.Dash, 1);
				BidStroke						= new Stroke(Brushes.Blue, DashStyleHelper.Dash, 1);
				LastStroke						= new Stroke(Brushes.Yellow, DashStyleHelper.Dash, 1);
			}
			else if (State == State.Configure)
			{
				AddPlot(ShowAskLine ? AskStroke.Brush : Brushes.Transparent, Custom.Resource.PriceLinePlotAsk);
				AddPlot(ShowBidLine ? BidStroke.Brush : Brushes.Transparent, Custom.Resource.PriceLinePlotBid);
				AddPlot(ShowLastLine ? LastStroke.Brush : Brushes.Transparent, Custom.Resource.PriceLinePlotLast);
			}
		}

		protected override void OnBarUpdate() { }
		
		public override void OnCalculateMinMax()
		{
			double tmpMin = double.MaxValue;
			double tmpMax = double.MinValue;
			
			if (Values[0].Count > 0 && ShowAskLine && Values[0].IsValidDataPointAt(Values[0].Count - 1))
			{
				double askTmp = Values[0].GetValueAt(Values[0].Count - 1);
				tmpMin = Math.Min(tmpMin, askTmp);
				tmpMax = Math.Max(tmpMax, askTmp);
			}
			
			if (Values[1].Count > 0 && ShowBidLine && Values[1].IsValidDataPointAt(Values[1].Count - 1))
			{
				double bidTmp = Values[1].GetValueAt(Values[1].Count - 1);
				tmpMin = Math.Min(tmpMin, bidTmp);
				tmpMax = Math.Max(tmpMax, bidTmp);
			}
			
			if (Values[2].Count > 0 && ShowLastLine && Values[2].IsValidDataPointAt(Values[2].Count - 1))
			{
				double lastTmp = Values[2].GetValueAt(Values[2].Count - 1);
				tmpMin = Math.Min(tmpMin, lastTmp);
				tmpMax = Math.Max(tmpMax, lastTmp);
			}
			
			MinValue = tmpMin;
			MaxValue = tmpMax;
		}
		
		protected override void OnMarketData(MarketDataEventArgs e)
		{
			if (e.MarketDataType != MarketDataType.Last || CurrentBar < 0)
				return;
			
			Values[0][0] = e.Ask;
			Values[1][0] = e.Bid;
			Values[2][0] = e.Price;
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
		{
			if (BarsArray[0] == null || ChartBars == null)
				return;
			
			ChartPanel	panel 	= chartControl.ChartPanels[chartScale.PanelIndex];
			float 		endX 	= panel.X + panel.W;
			
			if (Values[0].Count > 0 && ShowAskLine && Values[0].IsValidDataPointAt(Values[0].Count - 1))
			{
				float startX 	= Convert.ToSingle(panel.X + panel.W * (1 - AskLineLength / 100.0));
				float y 		= chartScale.GetYByValue(Values[0].GetValueAt(Values[0].Count - 1));
				
				RenderTarget.DrawLine(new SharpDX.Vector2(startX, y), new SharpDX.Vector2(endX, y), AskStroke.BrushDX, AskStroke.Width, AskStroke.StrokeStyle);
			}
			
			if (Values[1].Count > 0 && ShowBidLine && Values[1].IsValidDataPointAt(Values[1].Count - 1))
			{
				float startX 	= Convert.ToSingle(panel.X + panel.W * (1 - BidLineLength / 100.0));
				float y 		= chartScale.GetYByValue(Values[1].GetValueAt(Values[1].Count - 1));
				
				RenderTarget.DrawLine(new SharpDX.Vector2(startX, y), new SharpDX.Vector2(endX, y), BidStroke.BrushDX, BidStroke.Width, BidStroke.StrokeStyle);
			}
			
			if (Values[2].Count > 0 && ShowLastLine && Values[2].IsValidDataPointAt(Values[2].Count - 1))
			{
				float startX 	= Convert.ToSingle(panel.X + panel.W * (1 - LastLineLength / 100.0));
				float y 		= chartScale.GetYByValue(Values[2].GetValueAt(Values[2].Count - 1));
				
				RenderTarget.DrawLine(new SharpDX.Vector2(startX, y), new SharpDX.Vector2(endX, y), LastStroke.BrushDX, LastStroke.Width, LastStroke.StrokeStyle);
			}
		}
		
		public override void OnRenderTargetChanged()
		{
			AskStroke	.RenderTarget = RenderTarget;
			BidStroke	.RenderTarget = RenderTarget;
			LastStroke	.RenderTarget = RenderTarget;
		}
		
		#region Properties
		[XmlIgnore]
		[Browsable(false)]
		public double AskLine { get { return Values[0].GetValueAt(Values[0].Count - 1); } }

		[XmlIgnore]
		[Browsable(false)]
		public double BidLine { get { return Values[1].GetValueAt(Values[1].Count - 1); } }

		[XmlIgnore]
		[Browsable(false)]
		public double LastLine { get { return Values[2].GetValueAt(Values[2].Count - 1); } }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowAskLine", GroupName = "NinjaScriptParameters", Order = 0)]
		public bool ShowAskLine { get; set; }
		
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowBidLine", GroupName = "NinjaScriptParameters", Order = 1)]
		public bool ShowBidLine { get; set; }
		
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowLastLine", GroupName = "NinjaScriptParameters", Order = 2)]
		public bool ShowLastLine { get; set; }
		
		[Range(1, 100)]
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "AskLineLength", GroupName = "NinjaScriptParameters", Order = 3)]
		public int AskLineLength { get; set; }
		
		[Range(1, 100)]
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "BidLineLength", GroupName = "NinjaScriptParameters", Order = 4)]
		public int BidLineLength { get; set; }
		
		[Range(1, 100)]
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "LastLineLength", GroupName = "NinjaScriptParameters", Order = 5)]
		public int LastLineLength { get; set; }
		
		[Display(ResourceType = typeof(Custom.Resource), Name = "AskLineStroke", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 1800)]
		public Stroke AskStroke { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "BidLineStroke", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 1810)]
		public Stroke BidStroke { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "LastLineStroke", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 1820)]
		public Stroke LastStroke { get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private PriceLine[] cachePriceLine;
		public PriceLine PriceLine(bool showAskLine, bool showBidLine, bool showLastLine, int askLineLength, int bidLineLength, int lastLineLength)
		{
			return PriceLine(Input, showAskLine, showBidLine, showLastLine, askLineLength, bidLineLength, lastLineLength);
		}

		public PriceLine PriceLine(ISeries<double> input, bool showAskLine, bool showBidLine, bool showLastLine, int askLineLength, int bidLineLength, int lastLineLength)
		{
			if (cachePriceLine != null)
				for (int idx = 0; idx < cachePriceLine.Length; idx++)
					if (cachePriceLine[idx] != null && cachePriceLine[idx].ShowAskLine == showAskLine && cachePriceLine[idx].ShowBidLine == showBidLine && cachePriceLine[idx].ShowLastLine == showLastLine && cachePriceLine[idx].AskLineLength == askLineLength && cachePriceLine[idx].BidLineLength == bidLineLength && cachePriceLine[idx].LastLineLength == lastLineLength && cachePriceLine[idx].EqualsInput(input))
						return cachePriceLine[idx];
			return CacheIndicator<PriceLine>(new PriceLine(){ ShowAskLine = showAskLine, ShowBidLine = showBidLine, ShowLastLine = showLastLine, AskLineLength = askLineLength, BidLineLength = bidLineLength, LastLineLength = lastLineLength }, input, ref cachePriceLine);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.PriceLine PriceLine(bool showAskLine, bool showBidLine, bool showLastLine, int askLineLength, int bidLineLength, int lastLineLength)
		{
			return indicator.PriceLine(Input, showAskLine, showBidLine, showLastLine, askLineLength, bidLineLength, lastLineLength);
		}

		public Indicators.PriceLine PriceLine(ISeries<double> input , bool showAskLine, bool showBidLine, bool showLastLine, int askLineLength, int bidLineLength, int lastLineLength)
		{
			return indicator.PriceLine(input, showAskLine, showBidLine, showLastLine, askLineLength, bidLineLength, lastLineLength);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.PriceLine PriceLine(bool showAskLine, bool showBidLine, bool showLastLine, int askLineLength, int bidLineLength, int lastLineLength)
		{
			return indicator.PriceLine(Input, showAskLine, showBidLine, showLastLine, askLineLength, bidLineLength, lastLineLength);
		}

		public Indicators.PriceLine PriceLine(ISeries<double> input , bool showAskLine, bool showBidLine, bool showLastLine, int askLineLength, int bidLineLength, int lastLineLength)
		{
			return indicator.PriceLine(input, showAskLine, showBidLine, showLastLine, askLineLength, bidLineLength, lastLineLength);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Price Oscillator indicator shows the variation among two moving averages for the price of a security.
	/// </summary>
	public class PriceOscillator : Indicator
	{
		private	EMA					emaFast;
		private EMA					emaSlow;
		private EMA					emaSmooth;
		private	Series<double>		smoothEma;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionPriceOscillator;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNamePriceOscillator;
				Fast						= 12;
				IsSuspendedWhileInactive	= true;
				Slow						= 26;
				Smooth						= 9;

				AddLine(Brushes.DarkGray,	0,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
				AddPlot(Brushes.Goldenrod,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNamePriceOscillator);
			}
			else if (State == State.DataLoaded)
			{
				smoothEma	= new Series<double>(this);
				emaFast		= EMA(Fast);
				emaSlow		= EMA(Slow);
				emaSmooth	= EMA(smoothEma, Smooth);
			}
		}

		protected override void OnBarUpdate()
		{
			smoothEma[0]	= emaFast[0] - emaSlow[0];
			Value[0]		= emaSmooth[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Fast", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Fast
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Slow", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Slow
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 2)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private PriceOscillator[] cachePriceOscillator;
		public PriceOscillator PriceOscillator(int fast, int slow, int smooth)
		{
			return PriceOscillator(Input, fast, slow, smooth);
		}

		public PriceOscillator PriceOscillator(ISeries<double> input, int fast, int slow, int smooth)
		{
			if (cachePriceOscillator != null)
				for (int idx = 0; idx < cachePriceOscillator.Length; idx++)
					if (cachePriceOscillator[idx] != null && cachePriceOscillator[idx].Fast == fast && cachePriceOscillator[idx].Slow == slow && cachePriceOscillator[idx].Smooth == smooth && cachePriceOscillator[idx].EqualsInput(input))
						return cachePriceOscillator[idx];
			return CacheIndicator<PriceOscillator>(new PriceOscillator(){ Fast = fast, Slow = slow, Smooth = smooth }, input, ref cachePriceOscillator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.PriceOscillator PriceOscillator(int fast, int slow, int smooth)
		{
			return indicator.PriceOscillator(Input, fast, slow, smooth);
		}

		public Indicators.PriceOscillator PriceOscillator(ISeries<double> input , int fast, int slow, int smooth)
		{
			return indicator.PriceOscillator(input, fast, slow, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.PriceOscillator PriceOscillator(int fast, int slow, int smooth)
		{
			return indicator.PriceOscillator(Input, fast, slow, smooth);
		}

		public Indicators.PriceOscillator PriceOscillator(ISeries<double> input , int fast, int slow, int smooth)
		{
			return indicator.PriceOscillator(input, fast, slow, smooth);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Plots the open, high, low and close values from the session starting on the prior day.
	/// </summary>
	public class PriorDayOHLC : Indicator
	{
		private DateTime 				currentDate 		=	Core.Globals.MinDate;
		private double					currentClose		=	0;
		private double					currentHigh			=	0;
		private double					currentLow			=	0;
		private double					currentOpen			=	0;
		private double					priorDayClose		=	0;
		private double					priorDayHigh		=	0;
		private double					priorDayLow			=	0;
		private double					priorDayOpen		=	0;
		private	Data.SessionIterator	sessionIterator;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionPriorDayOHLC;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNamePriorDayOHLC;
				IsAutoScale					= false;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				DrawOnPricePanel			= false;
				ShowClose					= true;
				ShowLow						= true;
				ShowHigh					= true;
				ShowOpen					= true;

				AddPlot(new Stroke(Brushes.SteelBlue,	DashStyleHelper.Dash,	2),	PlotStyle.Hash, NinjaTrader.Custom.Resource.PriorDayOHLCOpen);
				AddPlot(new Stroke(Brushes.DarkCyan,							2),	PlotStyle.Hash, NinjaTrader.Custom.Resource.PriorDayOHLCHigh);
				AddPlot(new Stroke(Brushes.Crimson,								2),	PlotStyle.Hash, NinjaTrader.Custom.Resource.PriorDayOHLCLow);
				AddPlot(new Stroke(Brushes.SlateBlue,	DashStyleHelper.Dash,	2),	PlotStyle.Hash, NinjaTrader.Custom.Resource.PriorDayOHLCClose);
			}
			else if (State == State.Configure)
			{
				currentDate 	    = Core.Globals.MinDate;
				currentClose		= 0;
				currentHigh			= 0;
				currentLow			= 0;
				currentOpen			= 0;
				priorDayClose		= 0;
				priorDayHigh		= 0;
				priorDayLow			= 0;
				priorDayOpen		= 0;
				sessionIterator		= null;
			}
			else if (State == State.DataLoaded)
			{
				sessionIterator = new Data.SessionIterator(Bars);
			}
			else if (State == State.Historical)
			{
				if (!Bars.BarsType.IsIntraday)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.PriorDayOHLCIntradayError, TextPosition.BottomRight);
					Log(NinjaTrader.Custom.Resource.PriorDayOHLCIntradayError, LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (!Bars.BarsType.IsIntraday)
				return;

			// If the current data is not the same date as the current bar then its a new session
			if (currentDate != sessionIterator.GetTradingDay(Time[0]) || currentOpen == 0)
			{
				// The current day OHLC values are now the prior days value so set
				// them to their respect indicator series for plotting
				priorDayOpen	= currentOpen;
				priorDayHigh	= currentHigh;
				priorDayLow		= currentLow;
				priorDayClose	= currentClose;

				if (ShowOpen)	PriorOpen[0]	= priorDayOpen;
				if (ShowHigh)	PriorHigh[0]	= priorDayHigh;
				if (ShowLow)	PriorLow[0]		= priorDayLow;
				if (ShowClose)	PriorClose[0]	= priorDayClose;

				// Initilize the current day settings to the new days data
				currentOpen 	=	Open[0];
				currentHigh 	=	High[0];
				currentLow		=	Low[0];
				currentClose	=	Close[0];

				currentDate 	=	sessionIterator.GetTradingDay(Time[0]);
			}
			else // The current day is the same day
			{
				// Set the current day OHLC values
				currentHigh 	=	Math.Max(currentHigh, High[0]);
				currentLow		=	Math.Min(currentLow, Low[0]);
				currentClose	=	Close[0];

				if (ShowOpen)	PriorOpen[0] = priorDayOpen;
				if (ShowHigh)	PriorHigh[0] = priorDayHigh;
				if (ShowLow)	PriorLow[0] = priorDayLow;
				if (ShowClose)	PriorClose[0] = priorDayClose;
			}
		}

		#region Properties
		[Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
		[XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
		public Series<double> PriorOpen
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> PriorHigh
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> PriorLow
		{
			get { return Values[2]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> PriorClose
		{
			get { return Values[3]; }
		}

		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowClose", GroupName = "NinjaScriptParameters", Order = 0)]
		public bool ShowClose
		{ get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowHigh", GroupName = "NinjaScriptParameters", Order = 1)]
		public bool ShowHigh
		{ get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowLow", GroupName = "NinjaScriptParameters", Order = 2)]
		public bool ShowLow
		{ get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowOpen", GroupName = "NinjaScriptParameters", Order = 3)]
		public bool ShowOpen
		{ get; set; }
		#endregion
		
		public override string FormatPriceMarker(double price)
		{
			return Instrument.MasterInstrument.FormatPrice(price);
		}
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private PriorDayOHLC[] cachePriorDayOHLC;
		public PriorDayOHLC PriorDayOHLC()
		{
			return PriorDayOHLC(Input);
		}

		public PriorDayOHLC PriorDayOHLC(ISeries<double> input)
		{
			if (cachePriorDayOHLC != null)
				for (int idx = 0; idx < cachePriorDayOHLC.Length; idx++)
					if (cachePriorDayOHLC[idx] != null &&  cachePriorDayOHLC[idx].EqualsInput(input))
						return cachePriorDayOHLC[idx];
			return CacheIndicator<PriorDayOHLC>(new PriorDayOHLC(), input, ref cachePriorDayOHLC);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.PriorDayOHLC PriorDayOHLC()
		{
			return indicator.PriorDayOHLC(Input);
		}

		public Indicators.PriorDayOHLC PriorDayOHLC(ISeries<double> input )
		{
			return indicator.PriorDayOHLC(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.PriorDayOHLC PriorDayOHLC()
		{
			return indicator.PriorDayOHLC(Input);
		}

		public Indicators.PriorDayOHLC PriorDayOHLC(ISeries<double> input )
		{
			return indicator.PriorDayOHLC(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class PsychologicalLine : Indicator
	{
		private double	prevUpBars;
		private int		saveCurrentBar;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description = NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionPsychologicalLine;
				Name		= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNamePsychologicalLine;
				IsOverlay	= false;
				Period		= 10;

				AddPlot(Brushes.DodgerBlue,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNamePsychologicalLine);
				AddLine(Brushes.DarkCyan, 75,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorOverBoughtLine);
				AddLine(Brushes.DarkCyan, 25,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorOverSoldLine);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar > saveCurrentBar)
				prevUpBars = prevUpBars + (Close[1] > Open[1] ? 1 : 0) - (CurrentBar <= Period - 1 ? 0 : Close[Period] > Open[Period] ? 1 : 0);
			else if (BarsArray[0].BarsType.IsRemoveLastBarSupported && saveCurrentBar < CurrentBar)
			{
				prevUpBars = 0;
				for (int barsBack = Math.Min(CurrentBar, Period - 1); barsBack > 0; barsBack--)
					if (Close[barsBack] > Open[barsBack])
						prevUpBars++;
			}

			Value[0]		= (((double) prevUpBars + (Close[0] > Open[0] ? 1 : 0)) / Math.Min(CurrentBar + 1, Period)) * 100;
			saveCurrentBar	= CurrentBar;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private PsychologicalLine[] cachePsychologicalLine;
		public PsychologicalLine PsychologicalLine(int period)
		{
			return PsychologicalLine(Input, period);
		}

		public PsychologicalLine PsychologicalLine(ISeries<double> input, int period)
		{
			if (cachePsychologicalLine != null)
				for (int idx = 0; idx < cachePsychologicalLine.Length; idx++)
					if (cachePsychologicalLine[idx] != null && cachePsychologicalLine[idx].Period == period && cachePsychologicalLine[idx].EqualsInput(input))
						return cachePsychologicalLine[idx];
			return CacheIndicator<PsychologicalLine>(new PsychologicalLine(){ Period = period }, input, ref cachePsychologicalLine);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.PsychologicalLine PsychologicalLine(int period)
		{
			return indicator.PsychologicalLine(Input, period);
		}

		public Indicators.PsychologicalLine PsychologicalLine(ISeries<double> input , int period)
		{
			return indicator.PsychologicalLine(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.PsychologicalLine PsychologicalLine(int period)
		{
			return indicator.PsychologicalLine(Input, period);
		}

		public Indicators.PsychologicalLine PsychologicalLine(ISeries<double> input , int period)
		{
			return indicator.PsychologicalLine(input, period);
		}
	}
}

#endregion



#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Calculates the range of a bar.
	/// </summary>
	public class Range : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionRange;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRange;
				BarsRequiredToPlot			= 0;
				IsSuspendedWhileInactive	= true;

				AddPlot(new Stroke(Brushes.Goldenrod, 2), PlotStyle.Bar, NinjaTrader.Custom.Resource.RangeValue);
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = High[0] - Low[0];
		}
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Range[] cacheRange;
		public Range Range()
		{
			return Range(Input);
		}

		public Range Range(ISeries<double> input)
		{
			if (cacheRange != null)
				for (int idx = 0; idx < cacheRange.Length; idx++)
					if (cacheRange[idx] != null &&  cacheRange[idx].EqualsInput(input))
						return cacheRange[idx];
			return CacheIndicator<Range>(new Range(), input, ref cacheRange);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Range Range()
		{
			return indicator.Range(Input);
		}

		public Indicators.Range Range(ISeries<double> input )
		{
			return indicator.Range(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Range Range()
		{
			return indicator.Range(Input);
		}

		public Indicators.Range Range(ISeries<double> input )
		{
			return indicator.Range(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class RangeCounter : Indicator
	{
		private string rangeString;
		private bool supportsRange;
		private bool isAdvancedType;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionRangeCounter;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRangeCounter;
				Calculate					= Calculate.OnPriceChange;
				CountDown					= true;
				DisplayInDataBox			= false;
				DrawOnPricePanel			= false;
				IsOverlay					= true;
				IsChartOnly					= true;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
			}
			else if (State == State.Historical)
			{
				isAdvancedType		= BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric;
				bool isOtherType	= BarsPeriod.ToString().IndexOf("Range") >= 0 || BarsPeriod.ToString().IndexOf(NinjaTrader.Custom.Resource.BarsPeriodTypeNameRange) >= 0;

				if (BarsPeriod.BarsPeriodType == BarsPeriodType.Range ||
					BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Range && isAdvancedType ||
					BarsArray[0].BarsType.BuiltFrom == BarsPeriodType.Tick && isOtherType)
				{
					supportsRange = true;
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray == null || BarsArray.Length == 0)
				return;

			if (supportsRange)
			{
				double	high		= High.GetValueAt(Bars.Count - 1 - (Calculate == NinjaTrader.NinjaScript.Calculate.OnBarClose ? 1 : 0));
				double	low			= Low.GetValueAt(Bars.Count - 1 - (Calculate == NinjaTrader.NinjaScript.Calculate.OnBarClose ? 1 : 0));
				double	close		= Close.GetValueAt(Bars.Count - 1 - (Calculate == NinjaTrader.NinjaScript.Calculate.OnBarClose ? 1 : 0));
				int		actualRange	= (int)Math.Round(Math.Max(close - low, high - close) / Bars.Instrument.MasterInstrument.TickSize);
				double	rangeCount	= CountDown ? (isAdvancedType ? BarsPeriod.BaseBarsPeriodValue : BarsPeriod.Value) - actualRange : actualRange;

				rangeString	= CountDown ? string.Format(NinjaTrader.Custom.Resource.RangeCounterRemaing, rangeCount) : 
										  string.Format(NinjaTrader.Custom.Resource.RangerCounterCount, rangeCount);
			}
			else
				rangeString = NinjaTrader.Custom.Resource.RangeCounterBarError;

			Draw.TextFixed(this, "NinjaScriptInfo", rangeString, TextPosition.BottomRight);
		}

		#region Properties
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "CountDown", Order = 1, GroupName = "NinjaScriptParameters")]
		public bool CountDown
		{ get; set; }
		#endregion

	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private RangeCounter[] cacheRangeCounter;
		public RangeCounter RangeCounter(bool countDown)
		{
			return RangeCounter(Input, countDown);
		}

		public RangeCounter RangeCounter(ISeries<double> input, bool countDown)
		{
			if (cacheRangeCounter != null)
				for (int idx = 0; idx < cacheRangeCounter.Length; idx++)
					if (cacheRangeCounter[idx] != null && cacheRangeCounter[idx].CountDown == countDown && cacheRangeCounter[idx].EqualsInput(input))
						return cacheRangeCounter[idx];
			return CacheIndicator<RangeCounter>(new RangeCounter(){ CountDown = countDown }, input, ref cacheRangeCounter);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.RangeCounter RangeCounter(bool countDown)
		{
			return indicator.RangeCounter(Input, countDown);
		}

		public Indicators.RangeCounter RangeCounter(ISeries<double> input , bool countDown)
		{
			return indicator.RangeCounter(input, countDown);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.RangeCounter RangeCounter(bool countDown)
		{
			return indicator.RangeCounter(Input, countDown);
		}

		public Indicators.RangeCounter RangeCounter(ISeries<double> input , bool countDown)
		{
			return indicator.RangeCounter(input, countDown);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX;
using SharpDX.Direct2D1;

#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Linear regression is used to calculate a best fit line for the price data. In addition an upper and lower band is added by calculating the standard deviation of prices from the regression line.
	/// </summary>
	public class RegressionChannel : Indicator
	{
		private Series<double> interceptSeries;
		private Series<double> slopeSeries;
		private Series<double> stdDeviationSeries;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionRegressionChannel;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRegressionChannel;
				IsAutoScale					= false;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 35;
				Width						= 2;

				AddPlot(Brushes.DarkGray, NinjaTrader.Custom.Resource.NinjaScriptIndicatorMiddle);
				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
			}
			else if (State == State.DataLoaded)
			{
				interceptSeries		= new Series<double>(this);
				slopeSeries			= new Series<double>(this);
				stdDeviationSeries	= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			// First we calculate the linear regression parameters

			double sumX = (double) Period*(Period - 1)*.5;
			double divisor = sumX*sumX -
								(double) Period*Period*(Period - 1)*(2*Period - 1)/6;
			double sumXY = 0;
			double sumY = 0;
			int barCount = Math.Min(Period, CurrentBar);

			for (int count = 0; count < barCount; count++)
			{
				sumXY += count*Input[count];
				sumY += Input[count];
			}

			if (divisor.ApproxCompare(0) == 0 && Period == 0) return;

			double slope = (Period*sumXY - sumX*sumY)/divisor;
			double intercept = (sumY - slope*sumX)/Period;

			slopeSeries[0] = slope;
			interceptSeries[0] = intercept;

			// Next we calculate the standard deviation of the
			// residuals (vertical distances to the regression line).

			double sumResiduals = 0;

			for (int count = 0; count < barCount; count++)
			{
				double regressionValue = intercept + slope * (Period - 1 - count);
				double residual = Math.Abs(Input[count] - regressionValue);
				sumResiduals += residual;
			}

			double avgResiduals = sumResiduals / Math.Min(CurrentBar - 1, Period);

			sumResiduals = 0;
			for (int count = 0; count < barCount; count++)
			{
				double regressionValue = intercept + slope * (Period - 1 - count);
				double residual = Math.Abs(Input[count] - regressionValue);
				sumResiduals += (residual - avgResiduals) * (residual - avgResiduals);
			}

			double stdDeviation = Math.Sqrt(sumResiduals / Math.Min(CurrentBar + 1, Period));
			stdDeviationSeries[0] = stdDeviation;

			double middle = intercept + slope * (Period - 1);
			Middle[0] = CurrentBar == 0 ? Input[0] : middle;
			Upper[0] = stdDeviation.ApproxCompare(0) == 0 || Double.IsInfinity(stdDeviation) ? Input[0] : middle + stdDeviation * Width;
			Lower[0] = stdDeviation.ApproxCompare(0) == 0 || Double.IsInfinity(stdDeviation) ? Input[0] : middle - stdDeviation * Width;
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Lower
		{
			get { return Values[2]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Middle
		{
			get { return Values[0]; }
		}

		[Range(2, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptGeneral", Order = 0)]
		public int Period
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Upper
		{
			get { return Values[1]; }
		}

		[Range(1, double.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Width", GroupName = "NinjaScriptGeneral", Order = 1)]
		public double Width
		{ get; set; }
		#endregion

		#region Misc
		private int GetXPos(int barsBack)
		{
			return ChartControl.GetXByBarIndex(ChartBars,
				Math.Max(0, Bars.Count - 1 - barsBack - (Calculate == Calculate.OnBarClose ? 1 : 0)));
		}

		private int GetYPos(double price, ChartScale chartScale)
		{
			return chartScale.GetYByValue(price);
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
		{
			if (Bars == null || ChartControl == null) return;

			RenderTarget.AntialiasMode = AntialiasMode.PerPrimitive;

			ChartPanel panel = chartControl.ChartPanels[ChartPanel.PanelIndex];

			int idx = BarsArray[0].Count - 1 - (Calculate == Calculate.OnBarClose ? 1 : 0);
			double intercept = interceptSeries.GetValueAt(idx);
			double slope = slopeSeries.GetValueAt(idx);
			double stdDev = stdDeviationSeries.GetValueAt(idx);
			int stdDevPixels = (int) Math.Round(((stdDev*Width)/(chartScale.MaxValue - chartScale.MinValue))*panel.H, 0);
			int xPos = GetXPos(Period - 1 - Displacement);
			int yPos = GetYPos(intercept, chartScale);
			int xPos2 = GetXPos(0 - Displacement);
			int yPos2 = GetYPos(intercept + slope*(Period - 1), chartScale);
			Vector2 startVector = new Vector2(xPos, yPos);
			Vector2 endVector = new Vector2(xPos2, yPos2);

			// Middle
			RenderTarget.DrawLine(startVector, endVector, Plots[0].BrushDX, Plots[0].Width, Plots[0].StrokeStyle);

			// Upper
			RenderTarget.DrawLine(new Vector2(startVector.X, startVector.Y - stdDevPixels), new Vector2(endVector.X, endVector.Y - stdDevPixels), Plots[1].BrushDX, Plots[1].Width, Plots[1].StrokeStyle);

			// Lower
			RenderTarget.DrawLine(new Vector2(startVector.X, startVector.Y + stdDevPixels), new Vector2(endVector.X, endVector.Y + stdDevPixels), Plots[2].BrushDX, Plots[2].Width, Plots[2].StrokeStyle);

			RenderTarget.AntialiasMode = AntialiasMode.Aliased;
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private RegressionChannel[] cacheRegressionChannel;
		public RegressionChannel RegressionChannel(int period, double width)
		{
			return RegressionChannel(Input, period, width);
		}

		public RegressionChannel RegressionChannel(ISeries<double> input, int period, double width)
		{
			if (cacheRegressionChannel != null)
				for (int idx = 0; idx < cacheRegressionChannel.Length; idx++)
					if (cacheRegressionChannel[idx] != null && cacheRegressionChannel[idx].Period == period && cacheRegressionChannel[idx].Width == width && cacheRegressionChannel[idx].EqualsInput(input))
						return cacheRegressionChannel[idx];
			return CacheIndicator<RegressionChannel>(new RegressionChannel(){ Period = period, Width = width }, input, ref cacheRegressionChannel);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.RegressionChannel RegressionChannel(int period, double width)
		{
			return indicator.RegressionChannel(Input, period, width);
		}

		public Indicators.RegressionChannel RegressionChannel(ISeries<double> input , int period, double width)
		{
			return indicator.RegressionChannel(input, period, width);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.RegressionChannel RegressionChannel(int period, double width)
		{
			return indicator.RegressionChannel(Input, period, width);
		}

		public Indicators.RegressionChannel RegressionChannel(ISeries<double> input , int period, double width)
		{
			return indicator.RegressionChannel(input, period, width);
		}
	}
}

#endregion


#########################

﻿//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Relative Vigor Index measures the strength of a trend by comparing an instruments closing price to its price range. It's based on the fact that prices tend to close higher than they open in up trends, and closer lower than they open in downtrends.
	/// </summary>
	public class RelativeVigorIndex : Indicator
	{
		private Series<double> series1;
		private Series<double> series2;
		
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionRelativeVigorIndex;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRelativeVigorIndex;
				Calculate					= Calculate.OnBarClose;
				IsOverlay					= false;
				DrawOnPricePanel			= false;
				IsSuspendedWhileInactive	= true;
				Period 						= 10;

				AddPlot(Brushes.Green, NinjaTrader.Custom.Resource.NinjaScriptIndicatorRelativeVigorIndex);
				AddPlot(Brushes.Red, NinjaTrader.Custom.Resource.NinjaScriptIndicatorSignal);
			}
			else if (State == State.DataLoaded)
			{
				series1 = new Series<double>(this);
				series2 = new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < 3)
				return;
			
			series1[0] = ((Close[0] - Open[0]) + 2 * (Close[1] - Open[1]) + 2 * (Close[2] - Open[2]) + (Close[3] - Open[3])) / 6.0;
			series2[0] = ((High[0] - Low[0]) + 2 * (High[1] - Low[1]) + 2 * (High[2] - Low[2]) + (High[3] - Low[3])) / 6.0;

			double numerator 	= 0;
			double denominator 	= 0;

			for (int i = 0; i < Math.Min(CurrentBar, Period); i++)
			{
				numerator 	+= series1[i];
				denominator += series2[i];
			}
			
			if (denominator != 0)
			{
				Value[0] 	= numerator / denominator;
				Signal[0] 	= (Value[0] + 2 * Value[1] + 2 * Value[2] + Value[3]) / 6.0;
			}
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Default { get { return Values[0]; } }
		
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Signal { get { return Values[1]; } }
		
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period { get; set; }
		#endregion

	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private RelativeVigorIndex[] cacheRelativeVigorIndex;
		public RelativeVigorIndex RelativeVigorIndex(int period)
		{
			return RelativeVigorIndex(Input, period);
		}

		public RelativeVigorIndex RelativeVigorIndex(ISeries<double> input, int period)
		{
			if (cacheRelativeVigorIndex != null)
				for (int idx = 0; idx < cacheRelativeVigorIndex.Length; idx++)
					if (cacheRelativeVigorIndex[idx] != null && cacheRelativeVigorIndex[idx].Period == period && cacheRelativeVigorIndex[idx].EqualsInput(input))
						return cacheRelativeVigorIndex[idx];
			return CacheIndicator<RelativeVigorIndex>(new RelativeVigorIndex(){ Period = period }, input, ref cacheRelativeVigorIndex);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.RelativeVigorIndex RelativeVigorIndex(int period)
		{
			return indicator.RelativeVigorIndex(Input, period);
		}

		public Indicators.RelativeVigorIndex RelativeVigorIndex(ISeries<double> input , int period)
		{
			return indicator.RelativeVigorIndex(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.RelativeVigorIndex RelativeVigorIndex(int period)
		{
			return indicator.RelativeVigorIndex(Input, period);
		}

		public Indicators.RelativeVigorIndex RelativeVigorIndex(ISeries<double> input , int period)
		{
			return indicator.RelativeVigorIndex(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// RIND (Range Indicator) compares the intraday range (high - low) to the
	/// inter-day (close - previous close) range. When the intraday range is greater
	/// than the inter-day range, the Range Indicator will be a high value. This
	/// signals an end to the current trend. When the Range Indicator is at a low
	/// level, a new trend is about to start.
	/// </summary>
	public class RIND : Indicator
	{
		private EMA				ema;
		private MIN				min;
		private MAX				max;
		private Series<double>	stochRange;
		private Series<double>	val1;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionRIND;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRIND;
				IsOverlay					= false;
				IsSuspendedWhileInactive	= true;
				PeriodQ						= 3;
				Smooth						= 10;

				AddPlot(Brushes.DarkCyan, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRIND);
			}

			else if (State == State.DataLoaded)
			{
				stochRange 	= new Series<double>(this);
				val1		= new Series<double>(this);
				ema			= EMA(stochRange, Smooth);
				min			= MIN(val1, PeriodQ);
				max			= MAX(val1, PeriodQ);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				stochRange[0]	= 50;
				return;
			}

			double high0		= High[0];
			double low0			= Low[0];
			double close0		= Close[0];
			double close1		= Close[1];
			double trueRange	= Math.Max(high0, close1) - Math.Min(low0, close1);

			if (close0 > close1)
				val1[0] = trueRange / (close0 - close1);
			else
				val1[0] = trueRange;

			double min0		= min[0];
			double max0		= max[0];
			double val10	= val1[0];

			if ((max0 - min0) > 0)
				stochRange[0] = 100 * ((val10 - min0) / (max0 - min0));
			else
				stochRange[0] = 100 * (val10 - min0);

			Value[0] = ema[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "PeriodQ", GroupName = "NinjaScriptParameters", Order = 0)]
		public int PeriodQ
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private RIND[] cacheRIND;
		public RIND RIND(int periodQ, int smooth)
		{
			return RIND(Input, periodQ, smooth);
		}

		public RIND RIND(ISeries<double> input, int periodQ, int smooth)
		{
			if (cacheRIND != null)
				for (int idx = 0; idx < cacheRIND.Length; idx++)
					if (cacheRIND[idx] != null && cacheRIND[idx].PeriodQ == periodQ && cacheRIND[idx].Smooth == smooth && cacheRIND[idx].EqualsInput(input))
						return cacheRIND[idx];
			return CacheIndicator<RIND>(new RIND(){ PeriodQ = periodQ, Smooth = smooth }, input, ref cacheRIND);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.RIND RIND(int periodQ, int smooth)
		{
			return indicator.RIND(Input, periodQ, smooth);
		}

		public Indicators.RIND RIND(ISeries<double> input , int periodQ, int smooth)
		{
			return indicator.RIND(input, periodQ, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.RIND RIND(int periodQ, int smooth)
		{
			return indicator.RIND(Input, periodQ, smooth);
		}

		public Indicators.RIND RIND(ISeries<double> input , int periodQ, int smooth)
		{
			return indicator.RIND(input, periodQ, smooth);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The ROC (Rate-of-Change) indicator displays the percent change between the current price and the price x-time periods ago.
	/// </summary>
	public class ROC : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionROC;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameROC;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddLine(Brushes.DarkGray,	0,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
				AddPlot(Brushes.DodgerBlue,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameROC);
			}
		}

		protected override void OnBarUpdate()
		{
			double inputPeriod = Input[Math.Min(CurrentBar, Period)];
			
			if (inputPeriod <= 0)
				return;
			
			Value[0] = ((Input[0] - inputPeriod) / inputPeriod) * 100;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ROC[] cacheROC;
		public ROC ROC(int period)
		{
			return ROC(Input, period);
		}

		public ROC ROC(ISeries<double> input, int period)
		{
			if (cacheROC != null)
				for (int idx = 0; idx < cacheROC.Length; idx++)
					if (cacheROC[idx] != null && cacheROC[idx].Period == period && cacheROC[idx].EqualsInput(input))
						return cacheROC[idx];
			return CacheIndicator<ROC>(new ROC(){ Period = period }, input, ref cacheROC);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ROC ROC(int period)
		{
			return indicator.ROC(Input, period);
		}

		public Indicators.ROC ROC(ISeries<double> input , int period)
		{
			return indicator.ROC(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ROC ROC(int period)
		{
			return indicator.ROC(Input, period);
		}

		public Indicators.ROC ROC(ISeries<double> input , int period)
		{
			return indicator.ROC(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The RSI (Relative Strength Index) is a price-following oscillator that ranges between 0 and 100.
	/// </summary>
	public class RSI : Indicator
	{
		private Series<double>		avgDown;
		private Series<double>		avgUp;
		private double				constant1;
		private double				constant2;
		private double				constant3;
		private Series<double>		down;
		private SMA					smaDown;
		private	SMA					smaUp;
		private Series<double>		up;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionRSI;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRSI;
				IsSuspendedWhileInactive	= true;
				BarsRequiredToPlot			= 20;
				Period						= 14;
				Smooth						= 3;

				AddPlot(Brushes.DodgerBlue,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRSI);
				AddPlot(Brushes.Goldenrod,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorAvg);

				AddLine(Brushes.DarkCyan,	30,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.DarkCyan,	70,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
			else if (State == State.Configure)
			{
				constant1 = 2.0 / (1 + Smooth);
				constant2 = (1 - (2.0 / (1 + Smooth)));
				constant3 = (Period - 1);
			}
			else if (State == State.DataLoaded)
			{
				avgUp	= new Series<double>(this);
				avgDown = new Series<double>(this);
				down	= new Series<double>(this);
				up		= new Series<double>(this);
				smaDown = SMA(down, Period);
				smaUp	= SMA(up, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				down[0]		= 0;
				up[0]		= 0;

				if (Period < 3)
					Avg[0] = 50;

				return;
			}

			double input0	= Input[0];
			double input1	= Input[1];
			down[0]			= Math.Max(input1 - input0, 0);
			up[0]			= Math.Max(input0 - input1, 0);

			if (CurrentBar + 1 < Period)
			{
				if (CurrentBar + 1 == Period - 1)
					Avg[0] = 50;
				return;
			}

			if ((CurrentBar + 1) == Period)
			{
				// First averages
				avgDown[0]	= smaDown[0];
				avgUp[0]	= smaUp[0];
			}
			else
			{
				// Rest of averages are smoothed
				avgDown[0]	= (avgDown[1] * constant3 + down[0]) / Period;
				avgUp[0]	= (avgUp[1] * constant3 + up[0]) / Period;
			}

			double avgDown0	= avgDown[0];
			double value0	= avgDown0 == 0 ? 100 : 100 - 100 / (1 + avgUp[0] / avgDown0);
			Default[0]		= value0;
			Avg[0]			= constant1 * value0 + constant2 * Avg[1];
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Avg
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Default
		{
			get { return Values[0]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private RSI[] cacheRSI;
		public RSI RSI(int period, int smooth)
		{
			return RSI(Input, period, smooth);
		}

		public RSI RSI(ISeries<double> input, int period, int smooth)
		{
			if (cacheRSI != null)
				for (int idx = 0; idx < cacheRSI.Length; idx++)
					if (cacheRSI[idx] != null && cacheRSI[idx].Period == period && cacheRSI[idx].Smooth == smooth && cacheRSI[idx].EqualsInput(input))
						return cacheRSI[idx];
			return CacheIndicator<RSI>(new RSI(){ Period = period, Smooth = smooth }, input, ref cacheRSI);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.RSI RSI(int period, int smooth)
		{
			return indicator.RSI(Input, period, smooth);
		}

		public Indicators.RSI RSI(ISeries<double> input , int period, int smooth)
		{
			return indicator.RSI(input, period, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.RSI RSI(int period, int smooth)
		{
			return indicator.RSI(Input, period, smooth);
		}

		public Indicators.RSI RSI(ISeries<double> input , int period, int smooth)
		{
			return indicator.RSI(input, period, smooth);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// R-squared indicator
	/// </summary>
	public class RSquared : Indicator
	{
		private double myPeriod;
		private double priorSumXY;
		private	double priorSumY;
		private double priorSumY2;
		private double sumX;
		private double sumX2;
		private double sumXY;
		private double sumY;
		private double sumY2;
		private double denominator;
		private double r;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionRSquared;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRSquared;
				IsSuspendedWhileInactive	= true;
				Period						= 8;
				IsOverlay					= false;

				AddPlot(Brushes.Crimson,			NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRSquared);
				AddLine(Brushes.SlateBlue,	0.2,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.Goldenrod,	0.75,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}

			else if (State == State.Configure)
				priorSumXY = priorSumY = priorSumY2 = sumX = sumXY = sumX2 = sumY2 = denominator = 0;
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				sumX = (double)Period * (Period - 1) * 0.5;
				double divisor = sumX * sumX - (double)Period * Period * (Period - 1) * (2 * Period - 1) / 6;
				sumXY = 0;
				sumX2 = 0;
				sumY2 = 0;

				for (int count = 0; count < Period && CurrentBar - count >= 0; count++)
				{
					sumXY += count * Input[count];
					sumX2 += (count * count);
					sumY2 += (Input[count] * Input[count]);
				}

				double numerator = (Period * sumXY - sumX * SUM(Inputs[0], Period)[0]);
				denominator = (Period * sumX2 - (sumX * sumX)) * (Period * sumY2 - (SUM(Inputs[0], Period)[0] * SUM(Inputs[0], Period)[0]));

				if (denominator > 0)
					r = Math.Pow((numerator / Math.Sqrt(denominator)), 2);
				else
					r = 0;
				Value[0] = r;
			}
			else
			{
				if (IsFirstTickOfBar)
				{
					priorSumXY = sumXY;
					priorSumY = sumY;
					priorSumY2 = sumY2;
					myPeriod = Math.Min(CurrentBar + 1, Period);
					sumX = myPeriod * (myPeriod + 1) * 0.5;
					sumX2 = sumX * (2 * myPeriod + 1) / 3;
				}

				double input0 = Input[0];
				double inputPeriod = Input[Math.Min(Period, CurrentBar)];

				sumXY = priorSumXY - (CurrentBar >= Period ? priorSumY : 0) + myPeriod * input0;
				sumY = priorSumY + input0 - (CurrentBar >= Period ? inputPeriod : 0);
				sumY2 = priorSumY2 + input0 * input0 - (CurrentBar >= Period ? inputPeriod * inputPeriod : 0);
				denominator = (myPeriod * sumX2 - sumX * sumX) * (myPeriod * sumY2 - sumY * sumY);
				r = denominator > 0 ? (myPeriod * sumXY - sumX * sumY) / Math.Sqrt(denominator) : 0;
				Value[0] = (r * r);
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private RSquared[] cacheRSquared;
		public RSquared RSquared(int period)
		{
			return RSquared(Input, period);
		}

		public RSquared RSquared(ISeries<double> input, int period)
		{
			if (cacheRSquared != null)
				for (int idx = 0; idx < cacheRSquared.Length; idx++)
					if (cacheRSquared[idx] != null && cacheRSquared[idx].Period == period && cacheRSquared[idx].EqualsInput(input))
						return cacheRSquared[idx];
			return CacheIndicator<RSquared>(new RSquared(){ Period = period }, input, ref cacheRSquared);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.RSquared RSquared(int period)
		{
			return indicator.RSquared(Input, period);
		}

		public Indicators.RSquared RSquared(ISeries<double> input , int period)
		{
			return indicator.RSquared(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.RSquared RSquared(int period)
		{
			return indicator.RSquared(Input, period);
		}

		public Indicators.RSquared RSquared(ISeries<double> input , int period)
		{
			return indicator.RSquared(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Relative Spread Strength of the spread between two moving averages. TASC, October 2006, p. 16.
	/// </summary>
	public class RSS : Indicator
	{
		private EMA				ema1;
		private EMA				ema2;
		private RSI				rsi;
		private SMA				sma;
		private Series<double>	spread;
		private Series<double>	rs;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionRSS;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRSS;
				IsSuspendedWhileInactive	= true;
				EMA1						= 10;
				EMA2						= 40;
				Length						= 5;

				AddPlot(Brushes.DarkCyan,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRSS);
				AddLine(Brushes.DarkGray,	20,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.DarkGray,	80,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
			else if (State == State.DataLoaded)
			{
				spread 	= new Series<double>(this);
				rs		= new Series<double>(this);
				ema1	= EMA(EMA1);
				ema2	= EMA(EMA2);
				rsi		= RSI(spread, Length, 1);
				sma		= SMA(rs, 5);
			}
		}

		protected override void OnBarUpdate()
		{
			spread[0]	= ema1[0] - ema2[0];
			rs[0] 		= rsi[0];
			Value[0] 	= sma[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "EMA1", GroupName = "NinjaScriptParameters", Order = 0)]
		public int EMA1
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "EMA2", GroupName = "NinjaScriptParameters", Order = 1)]
		public int EMA2
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Length", GroupName = "NinjaScriptParameters", Order = 2)]
		public int Length
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private RSS[] cacheRSS;
		public RSS RSS(int eMA1, int eMA2, int length)
		{
			return RSS(Input, eMA1, eMA2, length);
		}

		public RSS RSS(ISeries<double> input, int eMA1, int eMA2, int length)
		{
			if (cacheRSS != null)
				for (int idx = 0; idx < cacheRSS.Length; idx++)
					if (cacheRSS[idx] != null && cacheRSS[idx].EMA1 == eMA1 && cacheRSS[idx].EMA2 == eMA2 && cacheRSS[idx].Length == length && cacheRSS[idx].EqualsInput(input))
						return cacheRSS[idx];
			return CacheIndicator<RSS>(new RSS(){ EMA1 = eMA1, EMA2 = eMA2, Length = length }, input, ref cacheRSS);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.RSS RSS(int eMA1, int eMA2, int length)
		{
			return indicator.RSS(Input, eMA1, eMA2, length);
		}

		public Indicators.RSS RSS(ISeries<double> input , int eMA1, int eMA2, int length)
		{
			return indicator.RSS(input, eMA1, eMA2, length);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.RSS RSS(int eMA1, int eMA2, int length)
		{
			return indicator.RSS(Input, eMA1, eMA2, length);
		}

		public Indicators.RSS RSS(ISeries<double> input , int eMA1, int eMA2, int length)
		{
			return indicator.RSS(input, eMA1, eMA2, length);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The RVI (Relative Volatility Index) was developed by Donald Dorsey as a compliment to and a confirmation of momentum based indicators. When used to confirm other signals, only buy when the RVI is over 50 and only sell when the RVI is under 50.
	/// </summary>
	public class RVI : Indicator
	{
		private double			dnAvgH;
		private double			dnAvgL;
		private double			upAvgH;
		private double			upAvgL;
		private double			lastDnAvgH;
		private double			lastDnAvgL;
		private double			lastUpAvgH;
		private double			lastUpAvgL;
		private Series<double>	dnAvgHSeries;
		private Series<double>	dnAvgLSeries;
		private Series<double>	upAvgHSeries;
		private Series<double>	upAvgLSeries;
		private int				savedCurrentBar;
		private StdDev			stdDevHigh;
		private StdDev			stdDevLow;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionRVI;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRVI;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				IsOverlay					= false;

				AddPlot(Brushes.Goldenrod,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameRVI);
				AddLine(Brushes.DarkGray,	50,	NinjaTrader.Custom.Resource.RVISignalLine);
			}

			else if (State == State.Configure)
			{
				savedCurrentBar	= -1;
				dnAvgH			= dnAvgL = upAvgH = upAvgL = lastDnAvgH
								= lastDnAvgL = lastUpAvgH = lastUpAvgL = 0;
			}
			else if (State == State.DataLoaded)
			{
				stdDevHigh	= StdDev(High, 10);
				stdDevLow	= StdDev(Low, 10);

				if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
				{
					dnAvgHSeries = new Series<double>(this);
					dnAvgLSeries = new Series<double>(this);
					upAvgHSeries = new Series<double>(this);
					upAvgLSeries = new Series<double>(this);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				Value[0] = 50;
				return;
			}

			if (CurrentBar != savedCurrentBar)
			{
				dnAvgH			= BarsArray[0].BarsType.IsRemoveLastBarSupported ? dnAvgHSeries[1] : lastDnAvgH;
				dnAvgL			= BarsArray[0].BarsType.IsRemoveLastBarSupported ? dnAvgLSeries[1] : lastDnAvgL;
				upAvgH			= BarsArray[0].BarsType.IsRemoveLastBarSupported ? upAvgHSeries[1] : lastUpAvgH;
				upAvgL			= BarsArray[0].BarsType.IsRemoveLastBarSupported ? upAvgLSeries[1] : lastUpAvgL;
				savedCurrentBar	= CurrentBar;
			}

			double high0		= High[0];
			double high1		= High[1];
			double low0			= Low[0];
			double low1			= Low[1];
			double up			= 0;
			double dn			= 0;

			// RVI(High)
			if (high0 > high1)
				up = stdDevHigh[0];
			else if (high0 < high1)
				dn = stdDevHigh[0];

			double actUpAvgH	= lastUpAvgH = (upAvgH * (Period - 1) + up) / Period;
			double actDnAvgH	= lastDnAvgH = (dnAvgH * (Period - 1) + dn) / Period;
			double rviH			= 100 * (actUpAvgH / (actUpAvgH + actDnAvgH));

			// RVI(Low)
			up = 0;
			dn = 0;

			if (low0 > low1)
				up = stdDevLow[0];
			else if (low0 < low1)
				dn = stdDevLow[0];

			double actUpAvgL	= lastUpAvgL = (upAvgL * (Period - 1) + up) / Period;
			double actDnAvgL 	= lastDnAvgL = (dnAvgL * (Period - 1) + dn) / Period;
			double rviL 		= 100 * (actUpAvgL / (actUpAvgL + actDnAvgL));

			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				dnAvgHSeries[0] = actDnAvgH;
				dnAvgLSeries[0] = actDnAvgL;
				upAvgHSeries[0] = actUpAvgH;
				upAvgLSeries[0] = actUpAvgL;
			}

			if(CurrentBar == 1)
				Value[0] = 50;
			else
				Value[0] = (rviH + rviL) / 2;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private RVI[] cacheRVI;
		public RVI RVI(int period)
		{
			return RVI(Input, period);
		}

		public RVI RVI(ISeries<double> input, int period)
		{
			if (cacheRVI != null)
				for (int idx = 0; idx < cacheRVI.Length; idx++)
					if (cacheRVI[idx] != null && cacheRVI[idx].Period == period && cacheRVI[idx].EqualsInput(input))
						return cacheRVI[idx];
			return CacheIndicator<RVI>(new RVI(){ Period = period }, input, ref cacheRVI);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.RVI RVI(int period)
		{
			return indicator.RVI(Input, period);
		}

		public Indicators.RVI RVI(ISeries<double> input , int period)
		{
			return indicator.RVI(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.RVI RVI(int period)
		{
			return indicator.RVI(Input, period);
		}

		public Indicators.RVI RVI(ISeries<double> input , int period)
		{
			return indicator.RVI(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX;
using SharpDX.Direct2D1;
using SharpDX.DirectWrite;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
public class SampleCustomRender : Indicator
{
		// These are WPF Brushes which are pushed and exposed to the UI by default
		// And allow users to configure a custom value of their choice
		// We will later convert the user defined brush from the UI to SharpDX Brushes for rendering purposes
		private System.Windows.Media.Brush	areaBrush;
		private System.Windows.Media.Brush	textBrush;
		private System.Windows.Media.Brush	smallAreaBrush;
		private int							areaOpacity;
		private SMA							mySma;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionSampleCustomRender;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSampleCustomRender;
				Calculate					= Calculate.OnBarClose;
				DisplayInDataBox			= false;
				IsOverlay					= true;
				IsChartOnly					= true;
				IsSuspendedWhileInactive	= true;
				ScaleJustification			= ScaleJustification.Right;
				AreaBrush = System.Windows.Media.Brushes.DodgerBlue;
				TextBrush = System.Windows.Media.Brushes.DodgerBlue;
				SmallAreaBrush = System.Windows.Media.Brushes.Crimson;
				AreaOpacity = 20;
				AddPlot(System.Windows.Media.Brushes.Crimson, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSampleCustomRender);
			}
			else if (State == State.DataLoaded)
			{
				mySma = SMA(20);
			}
			else if (State == State.Historical)
			{
				SetZOrder(-1); // default here is go below the bars and called in State.Historical
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = mySma[0];
		}

	protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
	{

		// This sample should be used along side the help guide educational resource on this topic:
		// http://www.ninjatrader.com/support/helpGuides/nt8/en-us/?using_sharpdx_for_custom_chart_rendering.htm

		// Default plotting in base class. Uncomment if indicators holds at least one plot
		// in this case we would expect NOT to see the SMA plot we have as well in this sample script
		//base.OnRender(chartControl, chartScale);

		// 1.1 - SharpDX Vectors and Charting RenderTarget Coordinates

		// The SharpDX SDK uses "Vector2" objects to describe a two-dimensional point of a device (X and Y coordinates)
		SharpDX.Vector2 startPoint;
		SharpDX.Vector2 endPoint;

		// For our custom script, we need a way to determine the Chart's RenderTarget coordinates to draw our custom shapes
		// This info can be found within the NinjaTrader.Gui.ChartPanel class.
		// You can also use various chartScale and chartControl members to calculate values relative to time and price
		// However, those concepts will not be discussed or used in this sample
		// Notes:  RenderTarget is always the full ChartPanel, so we need to be mindful which sub-ChartPanel we're dealing with
		// Always use ChartPanel X, Y, W, H - as chartScale and chartControl properties WPF units, so they can be drastically different depending on DPI set
		startPoint = new SharpDX.Vector2(ChartPanel.X, ChartPanel.Y);
		endPoint = new SharpDX.Vector2(ChartPanel.X + ChartPanel.W, ChartPanel.Y + ChartPanel.H);

		// These Vector2 objects are equivalent with WPF System.Windows.Point and can be used interchangeably depending on your requirements
		// For convenience, NinjaTrader provides a "ToVector2()" extension method to convert from WPF Points to SharpDX.Vector2
		SharpDX.Vector2 startPoint1 = new System.Windows.Point(ChartPanel.X, ChartPanel.Y + ChartPanel.H).ToVector2();
		SharpDX.Vector2 endPoint1 = new System.Windows.Point(ChartPanel.X + ChartPanel.W, ChartPanel.Y).ToVector2();

		// SharpDX.Vector2 objects contain X/Y properties which are helpful to recalculate new properties based on the initial vector
		float width = endPoint.X - startPoint.X;
		float height = endPoint.Y - startPoint.Y;

		// Or you can recalculate a new vector from existing vector objects
		SharpDX.Vector2 center = (startPoint + endPoint) / 2;

		// Tip: This check is simply added to prevent the Indicator dialog menu from opening as a user clicks on the chart
		// The default behavior is to open the Indicator dialog menu if a user double clicks on the indicator
		// (i.e, the indicator falls within the RenderTarget "hit testing")
		// You can remove this check if you want the default behavior implemented
		if (!IsInHitTest)
		{
			// 1.2 - SharpDX Brush Resources

			// RenderTarget commands must use a special brush resource defined in the SharpDX.Direct2D1 namespace
			// These resources exist just like you will find in the WPF/Windows.System.Media namespace
			// such as SolidColorBrushes, LienarGraidentBrushes, RadialGradientBrushes, etc.
			// To begin, we will start with the most basic "Brush" type
			// Warning:  Brush objects must be disposed of after they have been used
			SharpDX.Direct2D1.Brush areaBrushDx;
			SharpDX.Direct2D1.Brush smallAreaBrushDx;
			SharpDX.Direct2D1.Brush textBrushDx;

			// for convenience, you can simply convert a WPF Brush to a DXBrush using the ToDxBrush() extension method provided by NinjaTrader
			// This is a common approach if you have a Brush property created e.g., on the UI you wish to use in custom rendering routines
			areaBrushDx = areaBrush.ToDxBrush(RenderTarget);
			smallAreaBrushDx = smallAreaBrush.ToDxBrush(RenderTarget);
			textBrushDx = textBrush.ToDxBrush(RenderTarget);

			// However - it should be noted that this conversion process can be rather expensive
			// If you have many brushes being created, and are not tied to WPF resources
			// You should rather favor creating the SharpDX Brush directly:
			// Warning:  SolidColorBrush objects must be disposed of after they have been used
			SharpDX.Direct2D1.SolidColorBrush customDXBrush = new SharpDX.Direct2D1.SolidColorBrush(RenderTarget,
				SharpDX.Color.DodgerBlue);

			// 1.3 - Using The RenderTarget
			// before executing chart commands, you have the ability to describe how the RenderTarget should render
			// for example, we can store the existing RenderTarget AntialiasMode mode
			// then update the AntialiasMode to be the quality of non-text primitives are rendered
			SharpDX.Direct2D1.AntialiasMode oldAntialiasMode = RenderTarget.AntialiasMode;
			RenderTarget.AntialiasMode = SharpDX.Direct2D1.AntialiasMode.Aliased;

			// Note: The code above stores the oldAntialiasMode as a best practices
			// i.e., if you plan on changing a property of the RenderTarget, you should plan to set it back
			// This is to make sure your requirements to no interfere with the function of another script
			// Additionally smoothing has some performance impacts

			// Once you have defined all the necessary requirements for you object
			//  You can execute a command on the RenderTarget to draw specific shapes
			// e.g., we can now use the RenderTarget's DrawLine() command to render a line
			// using the start/end points and areaBrushDx objects defined before
			RenderTarget.DrawLine(startPoint, endPoint, areaBrushDx, 4);

			// Since rendering occurs in a sequential fashion, after you have executed a command
			// you can switch a property of the RenderTarget to meet other requirements
			// For example, we can draw a second line now which uses a different AntialiasMode
			// and the changes render on the chart for both lines from the time they received commands
			RenderTarget.AntialiasMode = SharpDX.Direct2D1.AntialiasMode.PerPrimitive;
			RenderTarget.DrawLine(startPoint1, endPoint1, areaBrushDx, 4);

			// 1.4 - Rendering Custom Shapes

			// SharpDX namespace consists of several shapes you can use to draw objects more complicated than lines
			// For example, we can use the RectangleF object to draw a rectangle that covers the entire chart area
			SharpDX.RectangleF rect = new SharpDX.RectangleF(startPoint.X, startPoint.Y, width, height);

			// The RenderTarget consists of two commands related to Rectangles.
			// The FillRectangle() method is used to "Paint" the area of a Rectangle
			RenderTarget.FillRectangle(rect, areaBrushDx);

			// and DrawRectangle() is used to "Paint" the outline of a Rectangle
			RenderTarget.DrawRectangle(rect, customDXBrush, 2);

			// Another example is an ellipse which can be used to draw circles
			// The ellipse center point can be used from the Vectors calculated earlier
			// The width and height an absolute 100 device pixels
			// To ensure that pixel coordinates work across all DPI devices, we use the NinjaTrader ChartingExteions methods
			// Which will convert the "100" value from WPF pixels to Device Pixels both vertically and horizontally
			int ellipseRadiusY = ChartingExtensions.ConvertToVerticalPixels(100, ChartControl.PresentationSource);
			int ellipseRadiusX = ChartingExtensions.ConvertToHorizontalPixels(100, ChartControl.PresentationSource);

			SharpDX.Direct2D1.Ellipse ellipse = new SharpDX.Direct2D1.Ellipse(center, ellipseRadiusX, ellipseRadiusY);

			// 1.5 - Complex Brush Types and Shapes
			// For this ellipse, we can use one of the more complex brush types "RadialGradientBrush"
			// Warning:  RadialGradientBrush objects must be disposed of after they have been used
			SharpDX.Direct2D1.RadialGradientBrush radialGradientBrush;

			// However creating a RadialGradientBrush requires a few more properties than SolidColorBrush
			// First, you need to define the array gradient stops the brush will eventually use
			SharpDX.Direct2D1.GradientStop[] gradientStops = new SharpDX.Direct2D1.GradientStop[2];

			// With the gradientStops array, we can describe the color and position of the individual gradients
			gradientStops[0].Color = SharpDX.Color.Goldenrod;
			gradientStops[0].Position = 0.0f;
			gradientStops[1].Color = SharpDX.Color.SeaGreen;
			gradientStops[1].Position = 1.0f;

			// then declare a GradientStopCollection from our render target that uses the gradientStops array defined just before
			// Warning:  GradientStopCollection objects must be disposed of after they have been used
			SharpDX.Direct2D1.GradientStopCollection gradientStopCollection =
				new SharpDX.Direct2D1.GradientStopCollection(RenderTarget, gradientStops);

			// we also need to tell our RadialGradientBrush to match the size and shape of the ellipse that we will be drawing
			// for convenience, SharpDX provides a RadialGradientBrushProperties structure to help define these properties
			SharpDX.Direct2D1.RadialGradientBrushProperties radialGradientBrushProperties =
				new SharpDX.Direct2D1.RadialGradientBrushProperties
				{
					GradientOriginOffset = new SharpDX.Vector2(0, 0),
					Center = ellipse.Point,
					RadiusX = ellipse.RadiusY,
					RadiusY = ellipse.RadiusY
				};

			// we now have everything we need to create a radial gradient brush
			radialGradientBrush = new SharpDX.Direct2D1.RadialGradientBrush(RenderTarget, radialGradientBrushProperties,
				gradientStopCollection);

			// Finally, we can use this radialGradientBrush to "Paint" the area of the ellipse
			RenderTarget.FillEllipse(ellipse, radialGradientBrush);

			// 1.6 - Simple Text Rendering

			// For rendering custom text to the Chart, there are a few ways you can approach depending on your requirements
			// The most straight forward way is to "borrow" the existing chartControl font provided as a "SimpleFont" class
			// Using the chartControl LabelFont, your custom object will also change to the user defined properties allowing
			// your object to match different fonts if defined by user.

			// The code below will use the chartControl Properties Label Font if it exists,
			// or fall back to a default property if it cannot obtain that value
			NinjaTrader.Gui.Tools.SimpleFont simpleFont = chartControl.Properties.LabelFont ??  new NinjaTrader.Gui.Tools.SimpleFont("Arial", 12);

			// the advantage of using a SimpleFont is they are not only very easy to describe
			// but there is also a convenience method which can be used to convert the SimpleFont to a SharpDX.DirectWrite.TextFormat used to render to the chart
			// Warning:  TextFormat objects must be disposed of after they have been used
			SharpDX.DirectWrite.TextFormat textFormat1 = simpleFont.ToDirectWriteTextFormat();

			// Once you have the format of the font, you need to describe how the font needs to be laid out
			// Here we will create a new Vector2() which draws the font according to the to top left corner of the chart (offset by a few pixels)
			SharpDX.Vector2 upperTextPoint = new SharpDX.Vector2(ChartPanel.X + 10, ChartPanel.Y + 20);
			// Warning:  TextLayout objects must be disposed of after they have been used
			SharpDX.DirectWrite.TextLayout textLayout1 =
				new SharpDX.DirectWrite.TextLayout(NinjaTrader.Core.Globals.DirectWriteFactory,
					NinjaTrader.Custom.Resource.SampleCustomPlotUpperLeftCorner, textFormat1, ChartPanel.X + ChartPanel.W,
					textFormat1.FontSize);

			// With the format and layout of the text completed, we can now render the font to the chart
			RenderTarget.DrawTextLayout(upperTextPoint, textLayout1, textBrushDx,
				SharpDX.Direct2D1.DrawTextOptions.NoSnap);

			// 1.7 - Advanced Text Rendering

			// Font formatting and text layouts can get as complex as you need them to be
			// This example shows how to use a complete custom font unrelated to the existing user-defined chart control settings
			// Warning:  TextLayout and TextFormat objects must be disposed of after they have been used
			SharpDX.DirectWrite.TextFormat textFormat2 =
				new SharpDX.DirectWrite.TextFormat(NinjaTrader.Core.Globals.DirectWriteFactory, "Century Gothic", FontWeight.Bold,
					FontStyle.Italic, 32f);
			SharpDX.DirectWrite.TextLayout textLayout2 =
				new SharpDX.DirectWrite.TextLayout(NinjaTrader.Core.Globals.DirectWriteFactory,
					NinjaTrader.Custom.Resource.SampleCustomPlotLowerRightCorner, textFormat2, 400, textFormat1.FontSize);

			// the textLayout object provides a way to measure the described font through a "Metrics" object
			// This allows you to create new vectors on the chart which are entirely dependent on the "text" that is being rendered
			// For example, we can create a rectangle that surrounds our font based off the textLayout which would dynamically change if the text used in the layout changed dynamically
			SharpDX.Vector2 lowerTextPoint = new SharpDX.Vector2(ChartPanel.W - textLayout2.Metrics.Width - 5,
				ChartPanel.Y + (ChartPanel.H - textLayout2.Metrics.Height));
			SharpDX.RectangleF rect1 = new SharpDX.RectangleF(lowerTextPoint.X, lowerTextPoint.Y, textLayout2.Metrics.Width,
				textLayout2.Metrics.Height);

			// We can draw the Rectangle based on the TextLayout used above
			RenderTarget.FillRectangle(rect1, smallAreaBrushDx);
			RenderTarget.DrawRectangle(rect1, smallAreaBrushDx, 2);

			// And render the advanced text layout using the DrawTextLayout() method
			// Note:  When drawing the same text repeatedly, using the DrawTextLayout() method is more efficient than using the DrawText()
			// because the text doesn't need to be formatted and the layout processed with each call
			RenderTarget.DrawTextLayout(lowerTextPoint, textLayout2, textBrushDx, SharpDX.Direct2D1.DrawTextOptions.NoSnap);

			// 1.8 - Cleanup
			// This concludes all of the rendering concepts used in the sample
			// However - there are some final clean up processes we should always provided before we are done

			// If changed, do not forget to set the AntialiasMode back to the default value as described above as a best practice
			RenderTarget.AntialiasMode = oldAntialiasMode;

			// We also need to make sure to dispose of every device dependent resource on each render pass
			// Failure to dispose of these resources will eventually result in unnecessary amounts of memory being used on the chart
			// Although the effects might not be obvious as first, if you see issues related to memory increasing over time
			// Objects such as these should be inspected first
			areaBrushDx.Dispose();
			customDXBrush.Dispose();
			gradientStopCollection.Dispose();
			radialGradientBrush.Dispose();
			smallAreaBrushDx.Dispose();
			textBrushDx.Dispose();
			textFormat1.Dispose();
			textFormat2.Dispose();
			textLayout1.Dispose();
			textLayout2.Dispose();
		}
	}

	#region Properties
	[XmlIgnore]
	[Display(ResourceType = typeof(Custom.Resource), Name = "NinjaScriptDrawingToolShapesAreaBrush", GroupName = "NinjaScriptGeneral")]
	public System.Windows.Media.Brush AreaBrush
	{
		get { return areaBrush; }
		set
		{
			areaBrush = value;
			if (areaBrush != null)
			{
				if (areaBrush.IsFrozen)
					areaBrush = areaBrush.Clone();
				areaBrush.Opacity = areaOpacity / 100d;
				areaBrush.Freeze();
			}
		}
	}

	[Browsable(false)]
	public string AreaBrushSerialize
	{
		get { return Serialize.BrushToString(AreaBrush); }
		set { AreaBrush = Serialize.StringToBrush(value); }
	}

	[Range(0, 100)]
	[Display(ResourceType = typeof(Custom.Resource), Name = "NinjaScriptDrawingToolAreaOpacity", GroupName = "NinjaScriptGeneral")]
	public int AreaOpacity
	{
		get { return areaOpacity; }
		set
		{
			areaOpacity = Math.Max(0, Math.Min(100, value));
			if (areaBrush != null)
			{
				System.Windows.Media.Brush newBrush		= areaBrush.Clone();
				newBrush.Opacity	= areaOpacity / 100d;
				newBrush.Freeze();
				areaBrush			= newBrush;
			}
		}
	}

	[XmlIgnore]
	[Display(ResourceType = typeof(Custom.Resource), Name = "SmallAreaColor", GroupName = "NinjaScriptGeneral")]
	public System.Windows.Media.Brush SmallAreaBrush
	{
		get { return smallAreaBrush; }
		set { smallAreaBrush = value; }
	}

	[Browsable(false)]
	public string SmallAreaBrushSerialize
	{
		get { return Serialize.BrushToString(SmallAreaBrush); }
		set { SmallAreaBrush = Serialize.StringToBrush(value); }
	}

	[Browsable(false)]
	[XmlIgnore]
	public Series<double> TestPlot
	{
		get { return Values[0]; }
	}

	[XmlIgnore]
	[Display(ResourceType = typeof(Custom.Resource), Name = "TextColor", GroupName = "NinjaScriptGeneral")]
	public System.Windows.Media.Brush TextBrush
	{
		get { return textBrush; }
		set { textBrush = value; }
	}

	[Browsable(false)]
	public string TextBrushSerialize
	{
		get { return Serialize.BrushToString(TextBrush); }
		set { TextBrush = Serialize.StringToBrush(value); }
	}
	#endregion
}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SampleCustomRender[] cacheSampleCustomRender;
		public SampleCustomRender SampleCustomRender()
		{
			return SampleCustomRender(Input);
		}

		public SampleCustomRender SampleCustomRender(ISeries<double> input)
		{
			if (cacheSampleCustomRender != null)
				for (int idx = 0; idx < cacheSampleCustomRender.Length; idx++)
					if (cacheSampleCustomRender[idx] != null &&  cacheSampleCustomRender[idx].EqualsInput(input))
						return cacheSampleCustomRender[idx];
			return CacheIndicator<SampleCustomRender>(new SampleCustomRender(), input, ref cacheSampleCustomRender);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SampleCustomRender SampleCustomRender()
		{
			return indicator.SampleCustomRender(Input);
		}

		public Indicators.SampleCustomRender SampleCustomRender(ISeries<double> input )
		{
			return indicator.SampleCustomRender(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SampleCustomRender SampleCustomRender()
		{
			return indicator.SampleCustomRender(Input);
		}

		public Indicators.SampleCustomRender SampleCustomRender(ISeries<double> input )
		{
			return indicator.SampleCustomRender(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The SMA (Simple Moving Average) is an indicator that shows the average value of a security's price over a period of time.
	/// </summary>
	public class SMA : Indicator
	{
		private double priorSum;
		private double sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionSMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA);
			}
			else if (State == State.Configure)
			{
				priorSum	= 0;
				sum			= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				if (CurrentBar == 0)
					Value[0] = Input[0];
				else
				{
					double last = Value[1] * Math.Min(CurrentBar, Period);

					if (CurrentBar >= Period)
						Value[0] = (last + Input[0] - Input[Period]) / Math.Min(CurrentBar, Period);
					else
						Value[0] = ((last + Input[0]) / (Math.Min(CurrentBar, Period) + 1));
				}
			}
			else
			{
				if (IsFirstTickOfBar)
					priorSum = sum;

				sum = priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);
				Value[0] = sum / (CurrentBar < Period ? CurrentBar + 1 : Period);
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SMA[] cacheSMA;
		public SMA SMA(int period)
		{
			return SMA(Input, period);
		}

		public SMA SMA(ISeries<double> input, int period)
		{
			if (cacheSMA != null)
				for (int idx = 0; idx < cacheSMA.Length; idx++)
					if (cacheSMA[idx] != null && cacheSMA[idx].Period == period && cacheSMA[idx].EqualsInput(input))
						return cacheSMA[idx];
			return CacheIndicator<SMA>(new SMA(){ Period = period }, input, ref cacheSMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Standard Deviation is a statistical measure of volatility.
	/// Standard Deviation is typically used as a component of other indicators,
	/// rather than as a stand-alone indicator. For example, Bollinger Bands are
	/// calculated by adding a security's Standard Deviation to a moving average.
	/// </summary>
	public class StdDev : Indicator
	{
		private Series<double> sumSeries;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionStdDev;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameStdDev;
				IsOverlay					= false;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.DarkCyan, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameStdDev);
			}
			else if (State == State.DataLoaded)
			{
				sumSeries = new Series<double>(this, Period <= 256 ? MaximumBarsLookBack.TwoHundredFiftySix : MaximumBarsLookBack.Infinite);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < 1)
			{
				Value[0] = 0;
				sumSeries[0] = Input[0];
			}
			else
			{
				sumSeries[0] = Input[0] + sumSeries[1] - (CurrentBar >= Period ? Input[Period] : 0);
				double avg = sumSeries[0] / Math.Min(CurrentBar + 1, Period);
				double sum = 0;
				for (int barsBack = Math.Min(CurrentBar, Period - 1); barsBack >= 0; barsBack--)
					sum += (Input[barsBack] - avg) * (Input[barsBack] - avg);

				Value[0] = Math.Sqrt(sum / Math.Min(CurrentBar + 1, Period));
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private StdDev[] cacheStdDev;
		public StdDev StdDev(int period)
		{
			return StdDev(Input, period);
		}

		public StdDev StdDev(ISeries<double> input, int period)
		{
			if (cacheStdDev != null)
				for (int idx = 0; idx < cacheStdDev.Length; idx++)
					if (cacheStdDev[idx] != null && cacheStdDev[idx].Period == period && cacheStdDev[idx].EqualsInput(input))
						return cacheStdDev[idx];
			return CacheIndicator<StdDev>(new StdDev(){ Period = period }, input, ref cacheStdDev);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.StdDev StdDev(int period)
		{
			return indicator.StdDev(Input, period);
		}

		public Indicators.StdDev StdDev(ISeries<double> input , int period)
		{
			return indicator.StdDev(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.StdDev StdDev(int period)
		{
			return indicator.StdDev(Input, period);
		}

		public Indicators.StdDev StdDev(ISeries<double> input , int period)
		{
			return indicator.StdDev(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Standard Error shows how near prices go around a linear regression line.
	/// </summary>
	public class StdError : Indicator
	{
		// Documentation of Linear Regression: http://en.wikipedia.org/wiki/Linear_regression
		// Documentation of Standard Error: http://tadoc.org/indicator/STDERR.htm
		private double			avg;
		private double			divisor;
		private	double			intercept;
		private double			myPeriod;
		private double			priorSumXY;
		private	double			priorSumY;
		private double			slope;
		private double			sumX2;
		private	double			sumX;
		private double			sumXY;
		private double			sumY;
		private SUM				sum;
		private Series<double>	y;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionStdError;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameStdError;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				IsOverlay					= true;

				AddPlot(Brushes.Goldenrod,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameLinReg);
				AddPlot(Brushes.DarkCyan,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
				AddPlot(Brushes.DarkCyan,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
			}
			else if (State == State.Configure)
			{
				avg	= divisor = intercept = myPeriod = priorSumXY
					= priorSumY = slope = sumX = sumX2 = sumY = sumXY = 0;
			}
			else if (State == State.DataLoaded)
			{
				y	= new Series<double>(this);
				sum = SUM(Inputs[0], Period);
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				// calculate Linear Regression
				double sumX = (double)Period * (Period - 1) * 0.5;
				double divisor = sumX * sumX - (double)Period * Period * (Period - 1) * (2 * Period - 1) / 6;
				double sumXY = 0;

				for (int count = 0; count < Period && CurrentBar - count >= 0; count++)
					sumXY += count * Input[count];

				y[0] = Input[0];
				double slope = ((double)Period * sumXY - sumX * SUM(y, Period)[0]) / divisor;
				double intercept = (SUM(y, Period)[0] - slope * sumX) / Period;
				double linReg = intercept + slope * (Period - 1);

				// Calculate Standard Error
				double sumSquares = 0;
				for (int count = 0; count < Period && CurrentBar - count >= 0; count++)
				{
					double linRegX = intercept + slope * (Period - 1 - count);
					double valueX = Input[count];
					double diff = Math.Abs(valueX - linRegX);

					sumSquares += diff * diff;
				}
				double stdErr = Math.Sqrt(sumSquares / Period);

				Middle[0]	= linReg;
				Upper[0]	= linReg + stdErr;
				Lower[0]	= linReg - stdErr;
			}
			else
			{
				if (IsFirstTickOfBar)
				{
					priorSumY = sumY;
					priorSumXY = sumXY;
					myPeriod = Math.Min(CurrentBar + 1, Period);
					sumX = myPeriod * (myPeriod - 1) * 0.5;
					sumX2 = myPeriod * (myPeriod + 1) * 0.5;
					divisor = myPeriod != 1 ? myPeriod * (myPeriod + 1) * (2 * myPeriod + 1) / 6 - sumX2 * sumX2 / myPeriod : 1.0;
				}

				double input0 = Input[0];
				sumXY = priorSumXY - (CurrentBar >= Period ? priorSumY : 0) + myPeriod * input0;
				sumY = priorSumY + input0 - (CurrentBar >= Period ? Input[Period] : 0);
				avg = myPeriod != 0 ? sumY / myPeriod : 0.0;
				slope = (sumXY - sumX2 * avg) / divisor;
				intercept = myPeriod != 0 ? (sum[0] - slope * sumX) / myPeriod : 0.0;
				double linReg = (intercept + slope * (myPeriod - 1));

				// Calculate Standard Error
				double sumSquares = 0;
				for (int count = 0; count < Period && CurrentBar - count >= 0; count++)
				{
					double linRegX = intercept + slope * (Period - 1 - count);
					double valueX = Input[count];
					double diff = Math.Abs(valueX - linRegX);
					sumSquares += diff * diff;
				}

				double stdErr = Math.Sqrt(sumSquares / Period);
				Middle[0] = CurrentBar == 0 ? input0 : linReg;
				Upper[0] = CurrentBar == 0 ? input0 : linReg + stdErr;
				Lower[0] = CurrentBar == 0 ? input0 : linReg - stdErr;
			}
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Lower
		{
			get { return Values[2]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Middle
		{
			get { return Values[0]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Upper
		{
			get { return Values[1]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private StdError[] cacheStdError;
		public StdError StdError(int period)
		{
			return StdError(Input, period);
		}

		public StdError StdError(ISeries<double> input, int period)
		{
			if (cacheStdError != null)
				for (int idx = 0; idx < cacheStdError.Length; idx++)
					if (cacheStdError[idx] != null && cacheStdError[idx].Period == period && cacheStdError[idx].EqualsInput(input))
						return cacheStdError[idx];
			return CacheIndicator<StdError>(new StdError(){ Period = period }, input, ref cacheStdError);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.StdError StdError(int period)
		{
			return indicator.StdError(Input, period);
		}

		public Indicators.StdError StdError(ISeries<double> input , int period)
		{
			return indicator.StdError(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.StdError StdError(int period)
		{
			return indicator.StdError(Input, period);
		}

		public Indicators.StdError StdError(ISeries<double> input , int period)
		{
			return indicator.StdError(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Stochastic Oscillator is made up of two lines that oscillate between
	/// a vertical scale of 0 to 100. The %K is the main line and it is drawn as
	/// a solid line. The second is the %D line and is a moving average of %K.
	/// The %D line is drawn as a dotted line. Use as a buy/sell signal generator,
	/// buying when fast moves above slow and selling when fast moves below slow.
	/// </summary>
	public class Stochastics : Indicator
	{
		private Series<double>		den;
		private Series<double>		fastK;
		private MIN					min;
		private MAX					max;
		private Series<double>		nom;
		private SMA					smaFastK;
		private SMA					smaK;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionStochastics;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameStochastics;
				IsSuspendedWhileInactive	= true;
				PeriodD						= 7;
				PeriodK						= 14;
				Smooth						= 3;

				AddPlot(Brushes.DodgerBlue,		NinjaTrader.Custom.Resource.StochasticsD);
				AddPlot(Brushes.Goldenrod,		NinjaTrader.Custom.Resource.StochasticsK);

				AddLine(Brushes.DarkCyan,	20,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.DarkCyan,	80,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
			else if (State == State.DataLoaded)
			{
				den			= new Series<double>(this);
				nom			= new Series<double>(this);
				fastK		= new Series<double>(this);
				min			= MIN(Low, PeriodK);
				max			= MAX(High, PeriodK);
				smaFastK	= SMA(fastK, Smooth);
				smaK		= SMA(K, PeriodD);
			}
		}

		protected override void OnBarUpdate()
		{
			double min0 = min[0];
			nom[0]		= Close[0] - min0;
			den[0]		= max[0] - min0;

			if (den[0].ApproxCompare(0) == 0)
				fastK[0] = CurrentBar == 0 ? 50 : fastK[1];
			else
				fastK[0] = Math.Min(100, Math.Max(0, 100 * nom[0] / den[0]));

			// Slow %K == Fast %D
			K[0] = smaFastK[0];
			D[0] = smaK[0];
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> D
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> K
		{
			get { return Values[1]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "PeriodD", GroupName = "NinjaScriptParameters", Order = 0)]
		public int PeriodD
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "PeriodK", GroupName = "NinjaScriptParameters", Order = 1)]
		public int PeriodK
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 2)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Stochastics[] cacheStochastics;
		public Stochastics Stochastics(int periodD, int periodK, int smooth)
		{
			return Stochastics(Input, periodD, periodK, smooth);
		}

		public Stochastics Stochastics(ISeries<double> input, int periodD, int periodK, int smooth)
		{
			if (cacheStochastics != null)
				for (int idx = 0; idx < cacheStochastics.Length; idx++)
					if (cacheStochastics[idx] != null && cacheStochastics[idx].PeriodD == periodD && cacheStochastics[idx].PeriodK == periodK && cacheStochastics[idx].Smooth == smooth && cacheStochastics[idx].EqualsInput(input))
						return cacheStochastics[idx];
			return CacheIndicator<Stochastics>(new Stochastics(){ PeriodD = periodD, PeriodK = periodK, Smooth = smooth }, input, ref cacheStochastics);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Stochastics Stochastics(int periodD, int periodK, int smooth)
		{
			return indicator.Stochastics(Input, periodD, periodK, smooth);
		}

		public Indicators.Stochastics Stochastics(ISeries<double> input , int periodD, int periodK, int smooth)
		{
			return indicator.Stochastics(input, periodD, periodK, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Stochastics Stochastics(int periodD, int periodK, int smooth)
		{
			return indicator.Stochastics(Input, periodD, periodK, smooth);
		}

		public Indicators.Stochastics Stochastics(ISeries<double> input , int periodD, int periodK, int smooth)
		{
			return indicator.Stochastics(input, periodD, periodK, smooth);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Stochastic Oscillator is made up of two lines that oscillate between
	/// a vertical scale of 0 to 100. The %K is the main line and it is drawn as
	/// a solid line. The second is the %D line and is a moving average of %K.
	/// The %D line is drawn as a dotted line. Use as a buy/sell signal generator,
	/// buying when fast moves above slow and selling when fast moves below slow.
	/// </summary>
	public class StochasticsFast : Indicator
	{
		private Series<double>			den;
		private MAX						max;
		private MIN						min;
		private Series<double>			nom;
		private SMA						smaK;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionStochasticsFast;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameStochasticsFast;
				IsSuspendedWhileInactive	= true;
				PeriodD						= 3;
				PeriodK						= 14;

				AddPlot(Brushes.DodgerBlue,		NinjaTrader.Custom.Resource.StochasticsD);
				AddPlot(Brushes.Goldenrod,		NinjaTrader.Custom.Resource.StochasticsK);
				AddLine(Brushes.DarkCyan,	20,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddLine(Brushes.DarkCyan,	80,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
			}
			else if (State == State.DataLoaded)
			{
				den			= new Series<double>(this);
				nom			= new Series<double>(this);
				min			= MIN(Low, PeriodK);
				max			= MAX(High, PeriodK);
				smaK		= SMA(K, PeriodD);
			}
		}

		protected override void OnBarUpdate()
		{
			double min0	= min[0];
			nom[0]		= Close[0] - min0;
			den[0]		= max[0] - min0;

			if (den[0].ApproxCompare(0) == 0)
				K[0] = CurrentBar == 0 ? 50 : K[1];
			else
				K[0] = Math.Min(100, Math.Max(0, 100 * nom[0] / den[0]));

			D[0] = smaK[0];
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> D
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> K
		{
			get { return Values[1]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "PeriodD", GroupName = "NinjaScriptParameters", Order = 0)]
		public int PeriodD
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "PeriodK", GroupName = "NinjaScriptParameters", Order = 1)]
		public int PeriodK
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private StochasticsFast[] cacheStochasticsFast;
		public StochasticsFast StochasticsFast(int periodD, int periodK)
		{
			return StochasticsFast(Input, periodD, periodK);
		}

		public StochasticsFast StochasticsFast(ISeries<double> input, int periodD, int periodK)
		{
			if (cacheStochasticsFast != null)
				for (int idx = 0; idx < cacheStochasticsFast.Length; idx++)
					if (cacheStochasticsFast[idx] != null && cacheStochasticsFast[idx].PeriodD == periodD && cacheStochasticsFast[idx].PeriodK == periodK && cacheStochasticsFast[idx].EqualsInput(input))
						return cacheStochasticsFast[idx];
			return CacheIndicator<StochasticsFast>(new StochasticsFast(){ PeriodD = periodD, PeriodK = periodK }, input, ref cacheStochasticsFast);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.StochasticsFast StochasticsFast(int periodD, int periodK)
		{
			return indicator.StochasticsFast(Input, periodD, periodK);
		}

		public Indicators.StochasticsFast StochasticsFast(ISeries<double> input , int periodD, int periodK)
		{
			return indicator.StochasticsFast(input, periodD, periodK);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.StochasticsFast StochasticsFast(int periodD, int periodK)
		{
			return indicator.StochasticsFast(Input, periodD, periodK);
		}

		public Indicators.StochasticsFast StochasticsFast(ISeries<double> input , int periodD, int periodK)
		{
			return indicator.StochasticsFast(input, periodD, periodK);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The StochRSI is an oscillator similar in computation to the stochastic measure,
	/// except instead of price values as input, the StochRSI uses RSI values.
	/// The StochRSI computes the current position of the RSI relative to the high and
	/// low RSI values over a specified number of days. The intent of this measure,
	/// designed by Tushard Chande and Stanley Kroll, is to provide further information
	/// about the overbought/oversold nature of the RSI. The StochRSI ranges between 0.0 and 1.0.
	/// Values above 0.8 are generally seen to identify overbought levels and values below 0.2 are
	/// considered to indicate oversold conditions.
	/// </summary>
	public class StochRSI : Indicator
	{
		private MAX max;
		private MIN min;
		private RSI rsi;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionStochRSI;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameStochRSI;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= false;
				Period						= 14;

				AddPlot(Brushes.DarkCyan,			NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameStochRSI);

				AddLine(Brushes.Crimson,	0.8,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorOverbought);
				AddLine(Brushes.DodgerBlue,	0.5,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorNeutral);
				AddLine(Brushes.Crimson,	0.2,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorOversold);
			}
			else if (State == State.DataLoaded)
			{
				rsi = RSI(Inputs[0], Period, 1);
				min	= MIN(rsi, Period);
				max = MAX(rsi, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			double rsi0 = rsi[0];
			double rsiL = min[0];
			double rsiH = max[0];

			if (rsi0 != rsiL && rsiH != rsiL)
				Value[0] = (rsi0 - rsiL) / (rsiH - rsiL);
			else
				Value[0] = 0;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private StochRSI[] cacheStochRSI;
		public StochRSI StochRSI(int period)
		{
			return StochRSI(Input, period);
		}

		public StochRSI StochRSI(ISeries<double> input, int period)
		{
			if (cacheStochRSI != null)
				for (int idx = 0; idx < cacheStochRSI.Length; idx++)
					if (cacheStochRSI[idx] != null && cacheStochRSI[idx].Period == period && cacheStochRSI[idx].EqualsInput(input))
						return cacheStochRSI[idx];
			return CacheIndicator<StochRSI>(new StochRSI(){ Period = period }, input, ref cacheStochRSI);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.StochRSI StochRSI(int period)
		{
			return indicator.StochRSI(Input, period);
		}

		public Indicators.StochRSI StochRSI(ISeries<double> input , int period)
		{
			return indicator.StochRSI(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.StochRSI StochRSI(int period)
		{
			return indicator.StochRSI(Input, period);
		}

		public Indicators.StochRSI StochRSI(ISeries<double> input , int period)
		{
			return indicator.StochRSI(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Sum shows the summation of the last n data points.
	/// </summary>
	public class SUM : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionSUM;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSUM;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.DarkCyan, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSUM);
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = Input[0] + (CurrentBar > 0 ? Value[1] : 0) - (CurrentBar >= Period ? Input[Period] : 0);
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SUM[] cacheSUM;
		public SUM SUM(int period)
		{
			return SUM(Input, period);
		}

		public SUM SUM(ISeries<double> input, int period)
		{
			if (cacheSUM != null)
				for (int idx = 0; idx < cacheSUM.Length; idx++)
					if (cacheSUM[idx] != null && cacheSUM[idx].Period == period && cacheSUM[idx].EqualsInput(input))
						return cacheSUM[idx];
			return CacheIndicator<SUM>(new SUM(){ Period = period }, input, ref cacheSUM);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SUM SUM(int period)
		{
			return indicator.SUM(Input, period);
		}

		public Indicators.SUM SUM(ISeries<double> input , int period)
		{
			return indicator.SUM(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SUM SUM(int period)
		{
			return indicator.SUM(Input, period);
		}

		public Indicators.SUM SUM(ISeries<double> input , int period)
		{
			return indicator.SUM(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Swing indicator plots lines that represents the swing high and low points.
	/// </summary>
	public class Swing : Indicator
	{
		private int			constant;
		private double		currentSwingHigh;
		private double		currentSwingLow;
		private ArrayList	lastHighCache;
		private double		lastSwingHighValue;
		private ArrayList	lastLowCache;
		private double		lastSwingLowValue;
		private int			saveCurrentBar;

		private Series<double> swingHighSeries;
		private Series<double> swingHighSwings;
		private Series<double> swingLowSeries;
		private Series<double> swingLowSwings;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= Custom.Resource.NinjaScriptIndicatorDescriptionSwing;
				Name						= Custom.Resource.NinjaScriptIndicatorNameSwing;
				DisplayInDataBox			= false;
				PaintPriceMarkers			= false;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				Strength					= 5;

				AddPlot(new Stroke(Brushes.DarkCyan,	2), PlotStyle.Dot, Custom.Resource.SwingHigh);
				AddPlot(new Stroke(Brushes.Goldenrod,	2), PlotStyle.Dot, Custom.Resource.SwingLow);
			}

			else if (State == State.Configure)
			{
				currentSwingHigh	= 0;
				currentSwingLow		= 0;
				lastSwingHighValue	= 0;
				lastSwingLowValue	= 0;
				saveCurrentBar		= -1;
				constant			= 2 * Strength + 1;
				Calculate			= Calculate.OnBarClose;
			}
			else if (State == State.DataLoaded)
			{
				lastHighCache	= new ArrayList();
				lastLowCache	= new ArrayList();

				swingHighSeries = new Series<double>(this);
				swingHighSwings = new Series<double>(this);
				swingLowSeries	= new Series<double>(this);
				swingLowSwings	= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			double high0	= !(Input is PriceSeries || Input is Bars) ? Input[0] : High[0];
			double low0		= !(Input is PriceSeries || Input is Bars) ? Input[0] : Low[0];
			double close0	= !(Input is PriceSeries || Input is Bars) ? Input[0] : Close[0];

			if (BarsArray[0].BarsType.IsRemoveLastBarSupported && CurrentBar < saveCurrentBar)
			{
				currentSwingHigh			= SwingHighPlot.IsValidDataPoint(0) ? SwingHighPlot[0] : 0;
				currentSwingLow				= SwingLowPlot.IsValidDataPoint(0) ? SwingLowPlot[0] : 0;
				lastSwingHighValue			= swingHighSeries[0];
				lastSwingLowValue			= swingLowSeries[0];
				swingHighSeries[Strength]	= 0;
				swingLowSeries[Strength]	= 0;

				lastHighCache.Clear();
				lastLowCache.Clear();
				for (int barsBack = Math.Min(CurrentBar, constant) - 1; barsBack >= 0; barsBack--)
				{
					lastHighCache.Add(!(Input is PriceSeries || Input is Bars) ? Input[barsBack] : High[barsBack]);
					lastLowCache.Add(!(Input is PriceSeries || Input is Bars) ? Input[barsBack] : Low[barsBack]);
				}
				saveCurrentBar = CurrentBar;
				return;
			}

			if (saveCurrentBar != CurrentBar)
			{
				swingHighSwings[0]	= 0;	// initializing important internal
				swingLowSwings[0]	= 0;	// initializing important internal

				swingHighSeries[0]	= 0;	// initializing important internal
				swingLowSeries[0]	= 0;	// initializing important internal

				lastHighCache.Add(high0);
				if (lastHighCache.Count > constant)
					lastHighCache.RemoveAt(0);
				lastLowCache.Add(low0);
				if (lastLowCache.Count > constant)
					lastLowCache.RemoveAt(0);

				if (lastHighCache.Count == constant)
				{
					bool	isSwingHigh					= true;
					double	swingHighCandidateValue		= (double) lastHighCache[Strength];
					for (int i = 0; i < Strength; i++)
						if (((double) lastHighCache[i]).ApproxCompare(swingHighCandidateValue) >= 0)
							isSwingHigh = false;

					for (int i = Strength+1; i < lastHighCache.Count; i++)
						if (((double) lastHighCache[i]).ApproxCompare(swingHighCandidateValue) > 0)
							isSwingHigh = false;

					swingHighSwings[Strength] = isSwingHigh ? swingHighCandidateValue : 0.0;
					if (isSwingHigh)
						lastSwingHighValue = swingHighCandidateValue;

					if (isSwingHigh)
					{
						currentSwingHigh = swingHighCandidateValue;
						for (int i = 0; i <= Strength; i++)
							SwingHighPlot[i] = currentSwingHigh;
					}
					else if (high0 > currentSwingHigh || currentSwingHigh.ApproxCompare(0.0) == 0)
					{
						currentSwingHigh = 0.0;
						SwingHighPlot[0] = close0;
						SwingHighPlot.Reset();
					}
					else
						SwingHighPlot[0] = currentSwingHigh;

					if (isSwingHigh)
						for (int i = 0; i <= Strength; i++)
							swingHighSeries[i] = lastSwingHighValue;
					else
						swingHighSeries[0] = lastSwingHighValue;
				}

				if (lastLowCache.Count == constant)
				{
					bool	isSwingLow				= true;
					double	swingLowCandidateValue	= (double) lastLowCache[Strength];
					for (int i = 0; i < Strength; i++)
						if (((double) lastLowCache[i]).ApproxCompare(swingLowCandidateValue) <= 0)
							isSwingLow = false;

					for (int i=Strength+1; i < lastLowCache.Count; i++)
						if (((double) lastLowCache[i]).ApproxCompare(swingLowCandidateValue) < 0)
							isSwingLow = false;

					swingLowSwings[Strength] = isSwingLow ? swingLowCandidateValue : 0.0;
					if (isSwingLow)
						lastSwingLowValue = swingLowCandidateValue;

					if (isSwingLow)
					{
						currentSwingLow = swingLowCandidateValue;
						for (int i = 0; i <= Strength; i++)
							SwingLowPlot[i] = currentSwingLow;
					}
					else if (low0 < currentSwingLow || currentSwingLow.ApproxCompare(0.0) == 0)
					{
						currentSwingLow = double.MaxValue;
						SwingLowPlot[0] = close0;
						SwingLowPlot.Reset();
					}
					else
						SwingLowPlot[0] = currentSwingLow;

					if (isSwingLow)
						for (int i = 0; i <= Strength; i++)
							swingLowSeries[i] = lastSwingLowValue;
					else
						swingLowSeries[0] = lastSwingLowValue;
				}

				saveCurrentBar = CurrentBar;
			}
			else if (CurrentBar >= constant - 1)
			{
				if (lastHighCache.Count == constant && high0.ApproxCompare((double) lastHighCache[lastHighCache.Count - 1]) > 0)
					lastHighCache[lastHighCache.Count - 1] = high0;
				if (lastLowCache.Count == constant && low0.ApproxCompare((double) lastLowCache[lastLowCache.Count - 1]) < 0)
					lastLowCache[lastLowCache.Count - 1] = low0;

				if (high0 > currentSwingHigh && swingHighSwings[Strength] > 0.0)
				{
					swingHighSwings[Strength] = 0.0;
					for (int i = 0; i <= Strength; i++)
					{
						SwingHighPlot[i] = close0;
						SwingHighPlot.Reset(i);
						currentSwingHigh = 0.0;
					}
				}
				else if (high0 > currentSwingHigh && currentSwingHigh.ApproxCompare(0.0) != 0)
				{
					SwingHighPlot[0] = close0;
					SwingHighPlot.Reset();
					currentSwingHigh = 0.0;
				}
				else if (high0 <= currentSwingHigh)
					SwingHighPlot[0] = currentSwingHigh;

				if (low0 < currentSwingLow && swingLowSwings[Strength] > 0.0)
				{
					swingLowSwings[Strength] = 0.0;
					for (int i = 0; i <= Strength; i++)
					{
						SwingLowPlot[i] = close0;
						SwingLowPlot.Reset(i);
						currentSwingLow = double.MaxValue;
					}
				}
				else if (low0 < currentSwingLow && currentSwingLow.ApproxCompare(double.MaxValue) != 0)
				{
					SwingLowPlot.Reset();
					currentSwingLow = double.MaxValue;
				}
				else if (low0 >= currentSwingLow)
					SwingLowPlot[0] = currentSwingLow;
			}
		}

		#region Functions
		/// <summary>
		/// Returns the number of bars ago a swing low occurred. Returns a value of -1 if a swing low is not found within the look back period.
		/// </summary>
		/// <param name="barsAgo"></param>
		/// <param name="instance"></param>
		/// <param name="lookBackPeriod"></param>
		/// <returns></returns>
		public int SwingLowBar(int barsAgo, int instance, int lookBackPeriod)
		{
			if (instance < 1)
				throw new Exception(string.Format(Custom.Resource.SwingSwingLowBarInstanceGreaterEqual, GetType().Name, instance));
			if (barsAgo < 0)
				throw new Exception(string.Format(Custom.Resource.SwingSwingLowBarBarsAgoGreaterEqual, GetType().Name, barsAgo));
			if (barsAgo >= Count)
				throw new Exception(string.Format(Custom.Resource.SwingSwingLowBarBarsAgoOutOfRange, GetType().Name, (Count - 1), barsAgo));

			Update();

			for (int idx=CurrentBar - barsAgo - Strength; idx >= CurrentBar - barsAgo - Strength - lookBackPeriod; idx--)
			{
				if (idx < 0)
					return -1;
				if (idx >= swingLowSwings.Count)
					continue;

				if (swingLowSwings.GetValueAt(idx).Equals(0.0))
					continue;

				if (instance == 1) // 1-based, < to be save
					return CurrentBar - idx;

				instance--;
			}

			return -1;
		}

		/// <summary>
		/// Returns the number of bars ago a swing high occurred. Returns a value of -1 if a swing high is not found within the look back period.
		/// </summary>
		/// <param name="barsAgo"></param>
		/// <param name="instance"></param>
		/// <param name="lookBackPeriod"></param>
		/// <returns></returns>
		public int SwingHighBar(int barsAgo, int instance, int lookBackPeriod)
		{
			if (instance < 1)
				throw new Exception(string.Format(Custom.Resource.SwingSwingHighBarInstanceGreaterEqual, GetType().Name, instance));
			if (barsAgo < 0)
				throw new Exception(string.Format(Custom.Resource.SwingSwingHighBarBarsAgoGreaterEqual, GetType().Name, barsAgo));
			if (barsAgo >= Count)
				throw new Exception(string.Format(Custom.Resource.SwingSwingHighBarBarsAgoOutOfRange, GetType().Name, (Count - 1), barsAgo));

			Update();

			for (int idx=CurrentBar - barsAgo - Strength; idx >= CurrentBar - barsAgo - Strength - lookBackPeriod; idx--)
			{
				if (idx < 0)
					return -1;
				if (idx >= swingHighSwings.Count)
					continue;

				if (swingHighSwings.GetValueAt(idx).Equals(0.0))
					continue;

				if (instance <= 1) // 1-based, < to be save
					return CurrentBar - idx;

				instance--;
			}

			return -1;
		}
		#endregion

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Strength", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Strength
		{ get; set; }

		/// <summary>
		/// Gets the high swings.
		/// </summary>
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> SwingHigh
		{
			get
			{
				Update();
				return swingHighSeries;
			}
		}

		private Series<double> SwingHighPlot
		{
			get
			{
				Update();
				return Values[0];
			}
		}

		/// <summary>
		/// Gets the low swings.
		/// </summary>
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> SwingLow
		{
			get
			{
				Update();
				return swingLowSeries;
			}
		}

		private Series<double> SwingLowPlot
		{
			get
			{
				Update();
				return Values[1];
			}
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Swing[] cacheSwing;
		public Swing Swing(int strength)
		{
			return Swing(Input, strength);
		}

		public Swing Swing(ISeries<double> input, int strength)
		{
			if (cacheSwing != null)
				for (int idx = 0; idx < cacheSwing.Length; idx++)
					if (cacheSwing[idx] != null && cacheSwing[idx].Strength == strength && cacheSwing[idx].EqualsInput(input))
						return cacheSwing[idx];
			return CacheIndicator<Swing>(new Swing(){ Strength = strength }, input, ref cacheSwing);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Swing Swing(int strength)
		{
			return indicator.Swing(Input, strength);
		}

		public Indicators.Swing Swing(ISeries<double> input , int strength)
		{
			return indicator.Swing(input, strength);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Swing Swing(int strength)
		{
			return indicator.Swing(Input, strength);
		}

		public Indicators.Swing Swing(ISeries<double> input , int strength)
		{
			return indicator.Swing(input, strength);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// T3 Moving Average
	/// </summary>
	public class T3 : Indicator
	{
		private System.Collections.ArrayList seriesCollection;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionT3;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameT3;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				Period						= 14;
				TCount						= 3;
				VFactor						= 0.7;

				AddPlot(Brushes.DarkCyan, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameT3);
			}
		}

		protected override void OnBarUpdate()
		{
			if (TCount == 1)
			{
				CalculateGD(Inputs[0], Values[0]);
				return;
			}

			if (seriesCollection == null)
			{
				seriesCollection = new System.Collections.ArrayList();
				for (int i = 0; i < TCount - 1; i++)
					seriesCollection.Add(new Series<double>(this));
			}

			CalculateGD(Inputs[0], (Series<double>) seriesCollection[0]);

			for (int i = 0; i <= seriesCollection.Count - 2; i++)
				CalculateGD((Series<double>) seriesCollection[i], (Series<double>) seriesCollection[i + 1]);

			CalculateGD((Series<double>) seriesCollection[seriesCollection.Count - 1], Values[0]);
		}

		private void CalculateGD(ISeries<double> input, Series<double> output)
		{
			output[0] = (EMA(input, Period)[0] * (1 + VFactor)) - (EMA(EMA(input, Period), Period)[0] * VFactor);
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "TCount", GroupName = "NinjaScriptParameters", Order = 1)]
		public int TCount
		{ get; set; }

		[Range(0, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "VFactor", GroupName = "NinjaScriptParameters", Order = 2)]
		public double VFactor
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private T3[] cacheT3;
		public T3 T3(int period, int tCount, double vFactor)
		{
			return T3(Input, period, tCount, vFactor);
		}

		public T3 T3(ISeries<double> input, int period, int tCount, double vFactor)
		{
			if (cacheT3 != null)
				for (int idx = 0; idx < cacheT3.Length; idx++)
					if (cacheT3[idx] != null && cacheT3[idx].Period == period && cacheT3[idx].TCount == tCount && cacheT3[idx].VFactor == vFactor && cacheT3[idx].EqualsInput(input))
						return cacheT3[idx];
			return CacheIndicator<T3>(new T3(){ Period = period, TCount = tCount, VFactor = vFactor }, input, ref cacheT3);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.T3 T3(int period, int tCount, double vFactor)
		{
			return indicator.T3(Input, period, tCount, vFactor);
		}

		public Indicators.T3 T3(ISeries<double> input , int period, int tCount, double vFactor)
		{
			return indicator.T3(input, period, tCount, vFactor);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.T3 T3(int period, int tCount, double vFactor)
		{
			return indicator.T3(Input, period, tCount, vFactor);
		}

		public Indicators.T3 T3(ISeries<double> input , int period, int tCount, double vFactor)
		{
			return indicator.T3(input, period, tCount, vFactor);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Triple Exponential Moving Average
	/// </summary>
	public class TEMA : Indicator
	{
		private EMA ema1;
		private EMA ema2;
		private EMA ema3;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionTEMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTEMA;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTEMA);
			}
			else if (State == State.DataLoaded)
			{
				ema1 = EMA(Inputs[0], Period);
				ema2 = EMA(ema1, Period);
				ema3 = EMA(ema2, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = 3 * ema1[0] - 3 * ema2[0] + ema3[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private TEMA[] cacheTEMA;
		public TEMA TEMA(int period)
		{
			return TEMA(Input, period);
		}

		public TEMA TEMA(ISeries<double> input, int period)
		{
			if (cacheTEMA != null)
				for (int idx = 0; idx < cacheTEMA.Length; idx++)
					if (cacheTEMA[idx] != null && cacheTEMA[idx].Period == period && cacheTEMA[idx].EqualsInput(input))
						return cacheTEMA[idx];
			return CacheIndicator<TEMA>(new TEMA(){ Period = period }, input, ref cacheTEMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.TEMA TEMA(int period)
		{
			return indicator.TEMA(Input, period);
		}

		public Indicators.TEMA TEMA(ISeries<double> input , int period)
		{
			return indicator.TEMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.TEMA TEMA(int period)
		{
			return indicator.TEMA(Input, period);
		}

		public Indicators.TEMA TEMA(ISeries<double> input , int period)
		{
			return indicator.TEMA(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//

#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX.DirectWrite;
using SharpDX;
using SharpDX.Direct2D1;
using Point = System.Windows.Point;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class TickCounter : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description			= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionTickCounter;
				Name				= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTickCounter;
				Calculate			= Calculate.OnEachTick;
				CountDown			= true;
				DisplayInDataBox	= false;
				DrawOnPricePanel	= false;
				IsChartOnly			= true;
				IsOverlay			= true;
				ShowPercent			= false;
			}
		}

		protected override void OnBarUpdate()
		{
			double periodValue 	= (BarsPeriod.BarsPeriodType == BarsPeriodType.Tick) ? BarsPeriod.Value : BarsPeriod.BaseBarsPeriodValue;
			double tickCount 	= ShowPercent ? CountDown ? (1 - Bars.PercentComplete) : Bars.PercentComplete : CountDown ? periodValue - Bars.TickCount : Bars.TickCount;
			string tickMsg		= ShowPercent ? tickCount.ToString("P0") : tickCount.ToString();

			string tick1 = (BarsPeriod.BarsPeriodType == BarsPeriodType.Tick 
						|| ((BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Tick) ? ((CountDown 
										? NinjaTrader.Custom.Resource.TickCounterTicksRemaining + tickMsg : NinjaTrader.Custom.Resource.TickCounterTickCount + tickMsg))
										: NinjaTrader.Custom.Resource.TickCounterBarError);

			Draw.TextFixed(this, "NinjaScriptInfo", tick1, TextPosition.BottomRight, ChartControl.Properties.ChartText, ChartControl.Properties.LabelFont, Brushes.Transparent, Brushes.Transparent, 0);
		}

		#region Properties
		[NinjaScriptProperty]
		[Display(ResourceType = typeof (Custom.Resource), Name = "CountDown", Order = 1, GroupName = "NinjaScriptParameters")]
		public bool CountDown
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof (Custom.Resource), Name = "ShowPercent", Order = 2, GroupName = "NinjaScriptParameters")]
		public bool ShowPercent
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private TickCounter[] cacheTickCounter;
		public TickCounter TickCounter(bool countDown, bool showPercent)
		{
			return TickCounter(Input, countDown, showPercent);
		}

		public TickCounter TickCounter(ISeries<double> input, bool countDown, bool showPercent)
		{
			if (cacheTickCounter != null)
				for (int idx = 0; idx < cacheTickCounter.Length; idx++)
					if (cacheTickCounter[idx] != null && cacheTickCounter[idx].CountDown == countDown && cacheTickCounter[idx].ShowPercent == showPercent && cacheTickCounter[idx].EqualsInput(input))
						return cacheTickCounter[idx];
			return CacheIndicator<TickCounter>(new TickCounter(){ CountDown = countDown, ShowPercent = showPercent }, input, ref cacheTickCounter);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.TickCounter TickCounter(bool countDown, bool showPercent)
		{
			return indicator.TickCounter(Input, countDown, showPercent);
		}

		public Indicators.TickCounter TickCounter(ISeries<double> input , bool countDown, bool showPercent)
		{
			return indicator.TickCounter(input, countDown, showPercent);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.TickCounter TickCounter(bool countDown, bool showPercent)
		{
			return indicator.TickCounter(Input, countDown, showPercent);
		}

		public Indicators.TickCounter TickCounter(ISeries<double> input , bool countDown, bool showPercent)
		{
			return indicator.TickCounter(input, countDown, showPercent);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The TMA (Triangular Moving Average) is a weighted moving average. Compared to the WMA which puts more weight on the latest price bar, the TMA puts more weight on the data in the middle of the specified period.
	/// </summary>
	public class TMA : Indicator
	{
		private int p1;
		private int p2;
		private SMA sma;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionTMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 15;

				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTMA);
			}
			else if (State == State.Configure)
			{
				p1 = 0;
				p2 = 0;
				if ((Period & 1) == 0)
				{
					// Even period
					p1 = Period / 2;
					p2 = p1 + 1;
				}
				else
				{
					// Odd period
					p1 = (Period + 1) / 2;
					p2 = p1;
				}
			}
			else if (State == State.DataLoaded)
			{
				sma = SMA(SMA(Inputs[0], p1), p2);
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = sma[0];
		}

		#region Properties

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof (Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private TMA[] cacheTMA;
		public TMA TMA(int period)
		{
			return TMA(Input, period);
		}

		public TMA TMA(ISeries<double> input, int period)
		{
			if (cacheTMA != null)
				for (int idx = 0; idx < cacheTMA.Length; idx++)
					if (cacheTMA[idx] != null && cacheTMA[idx].Period == period && cacheTMA[idx].EqualsInput(input))
						return cacheTMA[idx];
			return CacheIndicator<TMA>(new TMA(){ Period = period }, input, ref cacheTMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.TMA TMA(int period)
		{
			return indicator.TMA(Input, period);
		}

		public Indicators.TMA TMA(ISeries<double> input , int period)
		{
			return indicator.TMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.TMA TMA(int period)
		{
			return indicator.TMA(Input, period);
		}

		public Indicators.TMA TMA(ISeries<double> input , int period)
		{
			return indicator.TMA(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Trend lines automatically plots recent trends by connect high points together for high trends and connecting low points together for low trends.
	/// </summary>
	public class TrendLines : Indicator
	{
		private int			lastHighBar			= -1;
		private int			lastLowBar			= -1;
		private double		lastHighPrice		= double.MinValue;
		private double		lastLowPrice		= double.MaxValue;
		private bool?		highTrendIsActive	= null;
		private bool		alertIsArmed;
		private TrendRay	highTrend;
		private TrendRay	lowTrend;
		private TrendQueue	trendLines;
		private Swing		swing;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description			= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionTrendLines;
				Name				= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTrendLines;
				Calculate			= Calculate.OnBarClose;
				IsOverlay			= true;
				DisplayInDataBox	= false;
				DrawOnPricePanel	= false;
				PaintPriceMarkers	= false;
				Strength			= 5;
				NumberOfTrendLines	= 1;
				OldTrendsOpacity	= 25;
				AlertOnBreak		= false;
				AlertOnBreakSound	= System.IO.Path.Combine(NinjaTrader.Core.Globals.InstallDir, "sounds", "Alert2.wav");
				TrendLineHighStroke = new Stroke(Brushes.DarkCyan, 1f);
				TrendLineLowStroke	= new Stroke(Brushes.Goldenrod, 1f);
			}
			else if (State == State.Configure)
				AddPlot(Brushes.White, NinjaTrader.Custom.Resource.TrendLinesCurrentTrendLine);
			else if (State == State.DataLoaded)
			{
				swing		= Swing(Input, Strength);
				trendLines	= new TrendQueue(this, NumberOfTrendLines);
				if (ChartPanel == null)
					Draw.TextFixed(this, "TrendLinesStrategyAnalyzer", Custom.Resource.TrendLinesNotVisible, TextPosition.BottomRight);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < 0)
				return;

			// High Trend Line
			int swingHighBar = swing.SwingHighBar(0, 1, Strength + 1);

			if (swingHighBar != -1)
			{
				double swingHighPrice = !(Input is PriceSeries || Input is Bars) ? Input[swingHighBar] : High[swingHighBar];

				if (swingHighPrice < lastHighPrice && lastHighBar > -1)
				{
					highTrend = new TrendRay(lastHighBar, lastHighPrice, CurrentBar - swingHighBar, swingHighPrice) { IsHigh = true };
					trendLines.Enqueue(highTrend);
					highTrendIsActive	= true;
					alertIsArmed		= true;
				}

				lastHighBar		= CurrentBar - swingHighBar;
				lastHighPrice	= swingHighPrice;
			}

			// Low Trend Line
			int swingLowBar = swing.SwingLowBar(0, 1, Strength + 1);

			if (swingLowBar != -1)
			{
				double swingLowPrice = !(Input is PriceSeries || Input is Bars) ? Input[swingLowBar] : Low[swingLowBar];

				if (swingLowPrice > lastLowPrice && lastLowBar > -1)
				{
					lowTrend = new TrendRay(lastLowBar, lastLowPrice, CurrentBar - swingLowBar, swingLowPrice);
					trendLines.Enqueue(lowTrend);
					highTrendIsActive	= false;
					alertIsArmed		= true;
				}

				lastLowBar		= CurrentBar - swingLowBar;
				lastLowPrice	= swingLowPrice;
			}

			if (highTrendIsActive.HasValue)
			{
				if (ChartControl == null || ChartControl.BarSpacingType == BarSpacingType.TimeBased)
				{
					if (highTrendIsActive.Value)
					{
						double slope = (highTrend.EndPrice - highTrend.StartPrice) / (highTrend.EndBar - highTrend.StartBar);
						Values[0][0] = slope * CurrentBar - (slope * highTrend.StartBar - highTrend.StartPrice);
					}
					else
					{
						double slope = (lowTrend.EndPrice - lowTrend.StartPrice) / (lowTrend.EndBar - lowTrend.StartBar);
						Values[0][0] = slope * CurrentBar - (slope * lowTrend.StartBar - lowTrend.StartPrice);
					}
				}
				else
				{
					if (highTrendIsActive.Value)
					{
						double startSlotIndex	= ChartControl.GetSlotIndexByTime(ChartBars.GetTimeByBarIdx(ChartControl, highTrend.StartBar));
						double endSlotIndex		= ChartControl.GetSlotIndexByTime(ChartBars.GetTimeByBarIdx(ChartControl, highTrend.EndBar));
						double curSlotIndex		= ChartControl.GetSlotIndexByTime(Time[0]);
						double slope			= (highTrend.EndPrice - highTrend.StartPrice) / (endSlotIndex - startSlotIndex);
						Values[0][0]			= slope * curSlotIndex - (slope * startSlotIndex - highTrend.StartPrice);
					}
					else
					{
						double startSlotIndex	= ChartControl.GetSlotIndexByTime(ChartBars.GetTimeByBarIdx(ChartControl, lowTrend.StartBar));
						double endSlotIndex		= ChartControl.GetSlotIndexByTime(ChartBars.GetTimeByBarIdx(ChartControl, lowTrend.EndBar));
						double curSlotIndex		= ChartControl.GetSlotIndexByTime(Time[0]);
						double slope			= (lowTrend.EndPrice - lowTrend.StartPrice) / (endSlotIndex - startSlotIndex);
						Values[0][0]			= slope * curSlotIndex - (slope * startSlotIndex - lowTrend.StartPrice);
					}
				}

				if (State == State.Realtime && AlertOnBreak && alertIsArmed)
				{
					if (CrossAbove(Input, Values[0][0], 1) || CrossBelow(Input, Values[0][0], 1))
					{
						Alert(string.Empty, Priority.High, string.Format(NinjaTrader.Custom.Resource.TrendLinesTrendLineBroken, 
								highTrendIsActive.Value ? NinjaTrader.Custom.Resource.TrendLinesTrendLineHigh: NinjaTrader.Custom.Resource.TrendLinesTrendLineLow), 
							AlertOnBreakSound, 0, Brushes.Transparent, highTrendIsActive.Value ? TrendLineHighStroke.Brush : TrendLineLowStroke.Brush);

						alertIsArmed = false;
					}
				}
			}
		}

		public override void OnCalculateMinMax()
		{
			double minValue = double.MaxValue;
			double maxValue = double.MinValue;

			foreach (TrendRay trend in trendLines)
				AutoScalePerRay(trend.Ray, ref minValue, ref maxValue);

			MinValue = minValue;
			MaxValue = maxValue;
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale) { /* Don't Render Plots */ }

		#region Helpers
		private void AutoScalePerRay(Ray ray, ref double minValue, ref double maxValue)
		{
			// Do not do anything if there is no Ray (Strategy Analyzer chart)
			if (ray == null)
				return;

			int startIdx = ChartBars.GetBarIdxByTime(ChartControl, ray.StartAnchor.Time);

			if (startIdx >= ChartBars.FromIndex - Displacement && startIdx <= ChartBars.ToIndex - Displacement)
			{
				if (ray.StartAnchor.Price < minValue)
					minValue = ray.StartAnchor.Price;
				if (ray.StartAnchor.Price > maxValue)
					maxValue = ray.StartAnchor.Price;
			}

			int endIdx = ChartBars.GetBarIdxByTime(ChartControl, ray.EndAnchor.Time);

			if (endIdx >= ChartBars.FromIndex - Displacement && endIdx <= ChartBars.ToIndex - Displacement)
			{
				if (ray.EndAnchor.Price < minValue)
					minValue = ray.EndAnchor.Price;
				if (ray.EndAnchor.Price > maxValue)
					maxValue = ray.EndAnchor.Price;
			}
		}

		private class TrendRay
		{
			public int		StartBar;
			public double	StartPrice;
			public int		EndBar;
			public double	EndPrice;
			public Ray		Ray;
			public bool		IsHigh;

			public TrendRay(int startBar, double startPrice, int endBar, double endPrice)
			{
				StartBar	= startBar;
				StartPrice	= startPrice;
				EndBar		= endBar;
				EndPrice	= endPrice;
			}
		}

		private class TrendQueue : Queue<TrendRay>
		{
			private TrendLines	instance;
			private TrendRay	lastTrend;

			public new void Enqueue(TrendRay trend)
			{
				if (instance.ChartControl != null)
				{
					string rayName	= string.Format("{0}_{1}", trend.IsHigh ? NinjaTrader.Custom.Resource.TrendLinesTrendLineHigh : NinjaTrader.Custom.Resource.TrendLinesTrendLineLow, trend.StartBar);
					trend.Ray		= Draw.Ray(instance,
												rayName,
												false,
												instance.CurrentBar - trend.StartBar - instance.Displacement,
												trend.StartPrice,
												instance.CurrentBar - trend.EndBar - instance.Displacement,
												trend.EndPrice,
												trend.IsHigh ? instance.TrendLineHighStroke.Brush : instance.TrendLineLowStroke.Brush,
												trend.IsHigh ? instance.TrendLineHighStroke.DashStyleHelper : instance.TrendLineLowStroke.DashStyleHelper,
												(int)(trend.IsHigh ? instance.TrendLineHighStroke.Width : instance.TrendLineLowStroke.Width));

					trend.Ray.Stroke.Opacity = trend.IsHigh ? instance.TrendLineHighStroke.Opacity : instance.TrendLineLowStroke.Opacity;

					if (lastTrend != null)
						lastTrend.Ray.Stroke.Opacity = instance.OldTrendsOpacity;
				}

				lastTrend = trend;
				base.Enqueue(trend);

				// Make it into a circular buffer
				if (Count > instance.NumberOfTrendLines)
				{
					TrendRay toRemove = base.Dequeue();

					// Ray will be null if no ChartControl
					if (toRemove.Ray != null)
						instance.RemoveDrawObject(toRemove.Ray.Tag);
				}
			}

			public TrendQueue(TrendLines instance, int capacity) : base(capacity)
			{
				this.instance = instance;
			}
		}
		#endregion

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Strength", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Strength { get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "NumberOfTrendLines", GroupName = "NinjaScriptParameters", Order = 1)]
		public int NumberOfTrendLines { get; set; }

		[Range(0, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "OldTrendsOpacity", GroupName = "NinjaScriptParameters", Order = 2)]
		public int OldTrendsOpacity { get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "AlertOnBreak", GroupName = "NinjaScriptParameters", Order = 3)]
		public bool AlertOnBreak { get; set; }

		[PropertyEditor("NinjaTrader.Gui.Tools.FilePathPicker", Filter = "WAV Files (*.wav)|*.wav")]
		[Display(ResourceType = typeof(Custom.Resource), Name = "AlertOnBreakSound", GroupName = "NinjaScriptParameters", Order = 4)]
		public string AlertOnBreakSound { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "TrendLinesTrendLineHigh", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 1800)]
		public Stroke TrendLineHighStroke { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "TrendLinesTrendLineLow", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 1810)]
		public Stroke TrendLineLowStroke { get; set; }
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private TrendLines[] cacheTrendLines;
		public TrendLines TrendLines(int strength, int numberOfTrendLines, int oldTrendsOpacity, bool alertOnBreak)
		{
			return TrendLines(Input, strength, numberOfTrendLines, oldTrendsOpacity, alertOnBreak);
		}

		public TrendLines TrendLines(ISeries<double> input, int strength, int numberOfTrendLines, int oldTrendsOpacity, bool alertOnBreak)
		{
			if (cacheTrendLines != null)
				for (int idx = 0; idx < cacheTrendLines.Length; idx++)
					if (cacheTrendLines[idx] != null && cacheTrendLines[idx].Strength == strength && cacheTrendLines[idx].NumberOfTrendLines == numberOfTrendLines && cacheTrendLines[idx].OldTrendsOpacity == oldTrendsOpacity && cacheTrendLines[idx].AlertOnBreak == alertOnBreak && cacheTrendLines[idx].EqualsInput(input))
						return cacheTrendLines[idx];
			return CacheIndicator<TrendLines>(new TrendLines() { Strength = strength, NumberOfTrendLines = numberOfTrendLines, OldTrendsOpacity = oldTrendsOpacity, AlertOnBreak = alertOnBreak }, input, ref cacheTrendLines);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.TrendLines TrendLines(int strength, int numberOfTrendLines, int oldTrendsOpacity, bool alertOnBreak)
		{
			return indicator.TrendLines(Input, strength, numberOfTrendLines, oldTrendsOpacity, alertOnBreak);
		}

		public Indicators.TrendLines TrendLines(ISeries<double> input, int strength, int numberOfTrendLines, int oldTrendsOpacity, bool alertOnBreak)
		{
			return indicator.TrendLines(input, strength, numberOfTrendLines, oldTrendsOpacity, alertOnBreak);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.TrendLines TrendLines(int strength, int numberOfTrendLines, int oldTrendsOpacity, bool alertOnBreak)
		{
			return indicator.TrendLines(Input, strength, numberOfTrendLines, oldTrendsOpacity, alertOnBreak);
		}

		public Indicators.TrendLines TrendLines(ISeries<double> input, int strength, int numberOfTrendLines, int oldTrendsOpacity, bool alertOnBreak)
		{
			return indicator.TrendLines(input, strength, numberOfTrendLines, oldTrendsOpacity, alertOnBreak);
		}
	}
}

#endregion

#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The TRIX (Triple Exponential Average) displays the percentage Rate of Change (ROC)
	/// of a triple EMA. Trix oscillates above and below the zero value. The indicator
	/// applies triple smoothing in an attempt to eliminate insignificant price movements
	/// within the trend that you're trying to isolate.
	/// </summary>
	public class TRIX : Indicator
	{
		private EMA	emaDefault;
		private EMA	emaTriple;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionTRIX;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTRIX;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				SignalPeriod				= 3;

				AddPlot(Brushes.DimGray,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorDefault);
				AddPlot(Brushes.Crimson,		NinjaTrader.Custom.Resource.TRIXSignal);
				AddLine(Brushes.DarkGray, 0,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.DataLoaded)
			{
				emaTriple	= EMA(EMA(EMA(Inputs[0], Period), Period), Period);
				emaDefault	= EMA(Default, SignalPeriod);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				Value[0] = Input[0];
				return;
			}

			double emaTriple0	= emaTriple[0];
			Default[0]			= 100 * ((emaTriple0  - emaTriple[1]) / emaTriple0);
			Signal[0]			= emaDefault[0];
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Default
		{
			get { return Values[0]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> Signal
		{
			get { return Values[1]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "SignalPeriod", GroupName = "NinjaScriptParameters", Order = 1)]
		public int SignalPeriod
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private TRIX[] cacheTRIX;
		public TRIX TRIX(int period, int signalPeriod)
		{
			return TRIX(Input, period, signalPeriod);
		}

		public TRIX TRIX(ISeries<double> input, int period, int signalPeriod)
		{
			if (cacheTRIX != null)
				for (int idx = 0; idx < cacheTRIX.Length; idx++)
					if (cacheTRIX[idx] != null && cacheTRIX[idx].Period == period && cacheTRIX[idx].SignalPeriod == signalPeriod && cacheTRIX[idx].EqualsInput(input))
						return cacheTRIX[idx];
			return CacheIndicator<TRIX>(new TRIX(){ Period = period, SignalPeriod = signalPeriod }, input, ref cacheTRIX);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.TRIX TRIX(int period, int signalPeriod)
		{
			return indicator.TRIX(Input, period, signalPeriod);
		}

		public Indicators.TRIX TRIX(ISeries<double> input , int period, int signalPeriod)
		{
			return indicator.TRIX(input, period, signalPeriod);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.TRIX TRIX(int period, int signalPeriod)
		{
			return indicator.TRIX(Input, period, signalPeriod);
		}

		public Indicators.TRIX TRIX(ISeries<double> input , int period, int signalPeriod)
		{
			return indicator.TRIX(input, period, signalPeriod);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The TSF (Time Series Forecast) calculates probable future values for the price
	/// by fitting a linear regression line over a given number of price bars and following
	///  that line forward into the future. A linear regression line is a straight line which
	///  is as close to all of the given price points as possible. Also see the Linear Regression indicator.
	/// </summary>
	public class TSF : Indicator
	{
		private double			avg;
		private double			divisor;
		private	double			intercept;
		private double			myPeriod;
		private double			priorSumXY;
		private	double			priorSumY;
		private double			slope;
		private double			sumX2;
		private	double			sumX;
		private double			sumXY;
		private double			sumY;
		private SUM				sum;
		private Series<double>	y;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionTSF;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTSF;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				Period						= 14;
				Forecast					= 3;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTSF);
			}
			else if (State == State.Configure)
			{
				avg	= divisor = intercept = myPeriod = priorSumXY
					= priorSumY = slope = sumX = sumX2 = sumY = sumXY = 0;
			}
			else if (State == State.DataLoaded)
			{
				sum = SUM(Inputs[0], Period);
				y	= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				double sumX = (double)Period * (Period - 1) * 0.5;
				double divisor = sumX * sumX - (double)Period * Period * (Period - 1) * (2 * Period - 1) / 6;
				double sumXY = 0;

				for (int count = 0; count < Period && CurrentBar - count >= 0; count++)
					sumXY += count * Input[count];

				y[0] = Input[0];

				double slope = ((double)Period * sumXY - sumX * SUM(y, Period)[0]) / divisor;
				double intercept = (SUM(y, Period)[0] - slope * sumX) / Period;

				Value[0] = intercept + slope * ((Period - 1) + Forecast);
			}
			else
			{
				if (IsFirstTickOfBar)
				{
					priorSumY = sumY;
					priorSumXY = sumXY;
					myPeriod = Math.Min(CurrentBar + 1, Period);
					sumX = myPeriod * (myPeriod - 1) * 0.5;
					sumX2 = myPeriod * (myPeriod + 1) * 0.5;
					divisor = myPeriod * (myPeriod + 1) * (2 * myPeriod + 1) / 6 - sumX2 * sumX2 / myPeriod;
				}

				double input0 = Input[0];
				sumXY = priorSumXY - (CurrentBar >= Period ? priorSumY : 0) + myPeriod * input0;
				sumY = priorSumY + input0 - (CurrentBar >= Period ? Input[Period] : 0);
				avg = sumY / myPeriod;
				slope = (sumXY - sumX2 * avg) / divisor;
				intercept = (sum[0] - slope * sumX) / myPeriod;
				Value[0] = CurrentBar == 0 ? input0 : intercept + slope * ((myPeriod - 1) + Forecast);
			}
		}


		#region Properties
		[Range(-10, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Forecast", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Forecast
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private TSF[] cacheTSF;
		public TSF TSF(int forecast, int period)
		{
			return TSF(Input, forecast, period);
		}

		public TSF TSF(ISeries<double> input, int forecast, int period)
		{
			if (cacheTSF != null)
				for (int idx = 0; idx < cacheTSF.Length; idx++)
					if (cacheTSF[idx] != null && cacheTSF[idx].Forecast == forecast && cacheTSF[idx].Period == period && cacheTSF[idx].EqualsInput(input))
						return cacheTSF[idx];
			return CacheIndicator<TSF>(new TSF(){ Forecast = forecast, Period = period }, input, ref cacheTSF);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.TSF TSF(int forecast, int period)
		{
			return indicator.TSF(Input, forecast, period);
		}

		public Indicators.TSF TSF(ISeries<double> input , int forecast, int period)
		{
			return indicator.TSF(input, forecast, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.TSF TSF(int forecast, int period)
		{
			return indicator.TSF(Input, forecast, period);
		}

		public Indicators.TSF TSF(ISeries<double> input , int forecast, int period)
		{
			return indicator.TSF(input, forecast, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The TSI (True Strength Index) is a momentum-based indicator, developed by William Blau.
	/// Designed to determine both trend and overbought/oversold conditions, the TSI is
	/// applicable to intraday time frames as well as long term trading.
	/// </summary>
	public class TSI : Indicator
	{
		private double				constant1;
		private	double				constant2;
		private double				constant3;
		private double				constant4;
		private Series<double>		fastEma;
		private Series<double>		fastAbsEma;
		private Series<double>		slowEma;
		private Series<double>		slowAbsEma;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionTSI;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTSI;
				Fast						= 3;
				IsSuspendedWhileInactive	= true;
				Slow						= 14;

				AddPlot(Brushes.DarkCyan, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameTSI);
			}
			else if (State == State.Configure)
			{
				constant1	= (2.0 / (1 + Slow));
				constant2	= (1 - (2.0 / (1 + Slow)));
				constant3	= (2.0 / (1 + Fast));
				constant4	= (1 - (2.0 / (1 + Fast)));
			}
			else if (State == State.DataLoaded)
			{
				fastAbsEma	= new Series<double>(this);
				fastEma		= new Series<double>(this);
				slowAbsEma	= new Series<double>(this);
				slowEma		= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				fastAbsEma[0]	= 0;
				fastEma[0]		= 0;
				slowAbsEma[0]	= 0;
				slowEma[0]		= 0;
				Value[0]		= 0;
			}
			else
			{
				double momentum	= Input[0] - Input[1];
				slowEma[0]		= momentum * constant1 + constant2 * slowEma[1];
				fastEma[0]		= slowEma[0] * constant3 + constant4 * fastEma[1];
				slowAbsEma[0]	= Math.Abs(momentum) * constant1 + constant2 * slowAbsEma[1];
				fastAbsEma[0]	= slowAbsEma[0] * constant3 + constant4 * fastAbsEma[1];
				Value[0]		= fastAbsEma[0] == 0 ? 0 : 100 * fastEma[0] / fastAbsEma[0];
			}
		}

		#region Properties

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof (Custom.Resource), Name = "Fast", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Fast
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Slow", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Slow
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private TSI[] cacheTSI;
		public TSI TSI(int fast, int slow)
		{
			return TSI(Input, fast, slow);
		}

		public TSI TSI(ISeries<double> input, int fast, int slow)
		{
			if (cacheTSI != null)
				for (int idx = 0; idx < cacheTSI.Length; idx++)
					if (cacheTSI[idx] != null && cacheTSI[idx].Fast == fast && cacheTSI[idx].Slow == slow && cacheTSI[idx].EqualsInput(input))
						return cacheTSI[idx];
			return CacheIndicator<TSI>(new TSI(){ Fast = fast, Slow = slow }, input, ref cacheTSI);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.TSI TSI(int fast, int slow)
		{
			return indicator.TSI(Input, fast, slow);
		}

		public Indicators.TSI TSI(ISeries<double> input , int fast, int slow)
		{
			return indicator.TSI(input, fast, slow);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.TSI TSI(int fast, int slow)
		{
			return indicator.TSI(Input, fast, slow);
		}

		public Indicators.TSI TSI(ISeries<double> input , int fast, int slow)
		{
			return indicator.TSI(input, fast, slow);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Ultimate Oscillator is the weighted sum of three oscillators of different time periods.
	/// The typical time periods are 7, 14 and 28. The values of the Ultimate Oscillator range
	/// from zero to 100. Values over 70 indicate overbought conditions, and values under 30 indicate
	/// oversold conditions. Also look for agreement/divergence with the price to confirm a trend or signal the end of a trend.
	/// </summary>
	public class UltimateOscillator : Indicator
	{
		private Series<double>	buyingPressure;
		private double			constant1;
		private double			constant2;
		private double			constant3;
		private SUM				sumBpFast;
		private SUM				sumBpIntermediate;
		private SUM				sumBpSlow;
		private SUM				sumTrFast;
		private SUM				sumTrIntermediate;
		private SUM				sumTrSlow;
		private Series<double>	trueRange;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionUltimateOscillator;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameUltimateOscillator;
				IsSuspendedWhileInactive	= true;
				Fast						= 7;
				Intermediate				= 14;
				Slow						= 28;

				AddPlot(Brushes.DodgerBlue,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameUltimateOscillator);

				AddLine(Brushes.DarkGray,	30,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorOversold);
				AddLine(Brushes.DarkGray,	50,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorNeutral);
				AddLine(Brushes.DarkGray,	70,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorOverbought);
			}
			else if (State == State.Configure)
			{
				constant1			= Slow / Fast;
				constant2			= Slow / Intermediate;
				constant3			= constant1 + constant2 + 1;
			}
			else if (State == State.DataLoaded)
			{
				buyingPressure		= new Series<double>(this);
				trueRange			= new Series<double>(this);
				sumBpFast			= SUM(buyingPressure, Fast);
				sumBpIntermediate	= SUM(buyingPressure, Intermediate);
				sumBpSlow			= SUM(buyingPressure, Slow);
				sumTrFast			= SUM(trueRange, Fast);
				sumTrIntermediate	= SUM(trueRange, Intermediate);
				sumTrSlow			= SUM(trueRange, Slow);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
				Value[0] =  0;

			else
			{
				double high0	= High[0];
				double low0		= Low[0];
				double close0	= Close[0];
				double close1	= Close[1];

				buyingPressure[0] 	= close0 - Math.Min(low0, close1);
				trueRange[0] 		= Math.Max(Math.Max(high0 - low0, high0 - close1), close1 - low0);

				// Use previous value if we get into trouble
				if (sumTrFast[0] == 0 || sumTrIntermediate[0] == 0 || sumTrSlow[0] == 0)
				{
					Value[0] = Value[1];
					return;
				}

				Value[0] = (((sumBpFast[0] / sumTrFast[0]) * constant1
								+ (sumBpIntermediate[0] / sumTrIntermediate[0]) * constant2
								+ (sumBpSlow[0] / sumTrSlow[0]))
								/ (constant3)) * 100;
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Fast", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Fast
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Intermediate", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Intermediate
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Slow", GroupName = "NinjaScriptParameters", Order = 2)]
		public int Slow
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private UltimateOscillator[] cacheUltimateOscillator;
		public UltimateOscillator UltimateOscillator(int fast, int intermediate, int slow)
		{
			return UltimateOscillator(Input, fast, intermediate, slow);
		}

		public UltimateOscillator UltimateOscillator(ISeries<double> input, int fast, int intermediate, int slow)
		{
			if (cacheUltimateOscillator != null)
				for (int idx = 0; idx < cacheUltimateOscillator.Length; idx++)
					if (cacheUltimateOscillator[idx] != null && cacheUltimateOscillator[idx].Fast == fast && cacheUltimateOscillator[idx].Intermediate == intermediate && cacheUltimateOscillator[idx].Slow == slow && cacheUltimateOscillator[idx].EqualsInput(input))
						return cacheUltimateOscillator[idx];
			return CacheIndicator<UltimateOscillator>(new UltimateOscillator(){ Fast = fast, Intermediate = intermediate, Slow = slow }, input, ref cacheUltimateOscillator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.UltimateOscillator UltimateOscillator(int fast, int intermediate, int slow)
		{
			return indicator.UltimateOscillator(Input, fast, intermediate, slow);
		}

		public Indicators.UltimateOscillator UltimateOscillator(ISeries<double> input , int fast, int intermediate, int slow)
		{
			return indicator.UltimateOscillator(input, fast, intermediate, slow);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.UltimateOscillator UltimateOscillator(int fast, int intermediate, int slow)
		{
			return indicator.UltimateOscillator(Input, fast, intermediate, slow);
		}

		public Indicators.UltimateOscillator UltimateOscillator(ISeries<double> input , int fast, int intermediate, int slow)
		{
			return indicator.UltimateOscillator(input, fast, intermediate, slow);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The VMA (Variable Moving Average, also known as VIDYA or Variable Index Dynamic Average)
	///  is an exponential moving average that automatically adjusts the smoothing weight based
	/// on the volatility of the data series. VMA solves a problem with most moving averages.
	/// In times of low volatility, such as when the price is trending, the moving average time
	///  period should be shorter to be sensitive to the inevitable break in the trend. Whereas,
	/// in more volatile non-trending times, the moving average time period should be longer to
	/// filter out the choppiness. VIDYA uses the CMO indicator for it's internal volatility calculations.
	/// Both the VMA and the CMO period are adjustable.
	/// </summary>
	public class VMA : Indicator
	{
		private CMO		cmo;
		private double	sc;	//Smoothing Constant

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionVMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVMA;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				Period						= 9;
				VolatilityPeriod			= 9;

				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVMA);
			}
			else if (State == State.Configure)
			{
				sc  = 2 / (double)(Period + 1);
			}
			else if (State == State.DataLoaded)
			{
				cmo = CMO(Inputs[0], VolatilityPeriod);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				Value[0] = Input[0];
				return;
			}

			// Volatility Index
			double vi	= Math.Abs(cmo[0]) / 100;
			Value[0]	= sc * vi * Input[0] + (1 - sc * vi) * Value[1];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "VolatilityPeriod", GroupName = "NinjaScriptParameters", Order = 1)]
		public int VolatilityPeriod
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private VMA[] cacheVMA;
		public VMA VMA(int period, int volatilityPeriod)
		{
			return VMA(Input, period, volatilityPeriod);
		}

		public VMA VMA(ISeries<double> input, int period, int volatilityPeriod)
		{
			if (cacheVMA != null)
				for (int idx = 0; idx < cacheVMA.Length; idx++)
					if (cacheVMA[idx] != null && cacheVMA[idx].Period == period && cacheVMA[idx].VolatilityPeriod == volatilityPeriod && cacheVMA[idx].EqualsInput(input))
						return cacheVMA[idx];
			return CacheIndicator<VMA>(new VMA(){ Period = period, VolatilityPeriod = volatilityPeriod }, input, ref cacheVMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.VMA VMA(int period, int volatilityPeriod)
		{
			return indicator.VMA(Input, period, volatilityPeriod);
		}

		public Indicators.VMA VMA(ISeries<double> input , int period, int volatilityPeriod)
		{
			return indicator.VMA(input, period, volatilityPeriod);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.VMA VMA(int period, int volatilityPeriod)
		{
			return indicator.VMA(Input, period, volatilityPeriod);
		}

		public Indicators.VMA VMA(ISeries<double> input , int period, int volatilityPeriod)
		{
			return indicator.VMA(input, period, volatilityPeriod);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Volume is simply the number of shares (or contracts) traded during a specified time frame (e.g. hour, day, week, month, etc).
	/// </summary>
	public class VOL : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= Custom.Resource.NinjaScriptIndicatorDescriptionVOL;
				Name						= Custom.Resource.NinjaScriptIndicatorNameVOL;
				BarsRequiredToPlot			= 0;
				Calculate					= Calculate.OnEachTick;
				DrawOnPricePanel			= false;
				IsSuspendedWhileInactive	= true;

				AddPlot(new Stroke(Brushes.DodgerBlue, 2),	PlotStyle.Bar,	Custom.Resource.VOLVolume);
				AddLine(Brushes.DarkGray, 0,			Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0];
		}
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private VOL[] cacheVOL;
		public VOL VOL()
		{
			return VOL(Input);
		}

		public VOL VOL(ISeries<double> input)
		{
			if (cacheVOL != null)
				for (int idx = 0; idx < cacheVOL.Length; idx++)
					if (cacheVOL[idx] != null &&  cacheVOL[idx].EqualsInput(input))
						return cacheVOL[idx];
			return CacheIndicator<VOL>(new VOL(), input, ref cacheVOL);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.VOL VOL()
		{
			return indicator.VOL(Input);
		}

		public Indicators.VOL VOL(ISeries<double> input )
		{
			return indicator.VOL(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.VOL VOL()
		{
			return indicator.VOL(Input);
		}

		public Indicators.VOL VOL(ISeries<double> input )
		{
			return indicator.VOL(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The VOLMA (Volume Moving Average) plots an exponential moving average (EMA) of volume.
	/// </summary>
	public class VOLMA : Indicator
	{
		private EMA ema;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionVOLMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVOLMA;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= false;
				DrawOnPricePanel			= false;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVOLMA);
			}
			else if (State == State.DataLoaded)
				ema = EMA(Volume, Period);
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			Value[0] = Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)ema[0]) : ema[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private VOLMA[] cacheVOLMA;
		public VOLMA VOLMA(int period)
		{
			return VOLMA(Input, period);
		}

		public VOLMA VOLMA(ISeries<double> input, int period)
		{
			if (cacheVOLMA != null)
				for (int idx = 0; idx < cacheVOLMA.Length; idx++)
					if (cacheVOLMA[idx] != null && cacheVOLMA[idx].Period == period && cacheVOLMA[idx].EqualsInput(input))
						return cacheVOLMA[idx];
			return CacheIndicator<VOLMA>(new VOLMA(){ Period = period }, input, ref cacheVOLMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.VOLMA VOLMA(int period)
		{
			return indicator.VOLMA(Input, period);
		}

		public Indicators.VOLMA VOLMA(ISeries<double> input , int period)
		{
			return indicator.VOLMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.VOLMA VOLMA(int period)
		{
			return indicator.VOLMA(Input, period);
		}

		public Indicators.VOLMA VOLMA(ISeries<double> input , int period)
		{
			return indicator.VOLMA(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX.DirectWrite;
using SharpDX.Direct2D1;
using Point = System.Windows.Point;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class VolumeCounter : Indicator
	{
		private double volume;
		private bool isVolume, isVolumeBase;
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionVolumeCounter;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVolumeCounter;
				Calculate					= Calculate.OnEachTick;
				CountDown					= true;
				DisplayInDataBox			= false;
				DrawOnPricePanel			= false;
				IsChartOnly					= true;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				ShowPercent					= true;
			}
			else if(State == State.DataLoaded)
			{
				isVolume 		= BarsPeriod.BarsPeriodType == BarsPeriodType.Volume;
				isVolumeBase 	= (BarsPeriod.BarsPeriodType == BarsPeriodType.HeikenAshi || BarsPeriod.BarsPeriodType == BarsPeriodType.Volumetric) && BarsPeriod.BaseBarsPeriodType == BarsPeriodType.Volume;
			}
		}

		protected override void OnBarUpdate()
		{
			volume = Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0];

			double volumeCount = ShowPercent
				? CountDown
					? (1 - Bars.PercentComplete) * 100
					: Bars.PercentComplete * 100
				: CountDown
					? (isVolumeBase
						? BarsPeriod.BaseBarsPeriodValue
						: BarsPeriod.Value) - volume
					: volume;

			string volume1 = (isVolume || isVolumeBase)
				? ((CountDown
					? NinjaTrader.Custom.Resource.VolumeCounterVolumeRemaining + volumeCount
					: NinjaTrader.Custom.Resource.VolumeCounterVolumeCount + volumeCount) + (ShowPercent ? "%" : ""))
				: NinjaTrader.Custom.Resource.VolumeCounterBarError;

			Draw.TextFixed(this, "NinjaScriptInfo", volume1, TextPosition.BottomRight);
		}

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "CountDown", GroupName = "NinjaScriptParameters", Order = 0)]
		public bool CountDown
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "ShowPercent", GroupName = "NinjaScriptParameters", Order = 0)]
		public bool ShowPercent
		{ get; set; }
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private VolumeCounter[] cacheVolumeCounter;
		public VolumeCounter VolumeCounter(bool countDown, bool showPercent)
		{
			return VolumeCounter(Input, countDown, showPercent);
		}

		public VolumeCounter VolumeCounter(ISeries<double> input, bool countDown, bool showPercent)
		{
			if (cacheVolumeCounter != null)
				for (int idx = 0; idx < cacheVolumeCounter.Length; idx++)
					if (cacheVolumeCounter[idx] != null && cacheVolumeCounter[idx].CountDown == countDown && cacheVolumeCounter[idx].ShowPercent == showPercent && cacheVolumeCounter[idx].EqualsInput(input))
						return cacheVolumeCounter[idx];
			return CacheIndicator<VolumeCounter>(new VolumeCounter(){ CountDown = countDown, ShowPercent = showPercent }, input, ref cacheVolumeCounter);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.VolumeCounter VolumeCounter(bool countDown, bool showPercent)
		{
			return indicator.VolumeCounter(Input, countDown, showPercent);
		}

		public Indicators.VolumeCounter VolumeCounter(ISeries<double> input , bool countDown, bool showPercent)
		{
			return indicator.VolumeCounter(input, countDown, showPercent);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.VolumeCounter VolumeCounter(bool countDown, bool showPercent)
		{
			return indicator.VolumeCounter(Input, countDown, showPercent);
		}

		public Indicators.VolumeCounter VolumeCounter(ISeries<double> input , bool countDown, bool showPercent)
		{
			return indicator.VolumeCounter(input, countDown, showPercent);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Volume Oscillator measures volume by calculating the difference of a fast and
	/// a slow moving average of volume. The Volume Oscillator can provide insight into the
	/// strength or weakness of a price trend. A positive value suggests there is enough
	/// market support to continue driving price activity in the direction of the current
	/// trend. A negative value suggests there is a lack of support, that prices may begin
	/// to become stagnant or reverse.
	/// </summary>
	public class VolumeOscillator : Indicator
	{
		private SMA smaFast;
		private SMA smaSlow;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionVolumeOscillator;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVolumeOscillator;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= false;
				DrawOnPricePanel			= false;
				Fast						= 12;
				Slow						= 26;

				AddPlot(new Stroke(Brushes.DodgerBlue, 2), PlotStyle.Bar, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVolumeOscillator);
			}
			else if (State == State.DataLoaded)
			{
				smaFast	= SMA(Volume, Fast);
				smaSlow	= SMA(Volume, Slow);
			}
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			double value = smaFast[0] - smaSlow[0];
			if (Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency)
				value = Core.Globals.ToCryptocurrencyVolume((long)value);
			Value[0] = value;
		}

		#region Properties

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof (Custom.Resource), Name = "Fast", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Fast
		{ get; set; }


		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof (Custom.Resource), Name = "Slow", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Slow
		{ get; set; }

		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private VolumeOscillator[] cacheVolumeOscillator;
		public VolumeOscillator VolumeOscillator(int fast, int slow)
		{
			return VolumeOscillator(Input, fast, slow);
		}

		public VolumeOscillator VolumeOscillator(ISeries<double> input, int fast, int slow)
		{
			if (cacheVolumeOscillator != null)
				for (int idx = 0; idx < cacheVolumeOscillator.Length; idx++)
					if (cacheVolumeOscillator[idx] != null && cacheVolumeOscillator[idx].Fast == fast && cacheVolumeOscillator[idx].Slow == slow && cacheVolumeOscillator[idx].EqualsInput(input))
						return cacheVolumeOscillator[idx];
			return CacheIndicator<VolumeOscillator>(new VolumeOscillator(){ Fast = fast, Slow = slow }, input, ref cacheVolumeOscillator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.VolumeOscillator VolumeOscillator(int fast, int slow)
		{
			return indicator.VolumeOscillator(Input, fast, slow);
		}

		public Indicators.VolumeOscillator VolumeOscillator(ISeries<double> input , int fast, int slow)
		{
			return indicator.VolumeOscillator(input, fast, slow);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.VolumeOscillator VolumeOscillator(int fast, int slow)
		{
			return indicator.VolumeOscillator(Input, fast, slow);
		}

		public Indicators.VolumeOscillator VolumeOscillator(ISeries<double> input , int fast, int slow)
		{
			return indicator.VolumeOscillator(input, fast, slow);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Core;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class VolumeProfile : Indicator
	{
		#region Properties
		internal class VolumeInfoItem
		{
			public double up;
			public double down;
			public double neutral;
		}

		private double			alpha				= 50;
		private double			askPrice;
		private int				barSpacing			= 1;
		private double			bidPrice;
		private DateTime		cacheSessionEnd		= Globals.MinDate;
		private DateTime		currentDate			= Globals.MinDate;
		private bool			drawLines;
		private List<int>		newSessionBarIdx	= new List<int>();
		private DateTime		sessionDateTmp		= Globals.MinDate;
		private SessionIterator sessionIterator;
		private int				startIndexOf;
		private SessionIterator storedSession;

		private List<Dictionary<double, VolumeInfoItem>> 	sortedDicList   = new List<Dictionary<double, VolumeInfoItem>>();
		private Dictionary<double, VolumeInfoItem> 			cacheDictionary = new Dictionary<double, VolumeInfoItem>();
		#endregion

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionVolumeProfile;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVolumeProfile;
				Calculate					= Calculate.OnEachTick;
				DrawLines					= false;
				IsChartOnly					= true;
				IsOverlay					= true;
				DrawOnPricePanel			= false;
				LineBrush					= Brushes.DarkGray;
				VolumeDownBrush				= Brushes.Crimson;
				VolumeNeutralBrush			= Brushes.DarkGray;
				VolumeUpBrush				= Brushes.DarkCyan;
			}
			else if (State == State.Configure)
			{
				ZOrder = -1;
			}
			else if (State == State.DataLoaded)
			{
				storedSession = new SessionIterator(Bars);
			}
			else if (State == State.Historical)
			{
				if (Calculate != Calculate.OnEachTick)
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnBarCloseError, Name), TextPosition.BottomRight);
			}
		}

		protected override void OnBarUpdate() { }

		private DateTime GetLastBarSessionDate(DateTime time)
		{
			if (time <= cacheSessionEnd)
				return sessionDateTmp;
			
			if (!Bars.BarsType.IsIntraday)
				return sessionDateTmp;

			storedSession.GetNextSession(time, true);
			
			cacheSessionEnd = storedSession.ActualSessionEnd;
			sessionDateTmp 	= TimeZoneInfo.ConvertTime(cacheSessionEnd.AddSeconds(-1), Globals.GeneralOptions.TimeZoneInfo, Bars.TradingHours.TimeZoneInfo);

			if(newSessionBarIdx.Count == 0 || newSessionBarIdx.Count > 0 && CurrentBar > newSessionBarIdx[newSessionBarIdx.Count - 1])
				newSessionBarIdx.Add(CurrentBar);

			return sessionDateTmp;
		}

		protected override void OnMarketData(MarketDataEventArgs e)
		{
			if (Bars.Count <= 0)
				return;

			double			price;
			long			volume;
			VolumeInfoItem	volumeInfoItem;
			DateTime		lastBarTimeStamp = GetLastBarSessionDate(Time[0]);

			if (lastBarTimeStamp != currentDate)
			{
				cacheDictionary = new Dictionary<double, VolumeInfoItem>();
				sortedDicList.Add(cacheDictionary);
			}

			currentDate = lastBarTimeStamp;
			if (Bars.IsTickReplay)
			{
				if (e.MarketDataType == MarketDataType.Last)
				{
					price	= e.Price;
					volume	= e.Volume;

					if (!cacheDictionary.ContainsKey(price))
						cacheDictionary.Add(price, new VolumeInfoItem());

					volumeInfoItem = cacheDictionary[price];

					if (price >= e.Ask)
						volumeInfoItem.up		+= volume;
					else if (price <= e.Bid)
						volumeInfoItem.down		+= volume;
					else
						volumeInfoItem.neutral	+= volume;
				}
			}
			else
			{
				if (e.MarketDataType == MarketDataType.Ask)
				{
					askPrice = e.Price;
					return;
				}

				if (e.MarketDataType == MarketDataType.Bid)
				{
					bidPrice = e.Price;
					return;
				}

				if (e.MarketDataType != MarketDataType.Last || ChartControl == null || askPrice == 0 || bidPrice == 0)
					return;

				if (Bars != null && !SessionIterator.IsInSession(Core.Globals.Now, true, true))
					return;

				price	= e.Price;
				volume	= e.Volume;

				if (!cacheDictionary.ContainsKey(price))
					cacheDictionary.Add(price, new VolumeInfoItem());

				volumeInfoItem = cacheDictionary[price];

				if (price >= askPrice)
					volumeInfoItem.up		+= volume;
				else if (price <= bidPrice)
					volumeInfoItem.down		+= volume;
				else
					volumeInfoItem.neutral	+= volume;
			}
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
		{
			if(Bars == null || Bars.Instrument == null || IsInHitTest)
				return;

			int		firstBarIdxToPaint	= -1;
			double	tickSize			= Bars.Instrument.MasterInstrument.TickSize;
			double	volumeMax			= 0;

			SharpDX.Direct2D1.Brush upBrush			= VolumeUpBrush.ToDxBrush(RenderTarget);
			SharpDX.Direct2D1.Brush downBrush		= VolumeDownBrush.ToDxBrush(RenderTarget);
			SharpDX.Direct2D1.Brush neutralBrush	= VolumeNeutralBrush.ToDxBrush(RenderTarget);
			SharpDX.Direct2D1.Brush lineBrushDx		= LineBrush.ToDxBrush(RenderTarget);

			upBrush.Opacity			= (float)(alpha / 100.0);
			downBrush.Opacity		= (float)(alpha / 100.0);
			neutralBrush.Opacity	= (float)(alpha / 100.0);

			for (int i = newSessionBarIdx.Count - 1; i > 0; i--)
			{
				if (newSessionBarIdx[i] <= ChartBars.ToIndex)
				{
					startIndexOf		= i;
					firstBarIdxToPaint	= newSessionBarIdx[i];
					break;
				}
			}
			
			if (sortedDicList.Count < 1 && cacheDictionary.Keys.Count > 0)
				sortedDicList.Add(cacheDictionary);

			foreach (Dictionary<double, VolumeInfoItem> tmpDict in sortedDicList)
			{
				foreach (KeyValuePair<double, VolumeInfoItem> keyValue in tmpDict)
				{
					double price = keyValue.Key;

					if (Bars.BarsType.IsIntraday && (price > chartScale.MaxValue || price < chartScale.MinValue))
						continue;

					VolumeInfoItem	vii		= keyValue.Value;
					double			total	= vii.up + vii.down + vii.neutral;
					volumeMax				= Math.Max(volumeMax, total);
				}
			}

			if (volumeMax.ApproxCompare(0) == 0)
				return;

			int viiPositions = 0;

			foreach (KeyValuePair<double, VolumeInfoItem> keyValue in sortedDicList[startIndexOf])
			{
				viiPositions++;

				VolumeInfoItem vii = keyValue.Value;

				double	priceLower			= keyValue.Key - tickSize / 2;
				float	yLower				= chartScale.GetYByValue(priceLower);
				float	yUpper				= chartScale.GetYByValue(priceLower + tickSize);
				float	height				= Math.Max(1, Math.Abs(yUpper - yLower) - barSpacing);
				int		barWidthUp			= (int)((ChartPanel.W / 2) * (vii.up / volumeMax));
				int		barWidthNeutral		= (int)((ChartPanel.W / 2) * (vii.neutral / volumeMax));
				int		barWidthDown		= (int)((ChartPanel.W / 2) * (vii.down / volumeMax));
				float	stationaryXpos		= chartControl.GetXByBarIndex(ChartBars, !Bars.IsTickReplay ? ChartBars.FromIndex : Math.Max(ChartBars.FromIndex, firstBarIdxToPaint));
				float	xpos				= chartControl.GetXByBarIndex(ChartBars, !Bars.IsTickReplay ? ChartBars.FromIndex : Math.Max(1, Math.Max(ChartBars.FromIndex, firstBarIdxToPaint)) - 1);

				RenderTarget.FillRectangle(new SharpDX.RectangleF(xpos, yUpper, barWidthUp, height), upBrush);
				xpos += barWidthUp;
				RenderTarget.FillRectangle(new SharpDX.RectangleF(xpos, yUpper, barWidthNeutral, height), neutralBrush);
				xpos += barWidthNeutral;
				RenderTarget.FillRectangle(new SharpDX.RectangleF(xpos, yUpper, barWidthDown, height), downBrush);

				if (!drawLines)
					continue;
				
				// Lower line
				RenderTarget.DrawLine(new SharpDX.Vector2(stationaryXpos, yLower), new SharpDX.Vector2((ChartPanel.X + ChartPanel.W), yLower), lineBrushDx);

				// Upper line (only at very top)
				if (viiPositions == sortedDicList[startIndexOf].Count)
					RenderTarget.DrawLine(new SharpDX.Vector2(stationaryXpos, yUpper), new SharpDX.Vector2((ChartPanel.X + ChartPanel.W), yUpper), lineBrushDx);
			}

			lineBrushDx.Dispose();
			upBrush.Dispose();
			downBrush.Dispose();
			neutralBrush.Dispose();
		}

		#region Properties
		[Range(0, double.MaxValue)]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Opacity", Order = 0, GroupName = "NinjaScriptParameters")]
		public double Opacity
		{
			get { return alpha; }
			set { alpha = Math.Max(1, value); }
		}

		[Display(ResourceType = typeof(Custom.Resource), Name = "DrawLines", Order = 1, GroupName = "NinjaScriptParameters")]
		public bool DrawLines
		{
			get { return drawLines; }
			set { drawLines = value; }
		}

		[XmlIgnore]
		[Display(ResourceType = typeof(Custom.Resource), Name = "LineColor", Order = 2, GroupName = "NinjaScriptParameters")]
		public Brush LineBrush { get; set; }

		[Browsable(false)]
		public string LineBrushSerialize
		{
			get { return Serialize.BrushToString(LineBrush); }
			set { LineBrush = Serialize.StringToBrush(value); }
		}

		private SessionIterator SessionIterator
		{
			get
			{
				if (sessionIterator == null)
					sessionIterator = new SessionIterator(Bars);
				return sessionIterator;
			}
		}

		[XmlIgnore]
		[Display(ResourceType = typeof(Custom.Resource), Name = "VolumeDownColor", Order = 3, GroupName = "NinjaScriptParameters")]
		public Brush VolumeDownBrush { get; set; }

		[Browsable(false)]
		public string VolumeDownBrushSerialize
		{
			get { return Serialize.BrushToString(VolumeDownBrush); }
			set { VolumeDownBrush = Serialize.StringToBrush(value); }
		}

		[XmlIgnore]
		[Display(ResourceType = typeof(Custom.Resource), Name = "VolumeNeutralColor", Order = 4, GroupName = "NinjaScriptParameters")]
		public Brush VolumeNeutralBrush { get; set; }

		[Browsable(false)]
		public string VolumeNeutralBrushSerialize
		{
			get { return Serialize.BrushToString(VolumeNeutralBrush); }
			set { VolumeNeutralBrush = Serialize.StringToBrush(value); }
		}

		[XmlIgnore]
		[Display(ResourceType = typeof(Custom.Resource), Name = "VolumeUpColor", Order = 5, GroupName = "NinjaScriptParameters")]
		public Brush VolumeUpBrush { get; set; }

		[Browsable(false)]
		public string VolumeUpBrushSerialize
		{
			get { return Serialize.BrushToString(VolumeUpBrush); }
			set { VolumeUpBrush = Serialize.StringToBrush(value); }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private VolumeProfile[] cacheVolumeProfile;
		public VolumeProfile VolumeProfile()
		{
			return VolumeProfile(Input);
		}

		public VolumeProfile VolumeProfile(ISeries<double> input)
		{
			if (cacheVolumeProfile != null)
				for (int idx = 0; idx < cacheVolumeProfile.Length; idx++)
					if (cacheVolumeProfile[idx] != null &&  cacheVolumeProfile[idx].EqualsInput(input))
						return cacheVolumeProfile[idx];
			return CacheIndicator<VolumeProfile>(new VolumeProfile(), input, ref cacheVolumeProfile);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.VolumeProfile VolumeProfile()
		{
			return indicator.VolumeProfile(Input);
		}

		public Indicators.VolumeProfile VolumeProfile(ISeries<double> input )
		{
			return indicator.VolumeProfile(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.VolumeProfile VolumeProfile()
		{
			return indicator.VolumeProfile(Input);
		}

		public Indicators.VolumeProfile VolumeProfile(ISeries<double> input )
		{
			return indicator.VolumeProfile(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class VolumeUpDown : Indicator
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Calculate					= Calculate.OnBarClose;
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionVolumeUpDown;
				DrawOnPricePanel			= false;
				IsOverlay					= false;
				IsSuspendedWhileInactive	= true;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVolumeUpDown;

				AddPlot(new Stroke(Brushes.DarkCyan, 2),	PlotStyle.Bar,	NinjaTrader.Custom.Resource.VolumeUp);
				AddPlot(new Stroke(Brushes.Crimson, 2),		PlotStyle.Bar,	NinjaTrader.Custom.Resource.VolumeDown);
				AddLine(Brushes.DarkGray,					0,				NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (Close[0] >= Open[0])
			{
				UpVolume[0] = Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0];
				DownVolume.Reset();
			}
			else
			{
				UpVolume.Reset();
				DownVolume[0] = Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0];
			}
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> DownVolume
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> UpVolume
		{
			get { return Values[0]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private VolumeUpDown[] cacheVolumeUpDown;
		public VolumeUpDown VolumeUpDown()
		{
			return VolumeUpDown(Input);
		}

		public VolumeUpDown VolumeUpDown(ISeries<double> input)
		{
			if (cacheVolumeUpDown != null)
				for (int idx = 0; idx < cacheVolumeUpDown.Length; idx++)
					if (cacheVolumeUpDown[idx] != null &&  cacheVolumeUpDown[idx].EqualsInput(input))
						return cacheVolumeUpDown[idx];
			return CacheIndicator<VolumeUpDown>(new VolumeUpDown(), input, ref cacheVolumeUpDown);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.VolumeUpDown VolumeUpDown()
		{
			return indicator.VolumeUpDown(Input);
		}

		public Indicators.VolumeUpDown VolumeUpDown(ISeries<double> input )
		{
			return indicator.VolumeUpDown(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.VolumeUpDown VolumeUpDown()
		{
			return indicator.VolumeUpDown(Input);
		}

		public Indicators.VolumeUpDown VolumeUpDown(ISeries<double> input )
		{
			return indicator.VolumeUpDown(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class VolumeZones : Indicator
	{
		internal struct VolumeInfo
		{
			public double up;
			public double down;
			public double total;
		}

		private VolumeInfo[] volumeInfo = new VolumeInfo[20];

		private int barCount;
		private int barSpacing;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionVolumeZones;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVolumesZones;
				Calculate					= Calculate.OnBarClose;
				IsChartOnly					= true;
				IsOverlay					= true;
				DisplayInDataBox			= false;
				PaintPriceMarkers			= false;
				DrawLines					= false;
				Opacity						= 50;
				BarCount					= 10;
				BarSpacing					= 1;
				BarDownBrush				= Brushes.Crimson;
				BarUpBrush					= Brushes.DarkCyan;
				LineBrush					= Brushes.DarkGray;
			}
			else if (State == State.Configure)
			{
				ZOrder = -1;
			}
		}

		protected override void OnBarUpdate()
		{
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
		{
			if (IsInHitTest) return;

			int		lastBar		= ChartBars.ToIndex;
			int		firstBar	= ChartBars.FromIndex;
			double	highPrice	= 0;
			double	lowPrice	= double.MaxValue;

			SharpDX.Direct2D1.Brush brushDown	= BarDownBrush.ToDxBrush(RenderTarget);
			SharpDX.Direct2D1.Brush lineBrush	= LineBrush.ToDxBrush(RenderTarget);
			SharpDX.Direct2D1.Brush brushUp		= BarUpBrush.ToDxBrush(RenderTarget);
			brushDown.Opacity					= (float)(Opacity / 100.0);
			brushUp.Opacity						= (float)(Opacity / 100.0);

			for (int idx = firstBar; idx <= lastBar && idx >= 0; idx++)
			{
				highPrice	= Math.Max(highPrice, Bars.GetHigh(idx));
				lowPrice	= Math.Min(lowPrice, Bars.GetLow(idx));
			}

			int		volumeBarCount	= BarCount;
			double	priceRange		= highPrice - lowPrice;
			double	priceBoxSize	= priceRange / volumeBarCount;
			double	volumeMax		= 0;

			// Pass 1: Fill all VolumeInfo structures with appropriate data
			for (int i = 0; i < volumeBarCount; i++)
			{

				double priceUpper = lowPrice + priceBoxSize * (i + 1);
				double priceLower = lowPrice + priceBoxSize * i;

				double priceVolumeUp   = 0;
				double priceVolumeDown = 0;

				for (int idx = firstBar; idx <= lastBar; idx++)
				{
					double checkPrice;

					PriceSeries series = (Inputs[0] as PriceSeries);

					switch (series.PriceType)
					{
						case PriceType.Open:		checkPrice = Bars.GetOpen(idx); break;
						case PriceType.Close:		checkPrice = Bars.GetClose(idx); break;
						case PriceType.High:		checkPrice = Bars.GetHigh(idx); break;
						case PriceType.Low:			checkPrice = Bars.GetLow(idx); break;
						case PriceType.Median:		checkPrice = (Bars.GetHigh(idx) + Bars.GetLow(idx)) / 2; break;
						case PriceType.Typical:		checkPrice = (Bars.GetHigh(idx) + Bars.GetLow(idx) + Bars.GetClose(idx)) / 3; break;
						case PriceType.Weighted:	checkPrice = (Bars.GetHigh(idx) + Bars.GetLow(idx) + 2 * Bars.GetClose(idx)) / 4; break;
						default:					checkPrice = Bars.GetClose(idx); break;
					}

					if (checkPrice >= priceLower && checkPrice < priceUpper)
					{
						if (Bars.GetOpen(idx) < Bars.GetClose(idx))
							priceVolumeUp += Bars.GetVolume(idx);
						else
							priceVolumeDown += Bars.GetVolume(idx);
					}
				}

				volumeInfo[i].up	= priceVolumeUp;
				volumeInfo[i].down	= priceVolumeDown;
				volumeInfo[i].total = priceVolumeUp + priceVolumeDown;

				volumeMax = Math.Max(volumeMax, volumeInfo[i].total);
			}

			// Pass 2: Paint the volume bars
			for (int i = 0; i < Math.Min(volumeBarCount, lastBar - firstBar + 1); i++)
			{
				double	priceUpper		= lowPrice + priceBoxSize * (i + 1);
				double	priceLower		= lowPrice + priceBoxSize * i;
				int		yUpper			= Convert.ToInt32(chartScale.GetYByValue(priceUpper)) + BarSpacing;
				int		yLower			= Convert.ToInt32(chartScale.GetYByValue(priceLower));
				int		barWidthUp		= (int)((chartScale.Height / 2) * (volumeInfo[i].up / volumeMax));
				int		barWidthDown	= (int)((chartScale.Height / 2) * (volumeInfo[i].down / volumeMax));

				SharpDX.RectangleF rect = new SharpDX.RectangleF(ChartPanel.X, yUpper, barWidthUp, Math.Abs(yUpper - yLower));
				RenderTarget.FillRectangle(rect, brushUp);
				RenderTarget.DrawRectangle(rect, brushUp);

				SharpDX.RectangleF rect2 = new SharpDX.RectangleF(ChartPanel.X + barWidthUp, yUpper, barWidthDown, Math.Abs(yUpper - yLower));
				RenderTarget.DrawRectangle(rect2, brushDown);
				RenderTarget.FillRectangle(rect2, brushDown);

				if (DrawLines)
				{
					RenderTarget.DrawLine(new SharpDX.Vector2(ChartPanel.X, yLower), new SharpDX.Vector2(ChartPanel.X + ChartPanel.W, yLower), lineBrush);
					if( i == volumeBarCount - 1)
						RenderTarget.DrawLine(new SharpDX.Vector2(ChartPanel.X, yUpper), new SharpDX.Vector2(ChartPanel.X + ChartPanel.W, yUpper), lineBrush);
				}
			}

			lineBrush.Dispose();
			brushDown.Dispose();
			brushUp.Dispose();
		}

		#region Properties
		[Range(2, 20)]
		[Display(ResourceType = typeof(Custom.Resource), Name = "BarCount", Order = 1, GroupName = "NinjaScriptParameters")]
		public int BarCount
		{
			get { return barCount; }
			set
			{
				barCount = value;
				if (value > volumeInfo.Length)
					volumeInfo = new VolumeInfo[value];
			}
		}

		[Range(0, 5)]
		[Display(ResourceType = typeof(Custom.Resource), Name = "BarSpacing", Order = 2, GroupName = "NinjaScriptParameters")]
		public int BarSpacing
		{
			get { return barSpacing; }
			set { barSpacing = Math.Max(0, value); }
		}

		[XmlIgnore]
		[Display(ResourceType = typeof(Custom.Resource), Name = "DownBarColor", Order = 3, GroupName = "NinjaScriptParameters")]
		public Brush BarDownBrush
		{ get; set; }

		[Browsable(false)]
		public string BarColorDownSerialize
		{
			get { return Serialize.BrushToString(BarDownBrush); }
			set { BarDownBrush = Serialize.StringToBrush(value); }
		}

		[Display(ResourceType = typeof(Custom.Resource), Name = "DrawLines", Order = 4, GroupName = "NinjaScriptParameters")]
		public bool DrawLines
		{ get; set; }

		[XmlIgnore]
		[Display(ResourceType = typeof(Custom.Resource), Name = "LineColor", Order = 5, GroupName = "NinjaScriptParameters")]
		public Brush LineBrush
		{ get; set; }

		[Browsable(false)]
		public string LineBrushSerialize
		{
			get { return Serialize.BrushToString(LineBrush); }
			set { LineBrush = Serialize.StringToBrush(value); }
		}
		[XmlIgnore]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UpBarColor", Order = 6, GroupName = "NinjaScriptParameters")]
		public Brush BarUpBrush
		{ get; set; }

		[Browsable(false)]
		public string BarColorUpSerialize
		{
			get { return Serialize.BrushToString(BarUpBrush); }
			set { BarUpBrush = Serialize.StringToBrush(value); }
		}

		[Range(10, 100)]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Opacity", Order = 7, GroupName = "NinjaScriptParameters")]
		public double Opacity
		{ get; set; }

		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private VolumeZones[] cacheVolumeZones;
		public VolumeZones VolumeZones()
		{
			return VolumeZones(Input);
		}

		public VolumeZones VolumeZones(ISeries<double> input)
		{
			if (cacheVolumeZones != null)
				for (int idx = 0; idx < cacheVolumeZones.Length; idx++)
					if (cacheVolumeZones[idx] != null &&  cacheVolumeZones[idx].EqualsInput(input))
						return cacheVolumeZones[idx];
			return CacheIndicator<VolumeZones>(new VolumeZones(), input, ref cacheVolumeZones);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.VolumeZones VolumeZones()
		{
			return indicator.VolumeZones(Input);
		}

		public Indicators.VolumeZones VolumeZones(ISeries<double> input )
		{
			return indicator.VolumeZones(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.VolumeZones VolumeZones()
		{
			return indicator.VolumeZones(Input);
		}

		public Indicators.VolumeZones VolumeZones(ISeries<double> input )
		{
			return indicator.VolumeZones(input);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Vortex indicator is an oscillator used to identify trends. A bullish signal triggers when the VIPlus line crosses above the VIMinus line. A bearish signal triggers when the VIMinus line crosses above the VIPlus line.
	/// </summary>
	public class Vortex : Indicator
	{
		private Series<double> vmPlus;
		private Series<double> vmMinus;
		private Series<double> trueRange;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionVortex;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVortex;
				IsOverlay					= false;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.RoyalBlue,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorVIPlus);
				AddPlot(Brushes.Red,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorVIMinus);
			}
			else if (State == State.DataLoaded)
			{				
				vmPlus		= new Series<double>(this);
				vmMinus		= new Series<double>(this);
				trueRange	= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < 1)
				return;
			
			vmPlus[0] 		= Math.Abs(High[0] - Low[1]);
			vmMinus[0]		= Math.Abs(Low[0] - High[1]);
			trueRange[0]	= Math.Max(Math.Max(Math.Abs(High[0] - Close[1]), Math.Abs(Low[0] - Close[1])), High[0]-Low[0]);
            VIPlus[0]		= SUM(vmPlus, Period)[0] / SUM(trueRange, Period)[0];
            VIMinus[0]		= SUM(vmMinus, Period)[0] / SUM(trueRange, Period)[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> VIPlus
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> VIMinus
		{
			get { return Values[1]; }
		}
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Vortex[] cacheVortex;
		public Vortex Vortex(int period)
		{
			return Vortex(Input, period);
		}

		public Vortex Vortex(ISeries<double> input, int period)
		{
			if (cacheVortex != null)
				for (int idx = 0; idx < cacheVortex.Length; idx++)
					if (cacheVortex[idx] != null && cacheVortex[idx].Period == period && cacheVortex[idx].EqualsInput(input))
						return cacheVortex[idx];
			return CacheIndicator<Vortex>(new Vortex(){ Period = period }, input, ref cacheVortex);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Vortex Vortex(int period)
		{
			return indicator.Vortex(Input, period);
		}

		public Indicators.Vortex Vortex(ISeries<double> input , int period)
		{
			return indicator.Vortex(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Vortex Vortex(int period)
		{
			return indicator.Vortex(Input, period);
		}

		public Indicators.Vortex Vortex(ISeries<double> input , int period)
		{
			return indicator.Vortex(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The VROC (Volume Rate-of-Change) shows whether or not a volume trend is
	/// developing in either an up or down direction. It is similar to the ROC
	/// indicator, but is applied to volume instead.
	/// </summary>
	public class VROC : Indicator
	{
		private Series<double>	smaVolume;
		private SMA				sma;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionVROC;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVROC;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= false;
				DrawOnPricePanel			= false;
				Period						= 14;
				Smooth						= 3;

				AddPlot(Brushes.Goldenrod,		NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVROC);
				AddLine(Brushes.DarkGray,	0,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}

			else if (State == State.DataLoaded)
			{
				smaVolume	= new Series<double>(this);
				sma			= SMA(smaVolume, Smooth);
			}
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			double back 	= Volume[Math.Min(CurrentBar, Period - 1)];
			double volume0	= Volume[0];

			if (Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency)
			{
				back		= Core.Globals.ToCryptocurrencyVolume((long)back);
				volume0		= Core.Globals.ToCryptocurrencyVolume((long)volume0);
			}
			smaVolume[0] 	= (100 * volume0 / (back == 0 ? 1 : back)) - 100;
			Value[0]		= sma[0];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private VROC[] cacheVROC;
		public VROC VROC(int period, int smooth)
		{
			return VROC(Input, period, smooth);
		}

		public VROC VROC(ISeries<double> input, int period, int smooth)
		{
			if (cacheVROC != null)
				for (int idx = 0; idx < cacheVROC.Length; idx++)
					if (cacheVROC[idx] != null && cacheVROC[idx].Period == period && cacheVROC[idx].Smooth == smooth && cacheVROC[idx].EqualsInput(input))
						return cacheVROC[idx];
			return CacheIndicator<VROC>(new VROC(){ Period = period, Smooth = smooth }, input, ref cacheVROC);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.VROC VROC(int period, int smooth)
		{
			return indicator.VROC(Input, period, smooth);
		}

		public Indicators.VROC VROC(ISeries<double> input , int period, int smooth)
		{
			return indicator.VROC(input, period, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.VROC VROC(int period, int smooth)
		{
			return indicator.VROC(Input, period, smooth);
		}

		public Indicators.VROC VROC(ISeries<double> input , int period, int smooth)
		{
			return indicator.VROC(input, period, smooth);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The VWMA (Volume-Weighted Moving Average) returns the volume-weighted moving average
	/// for the specified price series and period. VWMA is similar to a Simple Moving Average
	/// (SMA), but each bar of data is weighted by the bar's Volume. VWMA places more significance
	/// on the days with the largest volume and the least for the days with lowest volume for the period specified.
	/// </summary>
	public class VWMA : Indicator
	{
		private double			priorVolPriceSum;
		private double			volPriceSum;
		private Series<double>	volSum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionVWMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVWMA;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				DrawOnPricePanel			= false;
				Period						= 14;

				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameVWMA);
			}
			else if (State == State.DataLoaded)
				volSum	= new Series<double>(this);
			else if (State == State.Historical)
			{
				if (Calculate == Calculate.OnPriceChange)
				{
					Draw.TextFixed(this, "NinjaScriptInfo", string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), TextPosition.BottomRight);
					Log(string.Format(NinjaTrader.Custom.Resource.NinjaScriptOnPriceChangeError, Name), LogLevel.Error);
				}
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				int numBars = Math.Min(CurrentBar, Period);

				double volPriceSum = 0;
				double volSum = 0;
				double vol = 0;
				for (int i = 0; i < numBars; i++)
				{
					vol			= Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[i]) : Volume[i];
					volPriceSum += Input[i] * vol;
					volSum		+= vol;
				}

				// Protect agains div by zero evilness
				if (volSum <= double.Epsilon)
					Value[0] = volPriceSum;
				else
					Value[0] = volPriceSum / volSum;
			}
			else
			{
				if (IsFirstTickOfBar)
					priorVolPriceSum = volPriceSum;

				double volume0		= Volume[0];
				double volumePeriod = Volume[Math.Min(Period, CurrentBar)];
				if (Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency)
				{
					volume0			= Core.Globals.ToCryptocurrencyVolume((long)volume0);
					volumePeriod	= Core.Globals.ToCryptocurrencyVolume((long)volumePeriod);
				}
				volPriceSum = priorVolPriceSum + Input[0] * volume0 - (CurrentBar >= Period ? Input[Period] * volumePeriod : 0);
				volSum[0]	= volume0 + (CurrentBar > 0 ? volSum[1] : 0) - (CurrentBar >= Period ? volumePeriod : 0);
				Value[0]	= volSum[0].ApproxCompare(0) == 0 ? volPriceSum : volPriceSum / volSum[0];
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private VWMA[] cacheVWMA;
		public VWMA VWMA(int period)
		{
			return VWMA(Input, period);
		}

		public VWMA VWMA(ISeries<double> input, int period)
		{
			if (cacheVWMA != null)
				for (int idx = 0; idx < cacheVWMA.Length; idx++)
					if (cacheVWMA[idx] != null && cacheVWMA[idx].Period == period && cacheVWMA[idx].EqualsInput(input))
						return cacheVWMA[idx];
			return CacheIndicator<VWMA>(new VWMA(){ Period = period }, input, ref cacheVWMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.VWMA VWMA(int period)
		{
			return indicator.VWMA(Input, period);
		}

		public Indicators.VWMA VWMA(ISeries<double> input , int period)
		{
			return indicator.VWMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.VWMA VWMA(int period)
		{
			return indicator.VWMA(Input, period);
		}

		public Indicators.VWMA VWMA(ISeries<double> input , int period)
		{
			return indicator.VWMA(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Williams %R is a momentum indicator that is designed to identify overbought and oversold areas in a nontrending market.
	/// </summary>
	public class WilliamsR : Indicator
	{
		private MAX max;
		private MIN min;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionWilliamsR;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameWilliamsR;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddLine(Brushes.DarkGray,	-25,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorUpper);
				AddLine(Brushes.DarkGray,	-75,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorLower);
				AddPlot(Brushes.Goldenrod,			NinjaTrader.Custom.Resource.WilliamsPercentR);
			}
			else if (State == State.DataLoaded)
			{
				max = MAX(High, Period);
				min	= MIN(Low, Period);
			}
		}

		protected override void OnBarUpdate()
		{
			double max0	= max[0];
			double min0	= min[0];
			Value[0]	= -100 * (max0 - Close[0]) / (max0 - min0 == 0 ? 1 : max0 - min0);
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private WilliamsR[] cacheWilliamsR;
		public WilliamsR WilliamsR(int period)
		{
			return WilliamsR(Input, period);
		}

		public WilliamsR WilliamsR(ISeries<double> input, int period)
		{
			if (cacheWilliamsR != null)
				for (int idx = 0; idx < cacheWilliamsR.Length; idx++)
					if (cacheWilliamsR[idx] != null && cacheWilliamsR[idx].Period == period && cacheWilliamsR[idx].EqualsInput(input))
						return cacheWilliamsR[idx];
			return CacheIndicator<WilliamsR>(new WilliamsR(){ Period = period }, input, ref cacheWilliamsR);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.WilliamsR WilliamsR(int period)
		{
			return indicator.WilliamsR(Input, period);
		}

		public Indicators.WilliamsR WilliamsR(ISeries<double> input , int period)
		{
			return indicator.WilliamsR(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.WilliamsR WilliamsR(int period)
		{
			return indicator.WilliamsR(Input, period);
		}

		public Indicators.WilliamsR WilliamsR(ISeries<double> input , int period)
		{
			return indicator.WilliamsR(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The WMA (Weighted Moving Average) is a Moving Average indicator that shows the average
	/// value of a security's price over a period of time with special emphasis on the more recent
	/// portions of the time period under analysis as opposed to the earlier.
	/// </summary>
	public class WMA : Indicator
	{
		private	int		myPeriod;
		private double	priorSum;
		private double	priorWsum;
		private double	sum;
		private double	wsum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{

				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionWMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameWMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameWMA);
			}
			else if (State == State.Configure)
			{
				priorSum	= 0;
				priorWsum	= 0;
				sum			= 0;
				wsum		= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				if (CurrentBar == 0)
					Value[0] = Input[0];
				else
				{
					int back = Math.Min(Period - 1, CurrentBar);
					double val = 0;
					int weight = 0;
					for (int idx = back; idx >= 0; idx--)
					{
						val += (idx + 1) * Input[back - idx];
						weight += (idx + 1);
					}
					Value[0] = val / weight;
				}
			}
			else
			{
				if (IsFirstTickOfBar)
				{
					priorWsum = wsum;
					priorSum = sum;
					myPeriod = Math.Min(CurrentBar + 1, Period);
				}

				wsum = priorWsum - (CurrentBar >= Period ? priorSum : 0) + myPeriod * Input[0];
				sum = priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);
				Value[0] = wsum / (0.5 * myPeriod * (myPeriod + 1));
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private WMA[] cacheWMA;
		public WMA WMA(int period)
		{
			return WMA(Input, period);
		}

		public WMA WMA(ISeries<double> input, int period)
		{
			if (cacheWMA != null)
				for (int idx = 0; idx < cacheWMA.Length; idx++)
					if (cacheWMA[idx] != null && cacheWMA[idx].Period == period && cacheWMA[idx].EqualsInput(input))
						return cacheWMA[idx];
			return CacheIndicator<WMA>(new WMA(){ Period = period }, input, ref cacheWMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.WMA WMA(int period)
		{
			return indicator.WMA(Input, period);
		}

		public Indicators.WMA WMA(ISeries<double> input , int period)
		{
			return indicator.WMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.WMA WMA(int period)
		{
			return indicator.WMA(Input, period);
		}

		public Indicators.WMA WMA(ISeries<double> input , int period)
		{
			return indicator.WMA(input, period);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The ZigZag indicator shows trend lines filtering out changes below a defined level.
	/// </summary>
	public class ZigZag : Indicator
	{
		private Series<double>		zigZagHighZigZags;
		private Series<double>		zigZagLowZigZags;
		private Series<double>		zigZagHighSeries;
		private Series<double>		zigZagLowSeries;

		private double				currentZigZagHigh;
		private double				currentZigZagLow;
		private int					lastSwingIdx;
		private double				lastSwingPrice;
		private int 				startIndex;
		private int					trendDir;
		
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionZigZag;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameZigZag;
				DeviationType				= DeviationType.Points;
				DeviationValue				= 0.5;
				DisplayInDataBox			= false;
				DrawOnPricePanel			= false;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				PaintPriceMarkers			= false;
				UseHighLow					= false;

				AddPlot(Brushes.DodgerBlue, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameZigZag);

				DisplayInDataBox			= false;
				PaintPriceMarkers			= false;
			}
			else if (State == State.Configure)
			{
				currentZigZagHigh	= 0;
				currentZigZagLow	= 0;
				lastSwingIdx		= -1;
				lastSwingPrice		= 0.0;
				trendDir			= 0; // 1 = trend up, -1 = trend down, init = 0
				startIndex 			= int.MinValue;
			}
			else if (State == State.DataLoaded)
			{
				zigZagHighZigZags	= new Series<double>(this, MaximumBarsLookBack.Infinite);
				zigZagLowZigZags	= new Series<double>(this, MaximumBarsLookBack.Infinite);
				zigZagHighSeries	= new Series<double>(this, MaximumBarsLookBack.Infinite);
				zigZagLowSeries		= new Series<double>(this, MaximumBarsLookBack.Infinite);
			}
		}

		// Returns the number of bars ago a zig zag low occurred. Returns a value of -1 if a zig zag low is not found within the look back period.
		public int LowBar(int barsAgo, int instance, int lookBackPeriod)
		{
			if (instance < 1)
				throw new Exception(string.Format(NinjaTrader.Custom.Resource.ZigZagLowBarInstanceGreaterEqual, GetType().Name, instance));
			if (barsAgo < 0)
				throw new Exception(string.Format(NinjaTrader.Custom.Resource.ZigZigLowBarBarsAgoGreaterEqual, GetType().Name, barsAgo));
			if (barsAgo >= Count)
				throw new Exception(string.Format(NinjaTrader.Custom.Resource.ZigZagLowBarBarsAgoOutOfRange, GetType().Name, (Count - 1), barsAgo));

			Update();
			for (int idx = CurrentBar - barsAgo - 1; idx >= CurrentBar - barsAgo - 1 - lookBackPeriod; idx--)
			{
				if (idx < 0)
					return -1;
				if (idx >= zigZagLowZigZags.Count)
					continue;

				if (!zigZagLowZigZags.IsValidDataPointAt(idx))
					continue;

				if (instance == 1) // 1-based, < to be save
					return CurrentBar - idx;

				instance--;
			}

			return -1;
		}

		// Returns the number of bars ago a zig zag high occurred. Returns a value of -1 if a zig zag high is not found within the look back period.
		public int HighBar(int barsAgo, int instance, int lookBackPeriod)
		{
			if (instance < 1)
				throw new Exception(string.Format(NinjaTrader.Custom.Resource.ZigZagHighBarInstanceGreaterEqual, GetType().Name, instance));
			if (barsAgo < 0)
				throw new Exception(string.Format(NinjaTrader.Custom.Resource.ZigZigHighBarBarsAgoGreaterEqual, GetType().Name, barsAgo));
			if (barsAgo >= Count)
				throw new Exception(string.Format(NinjaTrader.Custom.Resource.ZigZagHighBarBarsAgoOutOfRange, GetType().Name, (Count - 1), barsAgo));

			Update();
			for (int idx = CurrentBar - barsAgo - 1; idx >= CurrentBar - barsAgo - 1 - lookBackPeriod; idx--)
			{
				if (idx < 0)
					return -1;
				if (idx >= zigZagHighZigZags.Count)
					continue;

				if (!zigZagHighZigZags.IsValidDataPointAt(idx))
					continue;

				if (instance <= 1) // 1-based, < to be save
					return CurrentBar - idx;

				instance--;
			}

			return -1;
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < 2) // Need at least 3 bars to calculate Low/High
			{
				zigZagHighSeries[0]		= 0;
				zigZagLowSeries[0] 		= 0;
				return;
			}

			// Initialization
			if (lastSwingPrice == 0.0)
				lastSwingPrice = Input[0];

			ISeries<double> highSeries	= High;
			ISeries<double> lowSeries	= Low;

			if (!UseHighLow)
			{
				highSeries	= Input;
				lowSeries	= Input;
			}

			// Calculation always for 1-bar ago !
			bool isSwingHigh			= highSeries[1].ApproxCompare(highSeries[0]) >= 0
											&& highSeries[1].ApproxCompare(highSeries[2]) >= 0;
			bool isSwingLow				= lowSeries[1].ApproxCompare(lowSeries[0]) <= 0
											&& lowSeries[1].ApproxCompare(lowSeries[2]) <= 0;
			bool isOverHighDeviation	= (DeviationType == DeviationType.Percent && IsPriceGreater(highSeries[1], (lastSwingPrice * (1.0 + DeviationValue / 100.0))))
											|| (DeviationType == DeviationType.Points && IsPriceGreater(highSeries[1], lastSwingPrice + DeviationValue));
			bool isOverLowDeviation		= (DeviationType == DeviationType.Percent && IsPriceGreater(lastSwingPrice * (1.0 - DeviationValue / 100.0), lowSeries[1]))
											|| (DeviationType == DeviationType.Points && IsPriceGreater(lastSwingPrice - DeviationValue, lowSeries[1]));

			double	saveValue	= 0.0;
			bool	addHigh		= false;
			bool	addLow		= false;
			bool	updateHigh	= false;
			bool	updateLow	= false;

			if (!isSwingHigh && !isSwingLow)
			{
				zigZagHighSeries[0] = currentZigZagHigh;
				zigZagLowSeries[0]	= currentZigZagLow;
				return;
			}

			if (trendDir <= 0 && isSwingHigh && isOverHighDeviation)
			{
				saveValue	= highSeries[1];
				addHigh		= true;
				trendDir	= 1;
			}
			else if (trendDir >= 0 && isSwingLow && isOverLowDeviation)
			{
				saveValue	= lowSeries[1];
				addLow		= true;
				trendDir	= -1;
			}
			else if (trendDir == 1 && isSwingHigh && IsPriceGreater(highSeries[1], lastSwingPrice))
			{
				saveValue	= highSeries[1];
				updateHigh	= true;
			}
			else if (trendDir == -1 && isSwingLow && IsPriceGreater(lastSwingPrice, lowSeries[1]))
			{
				saveValue	= lowSeries[1];
				updateLow	= true;
			}

			if (addHigh || addLow || updateHigh || updateLow)
			{
				if (updateHigh && lastSwingIdx >= 0)
				{
					zigZagHighZigZags.Reset(CurrentBar - lastSwingIdx);
					Value.Reset(CurrentBar - lastSwingIdx);
				}
				else if (updateLow && lastSwingIdx >= 0)
				{
					zigZagLowZigZags.Reset(CurrentBar - lastSwingIdx);
					Value.Reset(CurrentBar - lastSwingIdx);
				}

				if (addHigh || updateHigh)
				{
					zigZagHighZigZags[1]	= saveValue;
					currentZigZagHigh 		= saveValue;
					zigZagHighSeries[1]		= currentZigZagHigh;
					Value[1]				= currentZigZagHigh;
				}
				else if (addLow || updateLow)
				{
					zigZagLowZigZags[1]	= saveValue;
					currentZigZagLow 	= saveValue;
					zigZagLowSeries[1]	= currentZigZagLow;
					Value[1]			= currentZigZagLow;
				}

				lastSwingIdx	= CurrentBar - 1;
				lastSwingPrice	= saveValue;
			}

			zigZagHighSeries[0]	= currentZigZagHigh;
			zigZagLowSeries[0]	= currentZigZagLow;
			
			if (startIndex == int.MinValue && (zigZagHighZigZags.IsValidDataPoint(1) && zigZagHighZigZags[1] != zigZagHighZigZags[2] || zigZagLowZigZags.IsValidDataPoint(1) && zigZagLowZigZags[1] != zigZagLowZigZags[2]))
				startIndex = CurrentBar - (Calculate == Calculate.OnBarClose ? 2 : 1);
		}

		#region Properties
		/// <summary>
		/// Gets the ZigZag high points.
		/// </summary>
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "DeviationType", GroupName = "NinjaScriptParameters", Order = 0)]
		public DeviationType DeviationType
		{ get; set; }

		[Range(0, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "DeviationValue", GroupName = "NinjaScriptParameters", Order = 1)]
		public double DeviationValue
		{ get; set; }

		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "UseHighLow", GroupName = "NinjaScriptParameters", Order = 2)]
		public bool UseHighLow
		{ get; set; }

		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> ZigZagHigh
		{
			get
			{
				Update();
				return zigZagHighSeries;
			}
		}

		/// <summary>
		/// Gets the ZigZag low points.
		/// </summary>
		[Browsable(false)]
		[XmlIgnore()]
		public Series<double> ZigZagLow
		{
			get
			{
				Update();
				return zigZagLowSeries;
			}
		}
		#endregion

		#region Miscellaneous
		private bool IsPriceGreater(double a, double b)
		{
			return a.ApproxCompare(b) > 0;
		}

		public override void OnCalculateMinMax()
		{
			MinValue = double.MaxValue;
			MaxValue = double.MinValue;
			
			if (BarsArray[0] == null || ChartBars == null || startIndex == int.MinValue)
				return;

			for (int seriesCount = 0; seriesCount < Values.Length; seriesCount++)
			{
				for (int idx = ChartBars.FromIndex - Displacement; idx <= ChartBars.ToIndex + Displacement; idx++)
				{
					if (idx < 0 || idx > Bars.Count - 1 - (Calculate == NinjaTrader.NinjaScript.Calculate.OnBarClose ? 1 : 0))
						continue;
					
					if (zigZagHighZigZags.IsValidDataPointAt(idx))
						MaxValue = Math.Max(MaxValue, zigZagHighZigZags.GetValueAt(idx));
					
					if (zigZagLowZigZags.IsValidDataPointAt(idx))
						MinValue = Math.Min(MinValue, zigZagLowZigZags.GetValueAt(idx));
				}
			}
		}

		protected override Point[] OnGetSelectionPoints(ChartControl chartControl, ChartScale chartScale)
		{
			if (!IsSelected || Count == 0 || Plots[0].Brush.IsTransparent() || startIndex == int.MinValue)
				return new System.Windows.Point[0];

			List<System.Windows.Point> points = new List<System.Windows.Point>();

			int lastIndex	= Calculate == NinjaTrader.NinjaScript.Calculate.OnBarClose ? ChartBars.ToIndex - 1 : ChartBars.ToIndex - 2;

			for (int i = Math.Max(0, ChartBars.FromIndex - Displacement); i <= Math.Max(lastIndex, Math.Min(Bars.Count - (Calculate == NinjaTrader.NinjaScript.Calculate.OnBarClose ? 2 : 1), lastIndex - Displacement)); i++)
			{
				int x = (chartControl.BarSpacingType == BarSpacingType.TimeBased || chartControl.BarSpacingType == BarSpacingType.EquidistantMulti && i + Displacement >= ChartBars.Count
					? chartControl.GetXByTime(ChartBars.GetTimeByBarIdx(chartControl, i + Displacement))
					: chartControl.GetXByBarIndex(ChartBars, i + Displacement));

				if (Value.IsValidDataPointAt(i))
					points.Add(new System.Windows.Point(x, chartScale.GetYByValue(Value.GetValueAt(i))));
			}
			return points.ToArray();
		}

		protected override void OnRender(Gui.Chart.ChartControl chartControl, Gui.Chart.ChartScale chartScale)
		{
			if (Bars == null || chartControl == null || startIndex == int.MinValue)
				return;

			IsValidDataPointAt(Bars.Count - 1 - (Calculate == NinjaTrader.NinjaScript.Calculate.OnBarClose ? 1 : 0)); // Make sure indicator is calculated until last (existing) bar
			int preDiff = 1;
			for (int i = ChartBars.FromIndex - 1; i >= 0; i--)
			{
				if (i - Displacement < startIndex || i - Displacement > Bars.Count - 1 - (Calculate == NinjaTrader.NinjaScript.Calculate.OnBarClose ? 1 : 0))
					break;

				bool isHigh	= zigZagHighZigZags.IsValidDataPointAt(i - Displacement);
				bool isLow	= zigZagLowZigZags.IsValidDataPointAt(i - Displacement);

				if (isHigh || isLow)
					break;

				preDiff++;
			}

			preDiff -= (Displacement < 0 ? Displacement : 0 - Displacement);

			int postDiff = 0;
			for (int i = ChartBars.ToIndex; i <= zigZagHighZigZags.Count; i++)
			{
				if (i - Displacement < startIndex || i - Displacement > Bars.Count - 1 - (Calculate == NinjaTrader.NinjaScript.Calculate.OnBarClose ? 1 : 0))
					break;

				bool isHigh	= zigZagHighZigZags.IsValidDataPointAt(i - Displacement);
				bool isLow	= zigZagLowZigZags.IsValidDataPointAt(i - Displacement);

				if (isHigh || isLow)
					break;

				postDiff++;
			}

			postDiff += (Displacement < 0 ? 0 - Displacement : Displacement);

			int		lastIdx		= -1;
			double	lastValue	= -1;
			SharpDX.Direct2D1.PathGeometry	g		= null;
			SharpDX.Direct2D1.GeometrySink	sink	= null;

			for (int idx = ChartBars.FromIndex - preDiff; idx <= ChartBars.ToIndex + postDiff; idx++)
			{
				if (idx < startIndex || idx > Bars.Count - (Calculate == NinjaTrader.NinjaScript.Calculate.OnBarClose ? 2 : 1) || idx < Math.Max(BarsRequiredToPlot - Displacement, Displacement))
					continue;

				bool isHigh	= zigZagHighZigZags.IsValidDataPointAt(idx);
				bool isLow	= zigZagLowZigZags.IsValidDataPointAt(idx);

				if (!isHigh && !isLow)
					continue;
				
				double value = isHigh ? zigZagHighZigZags.GetValueAt(idx) : zigZagLowZigZags.GetValueAt(idx);
				
				if (lastIdx >= startIndex)
				{
					float x1	= (chartControl.BarSpacingType == BarSpacingType.TimeBased || chartControl.BarSpacingType == BarSpacingType.EquidistantMulti && idx + Displacement >= ChartBars.Count
						? chartControl.GetXByTime(ChartBars.GetTimeByBarIdx(chartControl, idx + Displacement))
						: chartControl.GetXByBarIndex(ChartBars, idx + Displacement));
					float y1	= chartScale.GetYByValue(value);

					if (sink == null)
					{
						float x0	= (chartControl.BarSpacingType == BarSpacingType.TimeBased || chartControl.BarSpacingType == BarSpacingType.EquidistantMulti && lastIdx + Displacement >= ChartBars.Count
						? chartControl.GetXByTime(ChartBars.GetTimeByBarIdx(chartControl, lastIdx + Displacement))
						: chartControl.GetXByBarIndex(ChartBars, lastIdx + Displacement));
						float y0	= chartScale.GetYByValue(lastValue);
						g			= new SharpDX.Direct2D1.PathGeometry(Core.Globals.D2DFactory);
						sink		= g.Open();
						sink.BeginFigure(new SharpDX.Vector2(x0, y0), SharpDX.Direct2D1.FigureBegin.Hollow);
					}
					sink.AddLine(new SharpDX.Vector2(x1, y1));
				}

				// Save as previous point
				lastIdx		= idx;
				lastValue	= value;
			}

			if (sink != null)
			{
				sink.EndFigure(SharpDX.Direct2D1.FigureEnd.Open);
				sink.Close();
			}

			if (g != null)
			{
				var oldAntiAliasMode = RenderTarget.AntialiasMode;
				RenderTarget.AntialiasMode = SharpDX.Direct2D1.AntialiasMode.PerPrimitive;
				RenderTarget.DrawGeometry(g, Plots[0].BrushDX, Plots[0].Width, Plots[0].StrokeStyle);
				RenderTarget.AntialiasMode = oldAntiAliasMode;
				g.Dispose();
				RemoveDrawObject("NinjaScriptInfo");
			}
			else
				Draw.TextFixed(this, "NinjaScriptInfo", NinjaTrader.Custom.Resource.ZigZagDeviationValueError, TextPosition.BottomRight);
		}
		#endregion
	}
}

public enum DeviationType
{
	Percent,
	Points
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ZigZag[] cacheZigZag;
		public ZigZag ZigZag(DeviationType deviationType, double deviationValue, bool useHighLow)
		{
			return ZigZag(Input, deviationType, deviationValue, useHighLow);
		}

		public ZigZag ZigZag(ISeries<double> input, DeviationType deviationType, double deviationValue, bool useHighLow)
		{
			if (cacheZigZag != null)
				for (int idx = 0; idx < cacheZigZag.Length; idx++)
					if (cacheZigZag[idx] != null && cacheZigZag[idx].DeviationType == deviationType && cacheZigZag[idx].DeviationValue == deviationValue && cacheZigZag[idx].UseHighLow == useHighLow && cacheZigZag[idx].EqualsInput(input))
						return cacheZigZag[idx];
			return CacheIndicator<ZigZag>(new ZigZag(){ DeviationType = deviationType, DeviationValue = deviationValue, UseHighLow = useHighLow }, input, ref cacheZigZag);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ZigZag ZigZag(DeviationType deviationType, double deviationValue, bool useHighLow)
		{
			return indicator.ZigZag(Input, deviationType, deviationValue, useHighLow);
		}

		public Indicators.ZigZag ZigZag(ISeries<double> input , DeviationType deviationType, double deviationValue, bool useHighLow)
		{
			return indicator.ZigZag(input, deviationType, deviationValue, useHighLow);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ZigZag ZigZag(DeviationType deviationType, double deviationValue, bool useHighLow)
		{
			return indicator.ZigZag(Input, deviationType, deviationValue, useHighLow);
		}

		public Indicators.ZigZag ZigZag(ISeries<double> input , DeviationType deviationType, double deviationValue, bool useHighLow)
		{
			return indicator.ZigZag(input, deviationType, deviationValue, useHighLow);
		}
	}
}

#endregion


#########################

//
// Copyright (C) 2024, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The ZLEMA (Zero-Lag Exponential Moving Average) is an EMA variant that attempts to adjust for lag.
	/// </summary>
	public class ZLEMA : Indicator
	{
		private double	k;
		private int		lag;
		private double	oneMinusK;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionZLEMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameZLEMA;
				IsSuspendedWhileInactive	= true;
				IsOverlay					= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameZLEMA);
			}
			else if (State == State.Configure)
			{
				k			= 2.0 / (Period + 1);
				oneMinusK	= 1 - k;
				lag			= (int) Math.Ceiling((Period - 1) / 2.0);
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < lag)
				Value[0] = Input[0];
			else
				Value[0] = k * (2 * Input[0] - Input[lag]) + oneMinusK * Value[1];
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ZLEMA[] cacheZLEMA;
		public ZLEMA ZLEMA(int period)
		{
			return ZLEMA(Input, period);
		}

		public ZLEMA ZLEMA(ISeries<double> input, int period)
		{
			if (cacheZLEMA != null)
				for (int idx = 0; idx < cacheZLEMA.Length; idx++)
					if (cacheZLEMA[idx] != null && cacheZLEMA[idx].Period == period && cacheZLEMA[idx].EqualsInput(input))
						return cacheZLEMA[idx];
			return CacheIndicator<ZLEMA>(new ZLEMA(){ Period = period }, input, ref cacheZLEMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ZLEMA ZLEMA(int period)
		{
			return indicator.ZLEMA(Input, period);
		}

		public Indicators.ZLEMA ZLEMA(ISeries<double> input , int period)
		{
			return indicator.ZLEMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ZLEMA ZLEMA(int period)
		{
			return indicator.ZLEMA(Input, period);
		}

		public Indicators.ZLEMA ZLEMA(ISeries<double> input , int period)
		{
			return indicator.ZLEMA(input, period);
		}
	}
}

#endregion


#########################

// AutoDeltaDivZigZag.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Media;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
using System.Xml.Linq;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Core;
using NinjaTrader.Custom;
using NinjaTrader.Data;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.NinjaScript.AtmStrategy;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX;
using SharpDX.Direct2D1;

namespace NinjaTrader.NinjaScript.Indicators
{
    public class AutoDeltaDivZigZag : Indicator
    {
        NinjaTrader.Gui.Tools.SimpleFont title =
        new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 20, Bold = true };
        NinjaTrader.Gui.Tools.SimpleFont title2 =
        new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 15, Bold = true };
        NinjaTrader.Gui.Tools.SimpleFont TextFont =
        new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 15, Bold = false };

        double realizedPnL = 0;
        double TriggerBar1 = 0;
        double BarsSince1 = 0;
        double TriggerBar2 = 0;
        double BarsSince2 = 0;
        bool sigLock1 = false;
        bool sigLock2 = false;
        bool playOnce = false;
        bool isReversed = false;
        string version = "V8";

        private SimpleFont textFont = new SimpleFont("Arial", 10)
        {
            Bold = true
        };

        #region Box Vars
        private Border moveB;
        private Border hideB;
        private Border tileHolder;
        private Grid grid;
        private Thickness margin;
        private bool subscribedToSize;
        private System.Windows.Point startPoint;
        private Button ARMLONGbtn;
        private Button ARMSHORTbtn;
        private Button ARMOPTIONbtn;
        private Button Closebtn;
        private Button AUTOArmbtn;
        private Button resetQuantVal;
        private Button increaseQuant;
        private Button decreaseQuant;
        private Label ATMLabel;
        private Label ACCOUNTLabel;
        private Label selectedATMStrat;
        private Label accountSelected;
        private Label quantityLabel;
        private TextBox quantityLabelVal;
        private ComboBox combo;
        private bool armLongBtnToggle;
        private bool armShortBtnToggle;
        private bool armOptionBtnToggle;
        private bool autoArmBtnToggle;
        private int quantityValue = 1;
        private int quantityATM = 1;
        private bool closeRunning;
        private bool handlerSet;
        private Chart chartWindow;
        private Grid chartTraderGrid;
        private Grid chartTraderButtonsGrid;
        private Grid lowerButtonsGrid;
        private Grid upperButtonsGrid;
        private AtmStrategySelector atmSelector;
        private AccountSelector accountSelector;
        private bool connected;
        private Instrument inst;
        private bool onceTriggered;
        private bool inPosition;
        private int posDirection;
        private Account chartTraderAccount;
        private Position positions;
        private Timer _posTimer;
        private Timer _acctTimer;
        private FrameworkElement addedGrid;
        #endregion

        // Variables for divergence detection
        private OrderFlowCumulativeDelta cumulativeDelta;
        private ZigZag zigZag;

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Description = "";
                Name = "AutoDeltaDivZigZag";
                Calculate = Calculate.OnEachTick;
                BarsRequiredToPlot = 100;
                IsOverlay = true;
                DisplayInDataBox = false;
                ShowTransparentPlotsInDataBox = true;
                DrawOnPricePanel = true;
                PaintPriceMarkers = false;
                IsSuspendedWhileInactive = false;
                this.SelectedTypes = new XElement("SelectedTypes");
                ArePlotsConfigurable = false;
                AreLinesConfigurable = false;
                this.Left = 5.0;
                this.Top = -1.0;
                this.NumberOfRows = 5;
                realizedProfit = 0;
                realizedLoss = 0;
                startTime = 73000;
                endTime = 120000;
                econNumber1 = 74500;
                econNumber2 = 80000;
                openTime = 0;

                // Default parameters for divergence detection
                DeltaThreshold = 100;
                ZigZagDeviation = 0.5;
            }
            else if (State == State.Configure)
            {
                // Add the required data series for cumulative delta
                AddDataSeries(Data.BarsPeriodType.Tick, 1); // For cumulative delta (tick data)
            }
            else if (State == State.DataLoaded)
            {
                // Initialize cumulative delta and zigZag indicators
                cumulativeDelta = OrderFlowCumulativeDelta(CumulativeDeltaType.BidAsk, CumulativeDeltaPeriod.Bar, 0);
                zigZag = ZigZag(DeviationType.Percent, ZigZagDeviation, false);

                // Keyboard hot key listener
                ChartControl.Dispatcher.InvokeAsync(() =>
                {
                    ChartControl.KeyDown += new System.Windows.Input.KeyEventHandler(ChartControl_KeyDown);
                });
            }
            if (State != State.DataLoaded)
            {
                if (State == State.Historical)
                {
                    Draw.TextFixed(this, "hftName", "Auto DeltaDiv ZigZag", TextPosition.TopRight, Brushes.Magenta, title, Brushes.Black, Brushes.Black, 50);

                    #region Control Panel

                    try
                    {
                        Dispatcher.InvokeAsync(delegate ()
                        {
                            QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
                            this.quantityATM = quantityUpDown.Value;
                        });
                    }
                    catch (Exception)
                    {
                    }
                    try
                    {
                        if (ChartControl != null)
                        {
                            if (this.Top < 0.0)
                            {
                                this.Top = 25.0;
                            }
                            Dispatcher.Invoke(delegate ()
                            {
                                this.addedGrid = this.CreateControl();
                                UserControlCollection.Add(this.addedGrid);
                            });
                        }
                        return;
                    }
                    catch (Exception)
                    {
                        return;
                    }
                    #endregion
                }
                if (State == State.Terminated)
                {
                    if (ChartControl != null)
                    {
                        ChartControl.Dispatcher.InvokeAsync(() =>
                        {
                            ChartControl.KeyDown -= ChartControl_KeyDown;
                        });
                    }
                    #region Control Panel
                    this.grid = null;
                    this.tileHolder = null;
                    this.moveB = null;
                    this.hideB = null;
                    Dispatcher.Invoke(delegate ()
                    {
                        UserControlCollection.Remove(this.addedGrid);
                        this.addedGrid = null;
                    });
                    try
                    {
                        if (this._posTimer != null)
                        {
                            this._posTimer.Change(-1, 0);
                            this._posTimer.Dispose();
                        }
                        if (this._acctTimer != null)
                        {
                            this._acctTimer.Change(-1, 0);
                            this._acctTimer.Dispose();
                        }
                        if (this.addedGrid != null)
                        {
                            UserControlCollection.Remove(this.addedGrid);
                            this.addedGrid = null;
                        }
                        if (this.moveB != null)
                        {
                            this.moveB = null;
                        }
                        if (this.hideB != null)
                        {
                            this.hideB = null;
                        }
                        if (this.grid != null)
                        {
                            this.grid = null;
                        }
                        if (this.tileHolder != null)
                        {
                            this.tileHolder = null;
                        }
                        if (this.ARMLONGbtn != null)
                        {
                            this.ARMLONGbtn.Click -= this.ARMLONGbtn_Click;
                            this.ARMLONGbtn = null;
                        }
                        if (this.ARMSHORTbtn != null)
                        {
                            this.ARMSHORTbtn.Click -= this.ARMSHORTbtn_Click;
                            this.ARMSHORTbtn = null;
                        }
                        if (this.ARMOPTIONbtn != null)
                        {
                            this.ARMOPTIONbtn.Click -= this.ARMOPTIONbtn_Click;
                            this.ARMOPTIONbtn = null;
                        }
                        if (this.Closebtn != null)
                        {
                            this.Closebtn.Click -= this.Closebtn_Click;
                            this.Closebtn = null;
                        }
                        if (this.AUTOArmbtn != null)
                        {
                            this.AUTOArmbtn.Click -= this.AUTOArmbtn_Click;
                            this.AUTOArmbtn = null;
                        }
                        if (this.resetQuantVal != null)
                        {
                            this.resetQuantVal.Click -= new RoutedEventHandler(this.resetQuantVal_Click);
                            this.resetQuantVal = null;
                        }
                        if (this.increaseQuant != null)
                        {
                            this.increaseQuant.Click -= new RoutedEventHandler(this.increaseQuant_Click);
                            this.increaseQuant = null;
                        }
                        if (this.decreaseQuant != null)
                        {
                            this.decreaseQuant.Click -= new RoutedEventHandler(this.decreaseQuant_Click);
                            this.decreaseQuant = null;
                        }
                        if (this.atmSelector != null)
                        {
                            this.atmSelector.SelectionChanged -= new SelectionChangedEventHandler(this.ATMSelection_Changed);
                            this.atmSelector = null;
                        }
                        if (this.quantityLabelVal != null)
                        {
                            this.quantityLabelVal.PreviewKeyDown -= this.TextBox_PreviewKeyDown;
                            this.quantityLabelVal = null;
                        }
                        if (this.accountSelector != null)
                        {
                            this.accountSelector.SelectionChanged -= new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
                            this.accountSelector = null;
                        }
                    }
                    catch (Exception)
                    {
                    }
                    #endregion
                }
                return;
            }
        }

        protected override void OnBarUpdate()
        {
            try
            {
                if (!this.subscribedToSize && ChartPanel != null)
                {
                    this.subscribedToSize = true;
                    ChartPanel.SizeChanged += delegate (object sender, SizeChangedEventArgs e)
                    {
                        if (this.grid != null && ChartPanel != null)
                        {
                            if (this.grid.Margin.Left + this.grid.ActualWidth > ChartPanel.ActualWidth || this.grid.Margin.Top + this.grid.ActualHeight > ChartPanel.ActualHeight)
                            {
                                double left = Math.Max(0.0, Math.Min(this.grid.Margin.Left, ChartPanel.ActualWidth - this.grid.ActualWidth));
                                double top = Math.Max(0.0, Math.Min(this.grid.Margin.Top, ChartPanel.ActualHeight - this.grid.ActualHeight));
                                this.grid.Margin = new Thickness(left, top, 0.0, 0.0);
                                this.Left = left;
                                this.Top = top;
                            }
                            return;
                        }
                    };
                }
                try
                {
                    if (AccountName != null)
                    {
                        try
                        {
                            Account myPnL = null;
                            lock (Account.All)
                            {
                                myPnL = Account.All.FirstOrDefault(a => a.Name == AccountName);
                            }
                            realizedPnL = myPnL.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar);
                        }
                        catch (Exception e)
                        {
                        }
                    }
                    Draw.TextFixed(this, "pnlstat", "\n\n" + "ACC PNL $" + realizedPnL.ToString("F2"), TextPosition.TopRight);
                    if (realizedProfit != 0 && realizedPnL >= realizedProfit)
                    {
                        Draw.TextFixed(this, "PT STAT", "Stopped - Profit Target Reached" + "   Realized P&L: " + realizedPnL.ToString("F2"), TextPosition.Center, Brushes.LimeGreen, title, Brushes.Black, Brushes.Black, 50);
                        return;
                    }
                    if (realizedLoss != 0 && realizedPnL <= realizedLoss)
                    {
                        Draw.TextFixed(this, "SL STAT", "Stopped - Total Stop Loss Reached" + "   Realized P&L: " + realizedPnL.ToString("F2"), TextPosition.Center, Brushes.Red, title, Brushes.Black, Brushes.Black, 50);
                        return;
                    }
                    if (isReversed == false)
                    {
                        Draw.TextFixed(this, "Rev", "Normal" + "\n", TextPosition.BottomLeft, Brushes.LimeGreen, title2, Brushes.Transparent, Brushes.Black, 0);
                        Draw.TextFixed(this, "v", version.ToString(), TextPosition.BottomLeft);
                    }
                    if (isReversed == true)
                    {
                        Draw.TextFixed(this, "Rev", "Reversed" + "\n", TextPosition.BottomLeft, Brushes.LimeGreen, title2, Brushes.Transparent, Brushes.Black, 0);
                        Draw.TextFixed(this, "v", version.ToString(), TextPosition.BottomLeft);
                    }
                    // Avoid Econ
                    if (econNumber1 != 0 || econNumber2 != 0)
                    {
                        DateTime ecNumber = Time[0];
                        ecNumber.AddMinutes(5);

                        if ((ToTime(Time[0]) >= econNumber1 - (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0])) && ToTime(Time[0]) < econNumber1 + (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0])))) // Trade Time
                        {
                            Draw.TextFixed(this, "Econ", "\n\n\n\n" + "No Trades Econ Data Release +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent, Brushes.Black, 0);
                            return;
                        }
                        else if ((ToTime(Time[0]) >= econNumber2 - (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0])) && ToTime(Time[0]) < econNumber2 + (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0])))) // Trade Time
                        {
                            Draw.TextFixed(this, "Econ", "\n\n\n\n" + "No Trades Econ Data Release +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent, Brushes.Black, 0);
                            return;
                        }
                        else if ((ToTime(Time[0]) >= openTime - (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0])) && ToTime(Time[0]) < openTime + (ToTime(ecNumber.AddMinutes(5)) - ToTime(Time[0])))) // Trade Time
                        {
                            Draw.TextFixed(this, "Econ", "\n\n\n\n" + "No Trades During Market Open +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent, Brushes.Black, 0);
                            return;
                        }
                        else
                        {
                            Draw.TextFixed(this, "Econ", "\n\n\n\n" + "Skipping Econ @ " + econNumber1.ToString() + " and " + econNumber2.ToString(), TextPosition.TopRight, Brushes.LimeGreen, title2, Brushes.Transparent, Brushes.Black, 0);
                        }
                    }
                    // Trade Time
                    if ((ToTime(Time[0]) >= startTime && ToTime(Time[0]) < endTime))
                    {
                        Draw.TextFixed(this, "timeStat", "\n\n\n" + "Trade Time: Trading " + startTime.ToString() + " to " + endTime.ToString(), TextPosition.TopRight);
                    }
                    else if (startTime == 0 && endTime == 0)
                    {
                        Draw.TextFixed(this, "timeStat", "\n\n\n" + "Trade Time: Trading All Day", TextPosition.TopRight);
                    }
                    else
                    {
                        Draw.TextFixed(this, "timeStat", "\n\n\n" + "Trade Time: Not Trading", TextPosition.TopRight);
                        return;
                    }

                }
                catch
                {
                }
                try
                {
                    if (CurrentBars[0] < 20)
                    {
                        return;
                    }
                    if (State == State.Realtime && inPosition == false)
                    {
                        Draw.TextFixed(this, "pos", "\n\n\n\n\n" + "No Position", TextPosition.TopRight);
                    }
                    if (State == State.Realtime && inPosition == true)
                    {
                        Draw.TextFixed(this, "pos", "\n\n\n\n\n" + "In Position", TextPosition.TopRight);
                    }
                    if (CurrentBar > TriggerBar1)
                    {
                        BarsSince1 = CurrentBar - TriggerBar1;
                        if (BarsSince1 >= 1 && IsFirstTickOfBar)
                        {
                            TriggerBar1 = 0;
                            sigLock1 = false;
                            playOnce = false;
                        }
                    }
                    if (CurrentBar > TriggerBar2)
                    {
                        BarsSince2 = CurrentBar - TriggerBar2;
                        if (BarsSince2 >= 1 && IsFirstTickOfBar)
                        {
                            TriggerBar2 = 0;
                            sigLock2 = false;
                            playOnce = false;
                        }
                    }

                    // New trading logic from DeltaDivergenceZigZag

                    if (CurrentBar < 2)
                        return;

                    // Ensure we are processing the primary series
                    if (BarsInProgress != 0)
                        return;

                    // Ensure indicators are initialized
                    if (zigZag == null || cumulativeDelta == null)
                        return;

                    // Find the latest ZigZag swings
                    int lastSwingHighIndex = zigZag.HighBar(0, 1, CurrentBar);
                    int lastSwingLowIndex = zigZag.LowBar(0, 1, CurrentBar);

                    // Process swing highs for bearish divergence
                    if (lastSwingHighIndex >= 0 && lastSwingHighIndex < CurrentBar)
                    {
                        double lastPriceHigh = High[lastSwingHighIndex];
                        double currentPriceHigh = High[0];
                        double lastDeltaHigh = cumulativeDelta.DeltaClose[lastSwingHighIndex];
                        double currentDeltaHigh = cumulativeDelta.DeltaClose[0];

                        // Bearish divergence check
                        if (currentPriceHigh > lastPriceHigh && currentDeltaHigh < lastDeltaHigh - DeltaThreshold)
                        {
                            Print($"Bearish Divergence detected at bar {CurrentBar}");
                            Draw.ArrowDown(this, "BearDiv" + CurrentBar, true, 0, High[0] + TickSize * 5, Brushes.Red);

                            if (!sigLock1 && !inPosition)
                            {
                                if (!playOnce)
                                {
                                    try
                                    {
                                        PlaySound(NinjaTrader.Core.Globals.InstallDir + @"\sounds\HFTNQ.wav");
                                    }
                                    catch
                                    {
                                    }
                                    playOnce = true;
                                }

                                if (!isReversed)
                                {
                                    takeTrade(-1);
                                }
                                else
                                {
                                    takeTrade(1);
                                }
                                sigLock1 = true;
                                TriggerBar1 = CurrentBar;
                            }
                        }
                    }

                    // Process swing lows for bullish divergence
                    if (lastSwingLowIndex >= 0 && lastSwingLowIndex < CurrentBar)
                    {
                        double lastPriceLow = Low[lastSwingLowIndex];
                        double currentPriceLow = Low[0];
                        double lastDeltaLow = cumulativeDelta.DeltaClose[lastSwingLowIndex];
                        double currentDeltaLow = cumulativeDelta.DeltaClose[0];

                        // Bullish divergence check
                        if (currentPriceLow < lastPriceLow && currentDeltaLow > lastDeltaLow + DeltaThreshold)
                        {
                            Print($"Bullish Divergence detected at bar {CurrentBar}");
                            Draw.ArrowUp(this, "BullDiv" + CurrentBar, true, 0, Low[0] - TickSize * 5, Brushes.Green);

                            if (!sigLock2 && !inPosition)
                            {
                                if (!playOnce)
                                {
                                    try
                                    {
                                        PlaySound(NinjaTrader.Core.Globals.InstallDir + @"\sounds\HFTNQ.wav");
                                    }
                                    catch
                                    {
                                    }
                                    playOnce = true;
                                }

                                if (!isReversed)
                                {
                                    takeTrade(1);
                                }
                                else
                                {
                                    takeTrade(-1);
                                }
                                sigLock2 = true;
                                TriggerBar2 = CurrentBar;
                            }
                        }
                    }

                }
                catch (Exception)
                {
                }

            }
            catch (Exception)
            {
            }
        }

        private void ChartControl_KeyDown(object sender, KeyEventArgs e)
        {
            if (((Keyboard.Modifiers & ModifierKeys.Control) != 0) && Keyboard.IsKeyDown(Key.NumPad0))
            {
                if (isReversed == false)
                {
                    isReversed = true;
                    Print("Reversed");
                    return;
                }
                if (isReversed == true)
                {
                    isReversed = false;
                    Print("Normal");
                    return;
                }
            }
        }

        // Include all other methods from the original code here.

        #region Control Panel Methods
        private FrameworkElement CreateControl()
        {
            try
            {
                this.chartWindow = (Window.GetWindow(ChartControl.Parent) as Chart);
                this.chartTraderGrid = ((Extensions.FindFirst(this.chartWindow, "ChartWindowChartTraderControl") as ChartTrader).Content as Grid);
                if (this.chartTraderGrid != null)
                {
                    try
                    {
                        this.chartTraderButtonsGrid = (this.chartTraderGrid.Children[0] as Grid);
                        if (this.chartTraderButtonsGrid != null)
                        {
                            Grid grid = (Grid)this.chartTraderGrid.Children[2];
                            if (grid != null)
                            {
                                this.atmSelector = (AtmStrategySelector)grid.Children[1];
                                this.atmSelector.SelectionChanged += new SelectionChangedEventHandler(this.ATMSelection_Changed);
                            }
                            Grid grid2 = (Grid)this.chartTraderGrid.Children[1];
                            if (grid2 != null)
                            {
                                ChartControl.Dispatcher.Invoke(delegate ()
                                {
                                    AccountSelector accountSelector = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlAccountSelector") as AccountSelector;
                                    this.chartTraderAccount = ((accountSelector != null) ? accountSelector.SelectedAccount : null);
                                    this.accountSelector = ((accountSelector != null) ? accountSelector : null);
                                });
                                if (this.accountSelector != null && !this.handlerSet)
                                {
                                    this.handlerSet = true;
                                    this.accountSelector.SelectionChanged += new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
                                }
                                this.combo = (ComboBox)grid2.Children[4];
                                foreach (Instrument instrument in Instrument.All)
                                {
                                    if (instrument.FullName == this.combo.SelectedValue.ToString())
                                    {
                                        this.inst = instrument;
                                    }
                                }
                            }
                        }

                    }
                    catch (Exception)
                    {

                    }
                }
                this._posTimer = new Timer(new TimerCallback(this.posCallback), null, 0, 200);
                this._acctTimer = new Timer(new TimerCallback(this.acctCallback), null, 0, 200);
                if (this.grid != null)
                {
                    return this.grid;
                }
                this.grid = new Grid
                {
                    VerticalAlignment = VerticalAlignment.Top,
                    HorizontalAlignment = HorizontalAlignment.Left,
                    Margin = new Thickness(this.Left, this.Top, 0.0, 0.0),
                };
                this.grid.ColumnDefinitions.Add(new ColumnDefinition
                {
                    Width = default(GridLength)
                });
                this.grid.ColumnDefinitions.Add(new ColumnDefinition
                {
                    Width = default(GridLength)
                });
                this.grid.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                System.Windows.Media.Brush background = (Application.Current.FindResource("BackgroundMainWindow") as System.Windows.Media.Brush) ?? Brushes.White;
                System.Windows.Media.Brush borderBrush = (Application.Current.FindResource("BorderThinBrush") as System.Windows.Media.Brush) ?? Brushes.Black;
                Grid grid3 = new Grid();
                grid3.RowDefinitions.Add(new RowDefinition
                {
                    Height = new GridLength(2.0, GridUnitType.Star)
                });
                grid3.RowDefinitions.Add(new RowDefinition
                {
                    Height = new GridLength(1.0, GridUnitType.Star)
                });
                grid3.RowDefinitions.Add(new RowDefinition
                {
                    Height = new GridLength(2.0, GridUnitType.Star)
                });
                Grid grid4 = new Grid();
                grid4.RowDefinitions.Add(new RowDefinition
                {
                    Height = new GridLength(3.0, GridUnitType.Star)
                });
                for (int i = 0; i < grid3.RowDefinitions.Count; i++)
                {
                    System.Windows.Shapes.Ellipse element = new System.Windows.Shapes.Ellipse
                    {
                        Width = 4.0,
                        Height = 4.0,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        VerticalAlignment = VerticalAlignment.Center,
                        Fill = Brushes.White
                    };
                    Grid.SetRow(element, i);
                    grid3.Children.Add(element);
                }
                System.Windows.Shapes.Polygon element2 = new System.Windows.Shapes.Polygon
                {
                    Width = 12.0,
                    Height = 12.0,
                    HorizontalAlignment = HorizontalAlignment.Center,
                    VerticalAlignment = VerticalAlignment.Center,
                    Fill = Brushes.Crimson,
                    Points = new PointCollection
                    {
                        new System.Windows.Point(1.0, 5.0),
                        new System.Windows.Point(8.0, 10.0),
                        new System.Windows.Point(8.0, 0.0)
                    }
                };
                Grid.SetRow(element2, 0);
                grid4.Children.Add(element2);
                this.moveB = new Border
                {
                    VerticalAlignment = VerticalAlignment.Top,
                    BorderThickness = new Thickness(0.0, 1.0, 1.0, 1.0),
                    BorderBrush = borderBrush,
                    Background = background,
                    Width = 12.0,
                    Height = 24.0,
                    Cursor = Cursors.Hand,
                    Child = grid3
                };
                this.hideB = new Border
                {
                    VerticalAlignment = VerticalAlignment.Bottom,
                    BorderThickness = new Thickness(0.0, 1.0, 1.0, 1.0),
                    BorderBrush = borderBrush,
                    Background = background,
                    Width = 14.0,
                    Height = 24.0,
                    Cursor = Cursors.Hand,
                    Child = grid4
                };
                this.moveB.MouseDown += (MouseButtonEventHandler)((sender, e) =>
                {
                    this.startPoint = e.GetPosition((IInputElement)this.ChartPanel);
                    this.margin = this.grid.Margin;
                    if (e.ClickCount > 1)
                    {
                        this.moveB.ReleaseMouseCapture();
                        this.ChartControl.OnIndicatorsHotKey((object)this, (KeyEventArgs)null);
                    }
                    else
                        this.moveB.CaptureMouse();
                });
                this.moveB.MouseUp += delegate (object sender, MouseButtonEventArgs e)
                {
                    this.moveB.ReleaseMouseCapture();
                };
                this.moveB.MouseMove += delegate (object sender, MouseEventArgs e)
                {
                    if (this.moveB.IsMouseCaptured && this.grid != null && ChartPanel != null)
                    {
                        System.Windows.Point position = e.GetPosition(ChartPanel);
                        this.grid.Margin = new Thickness
                        {
                            Left = Math.Max(0.0, Math.Min(this.margin.Left + (position.X - this.startPoint.X), ChartPanel.ActualWidth - this.grid.ActualWidth)),
                            Top = Math.Max(0.0, Math.Min(this.margin.Top + (position.Y - this.startPoint.Y), ChartPanel.ActualHeight - this.grid.ActualHeight))
                        };
                        this.Left = this.grid.Margin.Left;
                        this.Top = this.grid.Margin.Top;
                        return;
                    }
                };
                Grid.SetColumn(this.moveB, 1);
                Grid.SetColumn(this.hideB, 2);
                this.grid.Children.Add(this.moveB);
                Grid grid5 = new Grid();
                grid5.Background = Brushes.Black; /// main
                grid5.ColumnDefinitions.Add(new ColumnDefinition
                {
                    Width = default(GridLength)
                });
                grid5.ColumnDefinitions.Add(new ColumnDefinition
                {
                    Width = default(GridLength)
                });
                grid5.ColumnDefinitions.Add(new ColumnDefinition
                {
                    Width = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                grid5.RowDefinitions.Add(new RowDefinition
                {
                    Height = default(GridLength)
                });
                Style style = Application.Current.FindResource("BasicEntryButton") as Style;
                Border border = new Border
                {
                    Background = Brushes.Black,
                    VerticalAlignment = VerticalAlignment.Stretch,
                    HorizontalAlignment = HorizontalAlignment.Stretch
                };
                Label label = new Label
                {
                    Content = string.Format("Auto Delta Div ZigZag", 0),
                    Height = 20.0,
                    Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
                    HorizontalAlignment = HorizontalAlignment.Center,
                    FontSize = 14.0
                };
                label.Foreground = Brushes.Magenta;
                label.Background = Brushes.Black;
                label.BorderBrush = Brushes.Transparent;
                label.HorizontalAlignment = HorizontalAlignment.Center;
                Grid.SetColumnSpan(label, 3);
                border.Child = label;
                Grid.SetRow(border, 0);
                Grid.SetColumnSpan(border, 3);
                grid5.Children.Add(border);
                this.ATMLabel = new Label
                {
                    Content = string.Format("ATM Strategy: ", 0),
                    Height = 20.0,
                    Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
                    HorizontalAlignment = HorizontalAlignment.Center
                };
                this.ATMLabel.Foreground = Brushes.White;
                this.ATMLabel.Background = Brushes.Transparent;
                this.ATMLabel.BorderBrush = Brushes.Transparent;
                this.ATMLabel.HorizontalAlignment = HorizontalAlignment.Center;
                Grid.SetColumnSpan(this.ATMLabel, 1);
                Grid.SetRow(this.ATMLabel, 1);
                grid5.Children.Add(this.ATMLabel);
                string format = string.Empty;
                if (this.atmSelector != null)
                {
                    try
                    {
                        format = this.atmSelector.SelectedAtmStrategy.DisplayName;
                    }
                    catch (Exception)
                    {
                        format = "None";
                    }
                }
                this.selectedATMStrat = new Label
                {
                    Content = string.Format(format, 0),
                    Height = 20.0,
                    Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
                    HorizontalAlignment = HorizontalAlignment.Center
                };
                this.selectedATMStrat.Foreground = Brushes.White;
                this.selectedATMStrat.Background = Brushes.Transparent;
                this.selectedATMStrat.BorderBrush = Brushes.Transparent;
                this.selectedATMStrat.HorizontalAlignment = HorizontalAlignment.Center;
                Grid.SetColumnSpan(this.selectedATMStrat, 2);
                Grid.SetColumn(this.selectedATMStrat, 1);
                Grid.SetRow(this.selectedATMStrat, 1);
                grid5.Children.Add(this.selectedATMStrat);
                this.ACCOUNTLabel = new Label
                {
                    Content = string.Format("Acc: ", 0),
                    Height = 20.0,
                    Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
                    HorizontalAlignment = HorizontalAlignment.Center
                };
                this.ACCOUNTLabel.Foreground = Brushes.White;
                this.ACCOUNTLabel.Background = Brushes.Transparent;
                this.ACCOUNTLabel.BorderBrush = Brushes.Transparent;
                this.ACCOUNTLabel.HorizontalAlignment = HorizontalAlignment.Center;
                Grid.SetColumnSpan(this.ACCOUNTLabel, 1);
                Grid.SetRow(this.ACCOUNTLabel, 2);
                grid5.Children.Add(this.ACCOUNTLabel);
                string format2 = string.Empty;
                lock (Connection.Connections)
                {
                    foreach (Connection connection in Connection.Connections)
                    {
                        if (connection.Status == ConnectionStatus.Connected)
                        {
                            this.connected = true;
                            break;
                        }
                    }
                }
                if (!this.connected)
                {
                    format2 = "Disconnected";
                }
                else
                {
                    try
                    {
                        if (this.accountSelector.SelectedIndex.ToString() == string.Empty || this.accountSelector.SelectedAccount.Name == string.Empty || this.accountSelector.SelectedAccount.Name == null || this.accountSelector == null)
                        {
                            format2 = "Select Account";
                        }
                        format2 = NinjaTrader.NinjaScript.Indicators.AutoDeltaDivZigZag.CensorString(this.accountSelector.SelectedAccount.DisplayName);
                    }
                    catch (Exception)
                    {
                        format2 = "Select Account";
                    }
                }
                this.accountSelected = new Label
                {
                    Content = string.Format(format2, 0),
                    Height = 20.0,
                    Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
                    HorizontalAlignment = HorizontalAlignment.Center
                };
                this.accountSelected.Foreground = Brushes.White;
                this.accountSelected.Background = Brushes.Transparent;
                this.accountSelected.BorderBrush = Brushes.Transparent;
                this.accountSelected.HorizontalAlignment = HorizontalAlignment.Center;
                Grid.SetColumnSpan(this.accountSelected, 2);
                Grid.SetColumn(this.accountSelected, 1);
                Grid.SetRow(this.accountSelected, 2);
                grid5.Children.Add(this.accountSelected);

                // Add other UI components (e.g., buttons) similar to HFT_Slayer indicator
                // You can customize the UI as needed

                // ARM LONG Button
                this.ARMLONGbtn = new Button
                {
                    Content = string.Format("Arm Long", 1),
                    Name = "LongArmButton",
                    Height = 30.0,
                    Width = 125.0,
                    Margin = new Thickness(4.0, 4.0, 0.0, 0.0),
                    Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Style = style
                };
                this.ARMLONGbtn.Background = Brushes.Gray;
                this.ARMLONGbtn.BorderBrush = Brushes.DimGray;
                this.ARMLONGbtn.Foreground = Brushes.White;
                this.ARMLONGbtn.Click += this.ARMLONGbtn_Click;
                Grid.SetColumn(this.ARMLONGbtn, 0);
                Grid.SetRow(this.ARMLONGbtn, 3);
                grid5.Children.Add(this.ARMLONGbtn);

                // ARM SHORT Button
                this.ARMSHORTbtn = new Button
                {
                    Content = string.Format("Arm Short", 1),
                    Name = "ShortArmButton",
                    Height = 30.0,
                    Width = 125.0,
                    Margin = new Thickness(0.0, 4.0, 4.0, 0.0),
                    Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Style = style
                };
                this.ARMSHORTbtn.Background = Brushes.Gray;
                this.ARMSHORTbtn.BorderBrush = Brushes.DimGray;
                this.ARMSHORTbtn.Foreground = Brushes.White;
                this.ARMSHORTbtn.Click += this.ARMSHORTbtn_Click;
                Grid.SetColumn(this.ARMSHORTbtn, 2);
                Grid.SetRow(this.ARMSHORTbtn, 3);
                grid5.Children.Add(this.ARMSHORTbtn);

                // ARM OPTION Button
                this.ARMOPTIONbtn = new Button
                {
                    Content = string.Format("Semi Auto", 1),
                    Name = "ARMOptionButton",
                    Height = 30.0,
                    Width = 125.0,
                    Margin = new Thickness(4.0, 4.0, 0.0, 0.0),
                    Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Style = style
                };
                this.ARMOPTIONbtn.Background = Brushes.Gray;
                this.ARMOPTIONbtn.BorderBrush = Brushes.DimGray;
                this.ARMOPTIONbtn.Foreground = Brushes.White;
                this.ARMOPTIONbtn.Click += this.ARMOPTIONbtn_Click;
                Grid.SetColumn(this.ARMOPTIONbtn, 0);
                Grid.SetRow(this.ARMOPTIONbtn, 4);
                grid5.Children.Add(this.ARMOPTIONbtn);

                // AUTO ARM Button
                this.AUTOArmbtn = new Button
                {
                    Content = string.Format("Full Auto", 1),
                    Name = "Continuous",
                    Height = 30.0,
                    Width = 125.0,
                    Margin = new Thickness(0.0, 4.0, 4.0, 0.0),
                    Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Style = style
                };
                this.AUTOArmbtn.Background = Brushes.Gray;
                this.AUTOArmbtn.BorderBrush = Brushes.DimGray;
                this.AUTOArmbtn.Foreground = Brushes.White;
                this.AUTOArmbtn.Click += this.AUTOArmbtn_Click;
                Grid.SetColumn(this.AUTOArmbtn, 2);
                Grid.SetRow(this.AUTOArmbtn, 4);
                grid5.Children.Add(this.AUTOArmbtn);

                // CLOSE Button
                this.Closebtn = new Button
                {
                    Content = string.Format("Flatten", 1),
                    Name = "Flatten",
                    Height = 30.0,
                    Margin = new Thickness(4.0, 4.0, 4.0, 0.0),
                    Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
                    Style = style
                };
                this.Closebtn.Background = Brushes.Red;
                this.Closebtn.BorderBrush = Brushes.DimGray;
                this.Closebtn.Foreground = Brushes.White;
                this.Closebtn.Click += this.Closebtn_Click;
                this.Closebtn.PreviewMouseDown += new MouseButtonEventHandler(this.Closebtn_MouseDown);
                this.Closebtn.PreviewMouseUp += new MouseButtonEventHandler(this.Closebtn_MouseUp);
                this.Closebtn.MouseLeave += new MouseEventHandler(this.Closebtn_MouseLeave);
                Grid.SetColumnSpan(this.Closebtn, 3);
                Grid.SetRow(this.Closebtn, 5);
                grid5.Children.Add(this.Closebtn);

                this.tileHolder = new Border
                {
                    Cursor = Cursors.Arrow,
                    Background = (Application.Current.FindResource("BackgroundMainWindow") as System.Windows.Media.Brush),
                    BorderThickness = new Thickness((double)(Application.Current.FindResource("BorderThinThickness") ?? 1)),
                    BorderBrush = (Application.Current.FindResource("BorderThinBrush") as System.Windows.Media.Brush),
                    Child = grid5
                };
                this.grid.Children.Add(this.tileHolder);
                this.hideB.MouseUp += delegate (object sender, MouseButtonEventArgs e)
                {
                    // Hide or show the UI elements when the hide button is clicked
                    if (this.ARMOPTIONbtn.Visibility == Visibility.Visible)
                    {
                        this.ARMOPTIONbtn.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        this.ARMOPTIONbtn.Visibility = Visibility.Visible;
                    }
                    if (this.ARMSHORTbtn.Visibility == Visibility.Visible)
                    {
                        this.ARMSHORTbtn.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        this.ARMSHORTbtn.Visibility = Visibility.Visible;
                    }
                    if (this.ARMLONGbtn.Visibility == Visibility.Visible)
                    {
                        this.ARMLONGbtn.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        this.ARMLONGbtn.Visibility = Visibility.Visible;
                    }
                    if (this.Closebtn.Visibility == Visibility.Visible)
                    {
                        this.Closebtn.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        this.Closebtn.Visibility = Visibility.Visible;
                    }
                    if (this.AUTOArmbtn.Visibility == Visibility.Visible)
                    {
                        this.AUTOArmbtn.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        this.AUTOArmbtn.Visibility = Visibility.Visible;
                    }
                    if (this.selectedATMStrat.Visibility == Visibility.Visible)
                    {
                        this.selectedATMStrat.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        this.selectedATMStrat.Visibility = Visibility.Visible;
                    }
                    if (this.ATMLabel.Visibility == Visibility.Visible)
                    {
                        this.ATMLabel.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        this.ATMLabel.Visibility = Visibility.Visible;
                    }
                    if (this.accountSelected.Visibility == Visibility.Visible)
                    {
                        this.accountSelected.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        this.accountSelected.Visibility = Visibility.Visible;
                    }
                    if (this.ACCOUNTLabel.Visibility == Visibility.Visible)
                    {
                        this.ACCOUNTLabel.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        this.ACCOUNTLabel.Visibility = Visibility.Visible;
                    }
                    if (this.moveB.Visibility == Visibility.Visible)
                    {
                        this.moveB.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        this.moveB.Visibility = Visibility.Visible;
                    }
                };
                this.grid.Children.Add(this.hideB);
                if (this.IsVisibleOnlyFocused)
                {
                    Binding binding = new Binding("IsActive")
                    {
                        Source = ChartControl.OwnerChart,
                        Converter = (Application.Current.FindResource("BoolToVisConverter") as IValueConverter)
                    };
                    this.grid.SetBinding(UIElement.VisibilityProperty, binding);
                    return this.grid;
                }
            }
            catch (Exception)
            {
            }
            return this.grid;
        }

        private static string CensorString(string input)
        {
            if (input != null && input.Length >= 3)
            {
                if (input.Length > 10)
                {
                    input = input.Substring(0, Math.Min(input.Length, 10));
                }
                else
                {
                    input = input.PadRight(10);
                }
                int count = input.Length - 2;
                string str = new string('*', count);
                return input.Substring(0, 2) + str;
            }
            return input;
        }

        private void resetQuantVal_Click(object sender, EventArgs e)
        {
            int num = 1;
            this.quantityLabelVal.Text = num.ToString();
            this.quantityValue = num;
            this.armOptionBtnToggle = false;
            this.ARMOPTIONbtn.Background = Brushes.Gray;
            this.ARMOPTIONbtn.Foreground = Brushes.White;
            this.ARMOPTIONbtn.Content = "Semi Auto";
            this.autoArmBtnToggle = false;
            this.AUTOArmbtn.Background = Brushes.Gray;
            this.AUTOArmbtn.Foreground = Brushes.White;
            this.AUTOArmbtn.Content = "Full Auto";
            this.armShortBtnToggle = false;
            this.ARMSHORTbtn.Background = Brushes.Gray;
            this.ARMSHORTbtn.Foreground = Brushes.White;
            this.armLongBtnToggle = false;
            this.ARMLONGbtn.Background = Brushes.Gray;
            this.ARMLONGbtn.Foreground = Brushes.White;
        }

        private void increaseQuant_Click(object sender, EventArgs e)
        {
            int num;
            if ((num = this.quantityValue + 1) < 1)
            {
                num = 1;
            }
            else if (num > 50)
            {
                num = 50;
            }
            this.quantityLabelVal.Text = num.ToString();
            this.quantityValue = num;
        }

        private void decreaseQuant_Click(object sender, EventArgs e)
        {
            int num;
            if ((num = this.quantityValue - 1) < 1)
            {
                num = 1;
            }
            else if (num > 50)
            {
                num = 50;
            }
            this.quantityLabelVal.Text = num.ToString();
            this.quantityValue = num;
        }

        private void ACCOUNTSelection_Changed(object sender, EventArgs e)
        {
            bool flag = false;
            lock (Connection.Connections)
            {
                foreach (Connection connection in Connection.Connections)
                {
                    if (connection.Status == ConnectionStatus.Connected)
                    {
                        flag = true;
                        break;
                    }
                }
            }
            if (!flag)
            {
                this.accountSelected.Content = "Disconnected";
                return;
            }
            if (this.accountSelector != null)
            {
                if (this.accountSelector.SelectedIndex.ToString() == string.Empty || this.accountSelector.SelectedAccount.Name == string.Empty || this.accountSelector.SelectedAccount.Name == null || this.accountSelector == null)
                {
                    this.accountSelected.Content = "Select Account";
                }
                this.accountSelected.Content = NinjaTrader.NinjaScript.Indicators.AutoDeltaDivZigZag.CensorString(this.accountSelector.SelectedAccount.DisplayName);
            }
        }

        private void TextBox_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            TextBox textBox = sender as TextBox;
            if (textBox != null)
            {
                if ((e.Key >= Key.D0 && e.Key <= Key.D9) || (e.Key >= Key.NumPad0 && e.Key <= Key.NumPad9))
                {
                    int num = (e.Key >= Key.NumPad0) ? (e.Key - Key.NumPad0) : (e.Key - Key.D0);
                    textBox.Text += num.ToString();
                    e.Handled = true;
                    return;
                }
                if (e.Key != Key.Back && e.Key != Key.Delete)
                {
                    if (e.Key != Key.Tab)
                    {
                        if (e.Key == Key.Return)
                        {
                            textBox.Text = textBox.Text;
                            this.quantityValue = int.Parse(textBox.Text);
                            e.Handled = false;
                            return;
                        }
                        e.Handled = true;
                        return;
                    }
                }
                e.Handled = false;
                return;
            }
        }

        private void TextBox_LostFocus(object sender, EventArgs e)
        {
            TextBox textBox = sender as TextBox;
            if (textBox != null)
            {
                textBox.Text = textBox.Text;
                this.quantityValue = int.Parse(textBox.Text);
            }
        }

        private void ATMSelection_Changed(object sender, EventArgs e)
        {
            if (this.selectedATMStrat == null || this.atmSelector.SelectedAtmStrategy == null)
            {
                this.selectedATMStrat.Content = "None";
                return;
            }
            if (!(this.atmSelector.SelectedItem.ToString() != "None"))
            {
                this.selectedATMStrat.Content = "None";
                return;
            }
            Dispatcher.InvokeAsync(delegate ()
            {
                QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
                this.quantityATM = quantityUpDown.Value;
            });
            if (this.atmSelector.SelectedAtmStrategy.DisplayName.Contains("-"))
            {
                this.selectedATMStrat.Content = this.atmSelector.SelectedAtmStrategy.DisplayName;
                return;
            }
            this.selectedATMStrat.Content = this.atmSelector.SelectedAtmStrategy.DisplayName;
        }
        #endregion

        #region Trade Execution Methods
        private void ARMLONGbtn_Click(object sender, RoutedEventArgs e)
        {
            if (!this.armLongBtnToggle)
            {
                this.armLongBtnToggle = true;
                this.onceTriggered = false;
                this.ARMLONGbtn.Background = Brushes.LimeGreen;
                this.ARMLONGbtn.Foreground = Brushes.Black;
                return;
            }
            this.armLongBtnToggle = false;
            this.ARMLONGbtn.Background = Brushes.Gray;
            this.ARMLONGbtn.Foreground = Brushes.White;
        }

        private void onceTriggeredARMLONGbtn()
        {
            this.armLongBtnToggle = false;
            this.ARMLONGbtn.Background = Brushes.Gray;
            this.ARMLONGbtn.Foreground = Brushes.White;
        }

        private void ARMSHORTbtn_Click(object sender, RoutedEventArgs e)
        {
            if (!this.armShortBtnToggle)
            {
                this.armShortBtnToggle = true;
                this.onceTriggered = false;
                this.ARMSHORTbtn.Background = Brushes.LimeGreen;
                this.ARMSHORTbtn.Foreground = Brushes.Black;
                return;
            }
            this.armShortBtnToggle = false;
            this.ARMSHORTbtn.Background = Brushes.Gray;
            this.ARMSHORTbtn.Foreground = Brushes.White;
        }

        private void onceTriggeredARMSHORTbtn()
        {
            this.armShortBtnToggle = false;
            this.ARMSHORTbtn.Background = Brushes.Gray;
            this.ARMSHORTbtn.Foreground = Brushes.White;
        }

        private void ARMOPTIONbtn_Click(object sender, RoutedEventArgs e)
        {
            if (!this.armOptionBtnToggle)
            {
                this.armOptionBtnToggle = true;
                this.ARMOPTIONbtn.Background = Brushes.DodgerBlue;
                this.ARMOPTIONbtn.Foreground = Brushes.White;
                this.ARMOPTIONbtn.Content = "Semi Auto - On";
                this.autoArmBtnToggle = false;
                this.AUTOArmbtn.Background = Brushes.Gray;
                this.AUTOArmbtn.Foreground = Brushes.White;
                this.AUTOArmbtn.Content = "Full Auto";
                return;
            }
            this.armOptionBtnToggle = false;
            this.ARMOPTIONbtn.Background = Brushes.Gray;
            this.ARMOPTIONbtn.Foreground = Brushes.White;
            this.ARMOPTIONbtn.Content = "Semi Auto";
        }

        private void AUTOArmbtn_Click(object sender, RoutedEventArgs e)
        {
            if (!this.autoArmBtnToggle)
            {
                this.autoArmBtnToggle = true;
                this.AUTOArmbtn.Background = Brushes.DodgerBlue;
                this.AUTOArmbtn.Foreground = Brushes.White;
                this.AUTOArmbtn.Content = "Full Auto - On";
                this.armOptionBtnToggle = false;
                this.ARMOPTIONbtn.Background = Brushes.Gray;
                this.ARMOPTIONbtn.Foreground = Brushes.White;
                this.ARMOPTIONbtn.Content = "Semi Auto";
                return;
            }
            this.autoArmBtnToggle = false;
            this.AUTOArmbtn.Background = Brushes.Gray;
            this.AUTOArmbtn.Foreground = Brushes.White;
            this.AUTOArmbtn.Content = "Full Auto";
        }

        private void Closebtn_Click(object sender, RoutedEventArgs e)
        {
            this.CloseTrades(true);
            this.autoArmBtnToggle = false;
            this.AUTOArmbtn.Background = Brushes.Gray;
            this.AUTOArmbtn.Foreground = Brushes.White;
            this.AUTOArmbtn.Content = "Full Auto";
            this.armOptionBtnToggle = false;
            this.ARMOPTIONbtn.Background = Brushes.Gray;
            this.ARMOPTIONbtn.Foreground = Brushes.White;
            this.ARMOPTIONbtn.Content = "Semi Auto";
            this.armShortBtnToggle = false;
            this.ARMSHORTbtn.Background = Brushes.Gray;
            this.ARMSHORTbtn.Foreground = Brushes.White;
            this.armLongBtnToggle = false;
            this.ARMLONGbtn.Background = Brushes.Gray;
            this.ARMLONGbtn.Foreground = Brushes.White;
        }

        private void Closebtn_MouseDown(object sender, RoutedEventArgs e)
        {
            if (this.Closebtn.IsMouseOver)
            {
                this.Closebtn.Background = Brushes.Maroon;
            }
            this.Closebtn.Background = Brushes.Maroon;
            this.Closebtn.FontStyle = FontStyles.Oblique;
        }

        private void Closebtn_MouseUp(object sender, RoutedEventArgs e)
        {
            this.Closebtn.Background = Brushes.Red;
            this.Closebtn.FontStyle = FontStyles.Normal;
        }

        private void Closebtn_MouseLeave(object sender, RoutedEventArgs e)
        {
            this.Closebtn.Background = Brushes.Red;
        }

        private void takeTrade(int direction)
	    {
			if (State != State.Realtime || !connected || this.getInstrumentPosition() != null)
	        return;
	      if (!this.armLongBtnToggle)
	      {
	        if (!this.armShortBtnToggle)
	          return;
	      }
	      try
				{
					AtmStrategy atmStrategy = null;
					object atmSelChoice = null;
					ChartControl.Dispatcher.Invoke(delegate()
					{
						AtmStrategySelector atmStrategySelector = Extensions.FindFirst(Window.GetWindow(this.ChartControl.Parent), "ChartTraderControlATMStrategySelector") as AtmStrategySelector;
						atmSelChoice = ((atmStrategySelector != null) ? atmStrategySelector.SelectedItem : null);
					});
					ChartControl.Dispatcher.Invoke(delegate()
					{
						QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
						this.quantityATM = quantityUpDown.Value;
					});
	        int quantity = this.quantityValue;
	        this.Dispatcher.InvokeAsync((Action) (() => quantity = this.quantityValue));
	        if (this.chartTraderAccount == null || atmSelChoice == null)
	          return;
	        if (atmSelChoice.ToString() != "None")
	          atmStrategy = (NinjaTrader.NinjaScript.AtmStrategy) atmSelChoice;
	        if (!this.armOptionBtnToggle && this.autoArmBtnToggle && (this.armLongBtnToggle || this.armShortBtnToggle))
	        {
	          if (!this.inPosition)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	            else if (direction < 0 && this.armShortBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	          }
	          if (this.inPosition && this.posDirection == -1)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              this.CloseTrades(false);
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	            else if (this.armShortBtnToggle && direction < 0)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	          }
	          if (!this.inPosition || this.posDirection != 1)
	            return;
	          if (direction < 0 && this.armShortBtnToggle)
	          {
	            this.CloseTrades(false);
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                try
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                catch (Exception ex)
	                {
	                }
	              }
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	            }
	          }
	          else
	          {
	            if (!this.armLongBtnToggle || direction <= 0)
	              return;
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	              }
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	            }
	          }
	        }
	        else
	        {
	          if (this.autoArmBtnToggle || !this.armOptionBtnToggle || this.onceTriggered || !this.armLongBtnToggle && !this.armShortBtnToggle)
	            return;
	          if (!this.inPosition)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	               ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	            else if (direction < 0 && this.armShortBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	          }
	          if (this.inPosition && this.posDirection == -1)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              this.CloseTrades(false);
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	               ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	            else if (this.armShortBtnToggle && direction < 0)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	          }
	          if (!this.inPosition || this.posDirection != 1)
	            return;
	          if (direction < 0 && this.armShortBtnToggle)
	          {
	            this.CloseTrades(false);
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                try
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                catch (Exception ex)
	                {
	                }
	              }
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	          }
	          else
	          {
	            if (!this.armLongBtnToggle || direction <= 0)
	              return;
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	              }
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	          }
	        }
	      }
	      catch (Exception ex)
	      {
	      }
	    }

        private void CloseTrades(bool yn)
	    {
	     if (yn)
			{
				List<Instrument> instrumentNames = new List<Instrument>();
				Dispatcher.BeginInvoke(new Action(delegate()
	        {
	          try
	          {
	            if (this.chartTraderAccount.Positions.Count == 0)
	              return;
	            foreach (Position position in this.chartTraderAccount.Positions)
	            {
	              Instrument instrument = position.Instrument;
	              if (!instrumentNames.Contains(instrument))
	                instrumentNames.Add(instrument);
	            }
	            this.chartTraderAccount.Flatten((ICollection<Instrument>) instrumentNames);
	            Thread.Sleep(250);
	          }
	          catch (Exception ex)
	          {
	          }
	        }));
	      }
	      else
	      {
	        if (this.inPosition && this.posDirection == -1)
	        {
	          int quantity = this.positions.Quantity;
	          int num = 0;
	          this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	          {
	            this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 1, (OrderType) 1, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "Entry", (CustomOrder) null)
	          });
	          foreach (Order order in this.chartTraderAccount.Orders)
	          {
	            if (order.Instrument == this.inst && order.OrderType == null && order.OrderState == (OrderState)10 && num < quantity)
	            {
	              ++num;
	              this.chartTraderAccount.Cancel((IEnumerable<Order>) new Order[1]
	              {
	                order
	              });
	            }
	          }
	        }
	        if (!this.inPosition || this.posDirection != 1)
	          return;
	        int quantity1 = this.positions.Quantity;
	        int num1 = 0;
	        this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	        {
	          this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (TimeInForce) 1, quantity1, 0.0, 0.0, string.Empty, "Entry", (CustomOrder) null)
	        });
	        foreach (Order order in this.chartTraderAccount.Orders)
	        {
	          if (order.Instrument == this.inst && order.OrderType == null && order.OrderState == (OrderState)10 && num1 < quantity1)
	          {
	            ++num1;
	            this.chartTraderAccount.Cancel((IEnumerable<Order>) new Order[1]
	            {
	              order
	            });
	          }
	        }
	      }
	    }

        private Position getInstrumentPosition()
        {
            long instrumentId = this.inst.Id;
            Position pos = null;
            Account myAccount = null;
            try
            {
                ChartControl.Dispatcher.Invoke(delegate ()
                {
                    lock (Account.All)
                    {
                        myAccount = Account.All.FirstOrDefault((Account a) => a.Name == this.accountSelector.SelectedAccount.DisplayName);
                    }
                    pos = myAccount.GetPosition(instrumentId);
                    realizedPnL = myAccount.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar); /// Added
                });
                if (pos == null)
                {
                    return null;
                }
                if (pos != null)
                {
                    return pos;
                }
            }
            catch (Exception)
            {
            }
            return pos;
        }

        private void acctCallback(object o)
        {
            try
            {
                ChartControl.Dispatcher.Invoke(delegate ()
                {
                    AccountSelector accountSelector = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlAccountSelector") as AccountSelector;
                    this.chartTraderAccount = ((accountSelector != null) ? accountSelector.SelectedAccount : null);
                    this.accountSelector = ((accountSelector != null) ? accountSelector : null);
                });
                if (this.chartTraderAccount != null && !this.handlerSet)
                {
                    this.handlerSet = true;
                    this.accountSelector.SelectionChanged += new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
                }
            }
            catch (Exception)
            {
            }
        }

        private void posCallback(object o)
        {
            long id = this.inst.Id;
            Position position = null;
            Account account = null;
            try
            {
                lock (Account.All)
                {
                    account = Account.All.FirstOrDefault((Account a) => a.Name == this.chartTraderAccount.DisplayName);
                }
                position = account.GetPosition(id);
                realizedPnL = account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar); /// Added
            }
            catch (Exception e)
            {
            }
            if (account == null)
            {
                this.inPosition = false;
                this.posDirection = 0;
                this.positions = null;
                return;
            }
            if (position == null)
            {
                this.inPosition = false;
                this.posDirection = 0;
                this.positions = null;
                return;
            }
            if (position != null)
            {
                this.inPosition = true;
                this.positions = position;
                if (position.MarketPosition == null)
                {
                    this.posDirection = 1;
                    return;
                }
                if (position.MarketPosition == MarketPosition.Short)
                {
                    this.posDirection = -1;
                }
            }
        }
        #endregion

        protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
        {
        }

        public override void OnRenderTargetChanged()
        {
        }

        #region Properties

        [NinjaScriptProperty]
        [Range(10, 10000)]
        [Display(Name = "Delta Threshold", Order = 1, GroupName = "Parameters")]
        public double DeltaThreshold { get; set; }

        [NinjaScriptProperty]
        [Range(0.1, 10.0)]
        [Display(Name = "ZigZag Deviation (%)", Order = 2, GroupName = "Parameters")]
        public double ZigZagDeviation { get; set; }

        // Existing properties
        [Browsable(false)]
        public double Top { get; set; }

        [Browsable(false)]
        public double Left { get; set; }

        [Display(ResourceType = typeof(Resource), Name = "NinjaScriptIsVisibleOnlyFocused", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 499)]
        [Browsable(false)]
        public bool IsVisibleOnlyFocused { get; set; }

        [Browsable(false)]
        public XElement SelectedTypes { get; set; }

        [Display(ResourceType = typeof(Resource), Name = "NinjaScriptNumberOfRows", GroupName = "NinjaScriptParameters", Order = 0)]
        [Range(1, 2147483647)]
        [Browsable(false)]
        public int NumberOfRows { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Profit Target", GroupName = "Total Strategy Profit Target / StopLoss", Order = 0)]
        public int realizedProfit { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "StopLoss (Negative Number)", GroupName = "Total Strategy Profit Target / StopLoss", Order = 0)]
        public int realizedLoss { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Start Time", GroupName = "Time Settings HHMMSS Format", Order = 2)]
        public int startTime { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "End Time", GroupName = "Time Settings HHMMSS Format", Order = 3)]
        public int endTime { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Econ1 Time", GroupName = "Time Settings HHMMSS Format", Order = 6)]
        public int econNumber1 { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Econ2 Time", GroupName = "Time Settings HHMMSS Format", Order = 7)]
        public int econNumber2 { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Market Open Time", GroupName = "Time Settings HHMMSS Format", Order = 1)]
        public int openTime { get; set; }

        [Display(Name = "Set Account For PNL Tracking", GroupName = "Performance", Order = 1)]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.AccountNameConverter))]
        public string AccountName { get; set; }

        #endregion
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private AutoDeltaDivZigZag[] cacheAutoDeltaDivZigZag;
		public AutoDeltaDivZigZag AutoDeltaDivZigZag(double deltaThreshold, double zigZagDeviation, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime)
		{
			return AutoDeltaDivZigZag(Input, deltaThreshold, zigZagDeviation, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime);
		}

		public AutoDeltaDivZigZag AutoDeltaDivZigZag(ISeries<double> input, double deltaThreshold, double zigZagDeviation, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime)
		{
			if (cacheAutoDeltaDivZigZag != null)
				for (int idx = 0; idx < cacheAutoDeltaDivZigZag.Length; idx++)
					if (cacheAutoDeltaDivZigZag[idx] != null && cacheAutoDeltaDivZigZag[idx].DeltaThreshold == deltaThreshold && cacheAutoDeltaDivZigZag[idx].ZigZagDeviation == zigZagDeviation && cacheAutoDeltaDivZigZag[idx].realizedProfit == realizedProfit && cacheAutoDeltaDivZigZag[idx].realizedLoss == realizedLoss && cacheAutoDeltaDivZigZag[idx].startTime == startTime && cacheAutoDeltaDivZigZag[idx].endTime == endTime && cacheAutoDeltaDivZigZag[idx].econNumber1 == econNumber1 && cacheAutoDeltaDivZigZag[idx].econNumber2 == econNumber2 && cacheAutoDeltaDivZigZag[idx].openTime == openTime && cacheAutoDeltaDivZigZag[idx].EqualsInput(input))
						return cacheAutoDeltaDivZigZag[idx];
			return CacheIndicator<AutoDeltaDivZigZag>(new AutoDeltaDivZigZag(){ DeltaThreshold = deltaThreshold, ZigZagDeviation = zigZagDeviation, realizedProfit = realizedProfit, realizedLoss = realizedLoss, startTime = startTime, endTime = endTime, econNumber1 = econNumber1, econNumber2 = econNumber2, openTime = openTime }, input, ref cacheAutoDeltaDivZigZag);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.AutoDeltaDivZigZag AutoDeltaDivZigZag(double deltaThreshold, double zigZagDeviation, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime)
		{
			return indicator.AutoDeltaDivZigZag(Input, deltaThreshold, zigZagDeviation, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime);
		}

		public Indicators.AutoDeltaDivZigZag AutoDeltaDivZigZag(ISeries<double> input , double deltaThreshold, double zigZagDeviation, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime)
		{
			return indicator.AutoDeltaDivZigZag(input, deltaThreshold, zigZagDeviation, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.AutoDeltaDivZigZag AutoDeltaDivZigZag(double deltaThreshold, double zigZagDeviation, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime)
		{
			return indicator.AutoDeltaDivZigZag(Input, deltaThreshold, zigZagDeviation, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime);
		}

		public Indicators.AutoDeltaDivZigZag AutoDeltaDivZigZag(ISeries<double> input , double deltaThreshold, double zigZagDeviation, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime)
		{
			return indicator.AutoDeltaDivZigZag(input, deltaThreshold, zigZagDeviation, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime);
		}
	}
}

#endregion


#########################

#region Using declarations
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Windows.Media;
using NinjaTrader.Cbi;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

namespace NinjaTrader.NinjaScript.Indicators
{
    public class DeltaDivergenceZigZag : Indicator
    {
        #region Variables
        private double deltaThreshold;
        private double zigZagDeviation;
        private OrderFlowCumulativeDelta cumulativeDelta;
        private ZigZag zigZag;
        #endregion

        #region Properties
        [NinjaScriptProperty]
        [Range(10, 10000)]
        [Display(Name = "Delta Threshold", Order = 1, GroupName = "Parameters")]
        public double DeltaThreshold { get; set; }

        [NinjaScriptProperty]
        [Range(0.1, 10.0)]
        [Display(Name = "ZigZag Deviation (%)", Order = 2, GroupName = "Parameters")]
        public double ZigZagDeviation { get; set; }
        #endregion

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Description = "Identifies potential pivot points based on delta divergence and ZigZag swings.";
                Name = "Delta Divergence with ZigZag";
                Calculate = Calculate.OnPriceChange;
                IsOverlay = true;
                DisplayInDataBox = true;
                DrawOnPricePanel = true;
                PaintPriceMarkers = true;
                IsSuspendedWhileInactive = true;

                // Default parameters
                DeltaThreshold = 100;
                ZigZagDeviation = 0.5;

                AddPlot(Brushes.Transparent, "ZigZagPlot"); // ZigZagPlot is added here but made invisible to avoid impacting chart scaling or render issues
                AddPlot(Brushes.Transparent, "DeltaPlot"); // DeltaPlot is added here but made invisible to avoid impacting chart scaling or render issues
               
            }
            else if (State == State.Configure)
            {
                // Add the required data series for cumulative delta and ZigZag
                AddDataSeries(Data.BarsPeriodType.Tick, 1); // For cumulative delta (tick data)
                AddDataSeries(Data.BarsPeriodType.Range, 4); // For ZigZag (range data)
            }
            else if (State == State.DataLoaded)
            {
                // Initialize cumulative delta indicator
                cumulativeDelta = OrderFlowCumulativeDelta(CumulativeDeltaType.BidAsk, CumulativeDeltaPeriod.Bar, 0);
                zigZag = ZigZag(DeviationType.Percent, ZigZagDeviation, false);
            }
        }

        protected override void OnBarUpdate()
        {
            if (CurrentBar < 2)
                return;

            // Ensure we are processing the primary series
            if (BarsInProgress != 0)
                return;

            // Debugging: Print current bar number
            Print($"Processing bar {CurrentBar}");

            // Ensure zigZag and cumulativeDelta values are valid before accessing them
            if (zigZag == null || cumulativeDelta == null)
            {
                Print("ZigZag or CumulativeDelta is not initialized.");
                return;
            }

            // Plot the ZigZag and Delta for visual analysis
            double zigZagValue = zigZag[0];
            double deltaValue = cumulativeDelta.DeltaClose[0];

            Values[0][0] = zigZagValue != 0 ? zigZagValue : double.NaN;
            Values[1][0] = deltaValue;

            // Find the latest ZigZag swings
            int lastSwingHighIndex = zigZag.HighBar(0, 1, CurrentBar);
            int lastSwingLowIndex = zigZag.LowBar(0, 1, CurrentBar);

            // Process swing highs for bearish divergence
            if (lastSwingHighIndex >= 0 && lastSwingHighIndex < CurrentBar)
            {
                double lastPriceHigh = High[lastSwingHighIndex];
                double currentPriceHigh = High[0];
                double lastDeltaHigh = cumulativeDelta.DeltaClose[lastSwingHighIndex];
                double currentDeltaHigh = cumulativeDelta.DeltaClose[0];

                // Bearish divergence check
                if (currentPriceHigh > lastPriceHigh && currentDeltaHigh < lastDeltaHigh - DeltaThreshold)
                {
                    Print($"Bearish Divergence detected at bar {CurrentBar}: LastPriceHigh={lastPriceHigh}, CurrentPriceHigh={currentPriceHigh}, LastDeltaHigh={lastDeltaHigh}, CurrentDeltaHigh={currentDeltaHigh}");
                    Draw.ArrowDown(this, "BearDiv" + CurrentBar, true, 0, High[0] + TickSize * 5, Brushes.Red);
                }
            }

            // Process swing lows for bullish divergence
            if (lastSwingLowIndex >= 0 && lastSwingLowIndex < CurrentBar)
            {
                double lastPriceLow = Low[lastSwingLowIndex];
                double currentPriceLow = Low[0];
                double lastDeltaLow = cumulativeDelta.DeltaClose[lastSwingLowIndex];
                double currentDeltaLow = cumulativeDelta.DeltaClose[0];

                // Bullish divergence check
                if (currentPriceLow < lastPriceLow && currentDeltaLow > lastDeltaLow + DeltaThreshold)
                {
                    Print($"Bullish Divergence detected at bar {CurrentBar}: LastPriceLow={lastPriceLow}, CurrentPriceLow={currentPriceLow}, LastDeltaLow={lastDeltaLow}, CurrentDeltaLow={currentDeltaLow}");
                    Draw.ArrowUp(this, "BullDiv" + CurrentBar, true, 0, Low[0] - TickSize * 5, Brushes.Green);
                }
            }
        }
    }
}


#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private DeltaDivergenceZigZag[] cacheDeltaDivergenceZigZag;
		public DeltaDivergenceZigZag DeltaDivergenceZigZag(double deltaThreshold, double zigZagDeviation)
		{
			return DeltaDivergenceZigZag(Input, deltaThreshold, zigZagDeviation);
		}

		public DeltaDivergenceZigZag DeltaDivergenceZigZag(ISeries<double> input, double deltaThreshold, double zigZagDeviation)
		{
			if (cacheDeltaDivergenceZigZag != null)
				for (int idx = 0; idx < cacheDeltaDivergenceZigZag.Length; idx++)
					if (cacheDeltaDivergenceZigZag[idx] != null && cacheDeltaDivergenceZigZag[idx].DeltaThreshold == deltaThreshold && cacheDeltaDivergenceZigZag[idx].ZigZagDeviation == zigZagDeviation && cacheDeltaDivergenceZigZag[idx].EqualsInput(input))
						return cacheDeltaDivergenceZigZag[idx];
			return CacheIndicator<DeltaDivergenceZigZag>(new DeltaDivergenceZigZag(){ DeltaThreshold = deltaThreshold, ZigZagDeviation = zigZagDeviation }, input, ref cacheDeltaDivergenceZigZag);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.DeltaDivergenceZigZag DeltaDivergenceZigZag(double deltaThreshold, double zigZagDeviation)
		{
			return indicator.DeltaDivergenceZigZag(Input, deltaThreshold, zigZagDeviation);
		}

		public Indicators.DeltaDivergenceZigZag DeltaDivergenceZigZag(ISeries<double> input , double deltaThreshold, double zigZagDeviation)
		{
			return indicator.DeltaDivergenceZigZag(input, deltaThreshold, zigZagDeviation);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.DeltaDivergenceZigZag DeltaDivergenceZigZag(double deltaThreshold, double zigZagDeviation)
		{
			return indicator.DeltaDivergenceZigZag(Input, deltaThreshold, zigZagDeviation);
		}

		public Indicators.DeltaDivergenceZigZag DeltaDivergenceZigZag(ISeries<double> input , double deltaThreshold, double zigZagDeviation)
		{
			return indicator.DeltaDivergenceZigZag(input, deltaThreshold, zigZagDeviation);
		}
	}
}

#endregion


#########################

#region Using declarations
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Windows.Media;
using NinjaTrader.Cbi;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

namespace NinjaTrader.NinjaScript.Indicators
{
    public class DeltaDivergenceZigZagWIP : Indicator
    {
        #region Variables
        private OrderFlowCumulativeDelta cumulativeDelta;
        private ZigZag zigZag;
        private Series<double> smoothedDelta;

        private double averageDelta;
        #endregion

        #region Properties
        [NinjaScriptProperty]
        [Range(1, 10000)]
        [Display(Name = "Delta Lookback", Order = 1, GroupName = "Parameters")]
        public int DeltaLookback { get; set; }

        [NinjaScriptProperty]
        [Range(0.1, 10.0)]
        [Display(Name = "Threshold Factor", Order = 2, GroupName = "Parameters")]
        public double ThresholdFactor { get; set; }

        [NinjaScriptProperty]
        [Range(1, 50)]
        [Display(Name = "Smoothing Period", Order = 3, GroupName = "Parameters")]
        public int SmoothingPeriod { get; set; }

        [NinjaScriptProperty]
        [Range(1, 10)]
        [Display(Name = "Confirmation Bars", Order = 4, GroupName = "Parameters")]
        public int ConfirmationBars { get; set; }

        // Allow very small percentage increments, e.g. 0.0001%
        [NinjaScriptProperty]
        [Range(0.0001, 10.0)]
        [Display(Name = "ZigZag Deviation (%)", Order = 5, GroupName = "Parameters")]
        public double ZigZagDeviationPercent { get; set; }
        #endregion

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Description                 = "Identifies potential pivot points based on normalized delta divergence and ZigZag swings.";
                Name                        = "Delta Divergence with ZigZag (Enhanced - Percent)";
                Calculate                   = Calculate.OnPriceChange;
                IsOverlay                   = true;
                DisplayInDataBox            = true;
                DrawOnPricePanel            = true;
                PaintPriceMarkers           = true;
                IsSuspendedWhileInactive    = true;

                // Default parameters
                DeltaLookback               = 20;
                ThresholdFactor             = 1.5;
                SmoothingPeriod             = 5;
                ConfirmationBars            = 2;
                ZigZagDeviationPercent      = 0.1; // default 0.1% deviation

                AddPlot(Brushes.Transparent, "ZigZagPlot");
                AddPlot(Brushes.Transparent, "DeltaPlot");
            }
            else if (State == State.Configure)
            {
                // Add the required data series
                AddDataSeries(Data.BarsPeriodType.Tick, 1);
                AddDataSeries(Data.BarsPeriodType.Range, 4);
            }
            else if (State == State.DataLoaded)
            {
                // Use second series for cumulative delta (tick), third for ZigZag (range)
                cumulativeDelta = OrderFlowCumulativeDelta(BarsArray[1], CumulativeDeltaType.BidAsk, CumulativeDeltaPeriod.Bar, 0);
                zigZag = ZigZag(BarsArray[2], DeviationType.Percent, ZigZagDeviationPercent, false);

                smoothedDelta = new Series<double>(this);
            }
        }

        protected override void OnBarUpdate()
        {
            // Ensure primary series
            if (BarsInProgress != 0)
                return;

            if (CurrentBar < Math.Max(DeltaLookback, SmoothingPeriod))
                return;

            // Compute smoothed delta
            double rawDelta = cumulativeDelta.DeltaClose[0];
            double smoothedValue = SMA(cumulativeDelta.DeltaClose, SmoothingPeriod)[0];
            smoothedDelta[0] = smoothedValue;

            // Compute adaptive threshold
            averageDelta = SMA(cumulativeDelta.DeltaClose, DeltaLookback)[0];
            double adaptiveThreshold = averageDelta * ThresholdFactor;

            // Plot values (invisible by default)
            Values[0][0] = zigZag[0] != 0 ? zigZag[0] : double.NaN;
            Values[1][0] = smoothedDelta[0];

            // Find the latest ZigZag swings
            int lastSwingHighAgo = zigZag.HighBar(0, 1, CurrentBar);
            int lastSwingLowAgo  = zigZag.LowBar(0, 1, CurrentBar);

            // Check swing highs for bearish divergence
            if (lastSwingHighAgo > 0 && lastSwingHighAgo <= CurrentBar && lastSwingHighAgo > ConfirmationBars)
            {
                double lastPriceHigh    = High[lastSwingHighAgo];
                double currentPriceHigh = High[0];
                double lastDeltaHigh    = smoothedDelta[lastSwingHighAgo];
                double currentDeltaHigh = smoothedDelta[0];

                double priceDiff = currentPriceHigh - lastPriceHigh;
                double deltaDiff = currentDeltaHigh - lastDeltaHigh;

                if (Math.Abs(priceDiff) > 1e-10)
                {
                    double normalizedDeltaDiff = deltaDiff / Math.Abs(priceDiff);

                    bool confirmed = true;
                    for (int i = 0; i < ConfirmationBars; i++)
                    {
                        double tempPriceDiff = High[i] - lastPriceHigh;
                        double tempDeltaDiff = smoothedDelta[i] - lastDeltaHigh;
                        if (Math.Abs(tempPriceDiff) > 1e-10)
                        {
                            double tempNormalizedDeltaDiff = tempDeltaDiff / Math.Abs(tempPriceDiff);
                            // Bearish condition: Price higher but delta lower
                            if (!(High[i] > lastPriceHigh && tempNormalizedDeltaDiff < -adaptiveThreshold))
                            {
                                confirmed = false;
                                break;
                            }
                        }
                        else
                        {
                            confirmed = false;
                            break;
                        }
                    }

                    if (confirmed && currentPriceHigh > lastPriceHigh && normalizedDeltaDiff < -adaptiveThreshold)
                    {
                        Draw.ArrowDown(this, "BearDiv" + CurrentBar, true, 0, High[0] + TickSize * 5, Brushes.Red);
                    }
                }
            }

            // Check swing lows for bullish divergence
            if (lastSwingLowAgo > 0 && lastSwingLowAgo <= CurrentBar && lastSwingLowAgo > ConfirmationBars)
            {
                double lastPriceLow    = Low[lastSwingLowAgo];
                double currentPriceLow = Low[0];
                double lastDeltaLow    = smoothedDelta[lastSwingLowAgo];
                double currentDeltaLow = smoothedDelta[0];

                double priceDiff = lastPriceLow - currentPriceLow;
                double deltaDiff = currentDeltaLow - lastDeltaLow;

                if (Math.Abs(priceDiff) > 1e-10)
                {
                    double normalizedDeltaDiff = deltaDiff / Math.Abs(priceDiff);

                    bool confirmed = true;
                    for (int i = 0; i < ConfirmationBars; i++)
                    {
                        double tempPriceDiff = lastPriceLow - Low[i];
                        double tempDeltaDiff = smoothedDelta[i] - lastDeltaLow;
                        if (Math.Abs(tempPriceDiff) > 1e-10)
                        {
                            double tempNormalizedDeltaDiff = tempDeltaDiff / Math.Abs(tempPriceDiff);
                            // Bullish condition: Price lower but delta higher
                            if (!(Low[i] < lastPriceLow && tempNormalizedDeltaDiff > adaptiveThreshold))
                            {
                                confirmed = false;
                                break;
                            }
                        }
                        else
                        {
                            confirmed = false;
                            break;
                        }
                    }

                    if (confirmed && currentPriceLow < lastPriceLow && normalizedDeltaDiff > adaptiveThreshold)
                    {
                        Draw.ArrowUp(this, "BullDiv" + CurrentBar, true, 0, Low[0] - TickSize * 5, Brushes.Green);
                    }
                }
            }
        }
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private DeltaDivergenceZigZagWIP[] cacheDeltaDivergenceZigZagWIP;
		public DeltaDivergenceZigZagWIP DeltaDivergenceZigZagWIP(int deltaLookback, double thresholdFactor, int smoothingPeriod, int confirmationBars, double zigZagDeviationPercent)
		{
			return DeltaDivergenceZigZagWIP(Input, deltaLookback, thresholdFactor, smoothingPeriod, confirmationBars, zigZagDeviationPercent);
		}

		public DeltaDivergenceZigZagWIP DeltaDivergenceZigZagWIP(ISeries<double> input, int deltaLookback, double thresholdFactor, int smoothingPeriod, int confirmationBars, double zigZagDeviationPercent)
		{
			if (cacheDeltaDivergenceZigZagWIP != null)
				for (int idx = 0; idx < cacheDeltaDivergenceZigZagWIP.Length; idx++)
					if (cacheDeltaDivergenceZigZagWIP[idx] != null && cacheDeltaDivergenceZigZagWIP[idx].DeltaLookback == deltaLookback && cacheDeltaDivergenceZigZagWIP[idx].ThresholdFactor == thresholdFactor && cacheDeltaDivergenceZigZagWIP[idx].SmoothingPeriod == smoothingPeriod && cacheDeltaDivergenceZigZagWIP[idx].ConfirmationBars == confirmationBars && cacheDeltaDivergenceZigZagWIP[idx].ZigZagDeviationPercent == zigZagDeviationPercent && cacheDeltaDivergenceZigZagWIP[idx].EqualsInput(input))
						return cacheDeltaDivergenceZigZagWIP[idx];
			return CacheIndicator<DeltaDivergenceZigZagWIP>(new DeltaDivergenceZigZagWIP(){ DeltaLookback = deltaLookback, ThresholdFactor = thresholdFactor, SmoothingPeriod = smoothingPeriod, ConfirmationBars = confirmationBars, ZigZagDeviationPercent = zigZagDeviationPercent }, input, ref cacheDeltaDivergenceZigZagWIP);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.DeltaDivergenceZigZagWIP DeltaDivergenceZigZagWIP(int deltaLookback, double thresholdFactor, int smoothingPeriod, int confirmationBars, double zigZagDeviationPercent)
		{
			return indicator.DeltaDivergenceZigZagWIP(Input, deltaLookback, thresholdFactor, smoothingPeriod, confirmationBars, zigZagDeviationPercent);
		}

		public Indicators.DeltaDivergenceZigZagWIP DeltaDivergenceZigZagWIP(ISeries<double> input , int deltaLookback, double thresholdFactor, int smoothingPeriod, int confirmationBars, double zigZagDeviationPercent)
		{
			return indicator.DeltaDivergenceZigZagWIP(input, deltaLookback, thresholdFactor, smoothingPeriod, confirmationBars, zigZagDeviationPercent);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.DeltaDivergenceZigZagWIP DeltaDivergenceZigZagWIP(int deltaLookback, double thresholdFactor, int smoothingPeriod, int confirmationBars, double zigZagDeviationPercent)
		{
			return indicator.DeltaDivergenceZigZagWIP(Input, deltaLookback, thresholdFactor, smoothingPeriod, confirmationBars, zigZagDeviationPercent);
		}

		public Indicators.DeltaDivergenceZigZagWIP DeltaDivergenceZigZagWIP(ISeries<double> input , int deltaLookback, double thresholdFactor, int smoothingPeriod, int confirmationBars, double zigZagDeviationPercent)
		{
			return indicator.DeltaDivergenceZigZagWIP(input, deltaLookback, thresholdFactor, smoothingPeriod, confirmationBars, zigZagDeviationPercent);
		}
	}
}

#endregion


#########################

#region Using declarations
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds Indicators
namespace NinjaTrader.NinjaScript.Indicators
{
    public class FisherVolatilityRegimeIndicator : Indicator
    {
        // Series for price-based Fisher
        private Series<double> fishValue;
        private Series<double> fishValuePrev;
        private Series<double> priceSeries;

        // Series for volume-based Fisher
        private Series<double> fishVolValue;
        private Series<double> fishVolValuePrev;

        // ATR and related values
        private ATR atr;
        private double regimeThreshold;
        private double currentAtr;

        // Momentum (ROC)
        private Series<double> rocSeries;

        private double prevFish;
        private double prevFishValue;

        // Track last signals for spacing
        private int lastBuyBar = -1;
        private int lastSellBar = -1;

        [Range(2, int.MaxValue), NinjaScriptProperty]
        [Display(Name="FisherLength", Order=1, GroupName="Parameters")]
        public int FisherLength { get; set; }

        [Range(2, int.MaxValue), NinjaScriptProperty]
        [Display(Name="ATRPeriod", Order=2, GroupName="Parameters")]
        public int ATRPeriod { get; set; }

        [Range(1, int.MaxValue), NinjaScriptProperty]
        [Display(Name="MomentumPeriod", Order=3, GroupName="Parameters")]
        public int MomentumPeriod { get; set; }

        [Display(Name="ATRThresholdMultiplier", Order=4, GroupName="Parameters")]
        public double ATRThresholdMultiplier { get; set; }

        [Range(0.0, double.MaxValue), NinjaScriptProperty]
        [Display(Name="SmoothingFactor", Order=5, GroupName="Parameters")]
        public double SmoothingFactor { get; set; }

        [NinjaScriptProperty]
        [Display(Name="ShowArrows", Order=6, GroupName="Parameters")]
        public bool ShowArrows { get; set; }

        [Range(1, int.MaxValue), NinjaScriptProperty]
        [Display(Name="BarThreshold", Order=7, GroupName="Parameters")]
        public int BarThreshold { get; set; }

        // New parameter to toggle the BuySellSignalLine behavior
        [NinjaScriptProperty]
        [Display(Name="MimicAlphaSignalLine", Order=8, GroupName="Parameters")]
        public bool MimicAlphaSignalLine { get; set; }

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "FisherVolatilityRegimeIndicator";
                Description = "Combines Fisher Transform on price and volume, ATR volatility regime detection, and momentum to produce signals. Enforces a bar spacing rule on identical consecutive signals.";
                Calculate = Calculate.OnBarClose;
                IsOverlay = true;               
                DrawOnPricePanel = true;        
                DisplayInDataBox = true;
                PaintPriceMarkers = true;
                ScaleJustification = NinjaTrader.Gui.Chart.ScaleJustification.Right;
                IsSuspendedWhileInactive = true;

                FisherLength = 9;
                ATRPeriod = 14;
                MomentumPeriod = 10;
                ATRThresholdMultiplier = 1.5;
                SmoothingFactor = 0.2;
                ShowArrows = true;
                BarThreshold = 15;
                MimicAlphaSignalLine = false; // Default: original behavior

                AddPlot(Brushes.DodgerBlue, "AlphaSignalLine");
                AddPlot(Brushes.Green, "BuySellSignalLine");
                AddLine(Brushes.Gray, 0, "ZeroLine");
            }
            else if (State == State.Configure)
            {
                // Additional configuration if needed
            }
            else if (State == State.DataLoaded)
            {
                fishValue = new Series<double>(this);
                fishValuePrev = new Series<double>(this);
                priceSeries = new Series<double>(this);

                fishVolValue = new Series<double>(this);
                fishVolValuePrev = new Series<double>(this);

                rocSeries = new Series<double>(this);

                atr = ATR(ATRPeriod);
            }
        }

        protected override void OnBarUpdate()
        {
            // Ensure we have enough bars for calculations
            if (CurrentBar < Math.Max(FisherLength, Math.Max(ATRPeriod, MomentumPeriod)))
            {
                Value[0] = 0;     // AlphaSignalLine
                Values[1][0] = 0; // BuySellSignalLine
                return;
            }

            // Median price for price-based Fisher
            double medianPrice = (High[0] + Low[0]) / 2.0;
            priceSeries[0] = medianPrice;

            // Price-based Fisher calculation
            double maxH = MAX(High, FisherLength)[0];
            double minL = MIN(Low, FisherLength)[0];
            double val = 0.33 * 2 * ((medianPrice - minL)/(maxH - minL) - 0.5) + 0.67 * (fishValuePrev[1]);
            val = Math.Min(Math.Max(val, -0.999), 0.999);
            fishValue[0] = 0.5 * Math.Log((1+val)/(1-val)) + 0.5 * fishValue[1];
            fishValuePrev[0] = val;

            prevFish = fishValue[1];
            prevFishValue = fishValuePrev[1];

            // Volume-based Fisher
            double maxVolume = MAX(Volume, FisherLength)[0];
            double minVolume = MIN(Volume, FisherLength)[0];
            double volumeRange = maxVolume - minVolume;
            if (volumeRange == 0) volumeRange = 1; 
            double volVal = 0.33 * 2 * ((Volume[0] - minVolume)/volumeRange - 0.5) + 0.67 * (fishVolValuePrev[1]);
            volVal = Math.Min(Math.Max(volVal, -0.999), 0.999);
            fishVolValue[0] = 0.5 * Math.Log((1+volVal)/(1-volVal)) + 0.5 * fishVolValue[1];
            fishVolValuePrev[0] = volVal;

            // ATR Volatility Regime
            currentAtr = atr[0];
            double avgRange = (MAX(High, ATRPeriod)[0] - MIN(Low, ATRPeriod)[0]);
            regimeThreshold = avgRange * ATRThresholdMultiplier;
            bool highVolRegime = currentAtr > regimeThreshold;

            // Momentum (ROC)
            double momentum = (Close[0] - Close[MomentumPeriod]) / Close[MomentumPeriod] * 100;
            rocSeries[0] = momentum;

            // Determine raw signal conditions (same as original logic)
            bool fisherBullish = fishValue[0] > 0 && fishValue[0] > prevFish;
            bool fisherBearish = fishValue[0] < 0 && fishValue[0] < prevFish;
            bool fisherVolBullish = fishVolValue[0] > 0;
            bool fisherVolBearish = fishVolValue[0] < 0;
            bool momentumBullish = momentum > 0;
            bool momentumBearish = momentum < 0;

            double rawSignal = 0.0;
            int preliminarySignal = 0;

            if (highVolRegime)
            {
                if (fisherBullish && fisherVolBullish && momentumBullish)
                {
                    rawSignal = 1.0;
                    preliminarySignal = 1; // Buy attempt
                }
                else if (fisherBearish && fisherVolBearish && momentumBearish)
                {
                    rawSignal = -1.0;
                    preliminarySignal = -1; // Sell attempt
                }
            }
            else
            {
                // Low volatility, more conservative
                if (fisherBullish && fisherVolBullish && momentumBullish)
                {
                    rawSignal = 0.7;
                    preliminarySignal = 1; // Buy attempt
                }
                else if (fisherBearish && fisherVolBearish && momentumBearish)
                {
                    rawSignal = -0.7;
                    preliminarySignal = -1; // Sell attempt
                }
            }

            // AlphaSignalLine calculation (same as original)
            double prevValue = (CurrentBar > 0) ? Value[0] : 0.0;
            double smoothedValue = (SmoothingFactor > 0) 
                ? (prevValue + SmoothingFactor*(rawSignal - prevValue)) 
                : rawSignal;

            Value[0] = smoothedValue; // AlphaSignalLine

            int buySellSignal = preliminarySignal;

            // If not mimicking AlphaSignalLine, use original BarThreshold logic
            if (!MimicAlphaSignalLine)
            {
                if (buySellSignal == 1)
                {
                    // Check if too soon for another buy
                    if (lastBuyBar != -1 && (CurrentBar - lastBuyBar < BarThreshold))
                        buySellSignal = 0;
                    else
                        lastBuyBar = CurrentBar;
                }
                else if (buySellSignal == -1)
                {
                    // Check if too soon for another sell
                    if (lastSellBar != -1 && (CurrentBar - lastSellBar < BarThreshold))
                        buySellSignal = 0;
                    else
                        lastSellBar = CurrentBar;
                }
            }
            else
            {
                // MimicAlphaSignalLine = true:
                // BuySellSignalLine continuously mimics AlphaSignalLine direction.
                // If AlphaSignalLine > 0 => 1; < 0 => -1; =0 => 0
                double alpha = Value[0];
                if (alpha > 0)
                    buySellSignal = 1;
                else if (alpha < 0)
                    buySellSignal = -1;
                else
                    buySellSignal = 0;
            }

            Values[1][0] = buySellSignal; // BuySellSignalLine

            // Draw arrows if enabled and a valid signal occurred (original logic)
            if (ShowArrows && buySellSignal != 0)
            {
                if (buySellSignal == 1)
                    Draw.ArrowUp(this, "BuySignal"+CurrentBar, false, 0, Low[0] - TickSize, Brushes.Green);
                else if (buySellSignal == -1)
                    Draw.ArrowDown(this, "SellSignal"+CurrentBar, false, 0, High[0] + TickSize, Brushes.Red);
            }
        }

        #region Properties
        [Browsable(false)]
        [XmlIgnore]
        public Series<double> AlphaSignalLine
        {
            get { return Values[0]; }
        }

        [Browsable(false)]
        [XmlIgnore]
        public Series<double> BuySellSignalLine
        {
            get { return Values[1]; }
        }
        #endregion
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private FisherVolatilityRegimeIndicator[] cacheFisherVolatilityRegimeIndicator;
		public FisherVolatilityRegimeIndicator FisherVolatilityRegimeIndicator(int fisherLength, int aTRPeriod, int momentumPeriod, double smoothingFactor, bool showArrows, int barThreshold, bool mimicAlphaSignalLine)
		{
			return FisherVolatilityRegimeIndicator(Input, fisherLength, aTRPeriod, momentumPeriod, smoothingFactor, showArrows, barThreshold, mimicAlphaSignalLine);
		}

		public FisherVolatilityRegimeIndicator FisherVolatilityRegimeIndicator(ISeries<double> input, int fisherLength, int aTRPeriod, int momentumPeriod, double smoothingFactor, bool showArrows, int barThreshold, bool mimicAlphaSignalLine)
		{
			if (cacheFisherVolatilityRegimeIndicator != null)
				for (int idx = 0; idx < cacheFisherVolatilityRegimeIndicator.Length; idx++)
					if (cacheFisherVolatilityRegimeIndicator[idx] != null && cacheFisherVolatilityRegimeIndicator[idx].FisherLength == fisherLength && cacheFisherVolatilityRegimeIndicator[idx].ATRPeriod == aTRPeriod && cacheFisherVolatilityRegimeIndicator[idx].MomentumPeriod == momentumPeriod && cacheFisherVolatilityRegimeIndicator[idx].SmoothingFactor == smoothingFactor && cacheFisherVolatilityRegimeIndicator[idx].ShowArrows == showArrows && cacheFisherVolatilityRegimeIndicator[idx].BarThreshold == barThreshold && cacheFisherVolatilityRegimeIndicator[idx].MimicAlphaSignalLine == mimicAlphaSignalLine && cacheFisherVolatilityRegimeIndicator[idx].EqualsInput(input))
						return cacheFisherVolatilityRegimeIndicator[idx];
			return CacheIndicator<FisherVolatilityRegimeIndicator>(new FisherVolatilityRegimeIndicator(){ FisherLength = fisherLength, ATRPeriod = aTRPeriod, MomentumPeriod = momentumPeriod, SmoothingFactor = smoothingFactor, ShowArrows = showArrows, BarThreshold = barThreshold, MimicAlphaSignalLine = mimicAlphaSignalLine }, input, ref cacheFisherVolatilityRegimeIndicator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.FisherVolatilityRegimeIndicator FisherVolatilityRegimeIndicator(int fisherLength, int aTRPeriod, int momentumPeriod, double smoothingFactor, bool showArrows, int barThreshold, bool mimicAlphaSignalLine)
		{
			return indicator.FisherVolatilityRegimeIndicator(Input, fisherLength, aTRPeriod, momentumPeriod, smoothingFactor, showArrows, barThreshold, mimicAlphaSignalLine);
		}

		public Indicators.FisherVolatilityRegimeIndicator FisherVolatilityRegimeIndicator(ISeries<double> input , int fisherLength, int aTRPeriod, int momentumPeriod, double smoothingFactor, bool showArrows, int barThreshold, bool mimicAlphaSignalLine)
		{
			return indicator.FisherVolatilityRegimeIndicator(input, fisherLength, aTRPeriod, momentumPeriod, smoothingFactor, showArrows, barThreshold, mimicAlphaSignalLine);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.FisherVolatilityRegimeIndicator FisherVolatilityRegimeIndicator(int fisherLength, int aTRPeriod, int momentumPeriod, double smoothingFactor, bool showArrows, int barThreshold, bool mimicAlphaSignalLine)
		{
			return indicator.FisherVolatilityRegimeIndicator(Input, fisherLength, aTRPeriod, momentumPeriod, smoothingFactor, showArrows, barThreshold, mimicAlphaSignalLine);
		}

		public Indicators.FisherVolatilityRegimeIndicator FisherVolatilityRegimeIndicator(ISeries<double> input , int fisherLength, int aTRPeriod, int momentumPeriod, double smoothingFactor, bool showArrows, int barThreshold, bool mimicAlphaSignalLine)
		{
			return indicator.FisherVolatilityRegimeIndicator(input, fisherLength, aTRPeriod, momentumPeriod, smoothingFactor, showArrows, barThreshold, mimicAlphaSignalLine);
		}
	}
}

#endregion


#########################

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Media;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
using System.Xml.Linq;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Core;
using NinjaTrader.Custom;
using NinjaTrader.Data;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.NinjaScript.AtmStrategy;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX;
using SharpDX.Direct2D1;
using System.Diagnostics;

namespace NinjaTrader.NinjaScript.Indicators
{
	public class HFT_Slayer : Indicator
	{
		NinjaTrader.Gui.Tools.SimpleFont title = 
		new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 20, Bold = true };
		NinjaTrader.Gui.Tools.SimpleFont title2 = 
		new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 15, Bold = true };
		NinjaTrader.Gui.Tools.SimpleFont TextFont = 
		new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 15, Bold = false };
		
		NinjaTrader.Gui.Tools.SimpleFont Stitle = 
		new NinjaTrader.Gui.Tools.SimpleFont("Slaytanic", 16) { Size = 30, Bold = true };
		
		double realizedPnL = 0;
		double TriggerBar1 = 0;
		double BarsSince1 = 0;
		double TriggerBar2 = 0;
		double BarsSince2 = 0;
		bool sigLock1 = false;
		bool sigLock2 = false;
		bool playOnce = false;
		bool isReversed = false;
		string version = "V1";
		
		bool alertLock1A = false;
		bool alertLock2A = false;
		int TriggerBar1A = 0;
		int TriggerBar2A = 0;
		bool under20 = false;
		bool over80 = false;
		
		
		private SimpleFont textFont = new SimpleFont("Arial", 10)
		{
			Bold = true
		};
		
		#region Box Vars
		private Border moveB;
		private Border hideB;
		private Border tileHolder;
		private Grid grid;
		private Thickness margin;
		private bool subscribedToSize;
		private System.Windows.Point startPoint;
		private Button ARMLONGbtn;
		private Button ARMSHORTbtn;
		private Button ARMOPTIONbtn;
		private Button Closebtn;
		private Button AUTOArmbtn;
		private Button resetQuantVal;
		private Button increaseQuant;
		private Button decreaseQuant;
		private Label ATMLabel;
		private Label ACCOUNTLabel;
		private Label selectedATMStrat;
		private Label accountSelected;
		private Label quantityLabel;
		private TextBox quantityLabelVal;
		private ComboBox combo;
		private bool armLongBtnToggle;
		private bool armShortBtnToggle;
		private bool armOptionBtnToggle;
		private bool autoArmBtnToggle;
		private int quantityValue = 1;
		private int quantityATM = 1;
		private bool closeRunning;
		private bool handlerSet;
		private Chart chartWindow;
		private Grid chartTraderGrid;
		private Grid chartTraderButtonsGrid;
		private Grid lowerButtonsGrid;
		private Grid upperButtonsGrid;
		private AtmStrategySelector atmSelector;
		private AccountSelector accountSelector;
		private bool connected;
		private Instrument inst;
		private bool onceTriggered;
		private bool inPosition;
		private int posDirection;
		private Account chartTraderAccount;
		private Position positions;
		private Timer _posTimer;
		private Timer _acctTimer;
		private FrameworkElement addedGrid;
		#endregion
		
		protected override void OnStateChange()
		{
			if (State == (State)1)
			{
				Description = "Custom Visualization for Strategy Execution Operations via HFT ALGO.";
				Name = "HFT_Slayer";
				Calculate = Calculate.OnEachTick;
				BarsRequiredToPlot = 100;
				IsOverlay = true;
				DisplayInDataBox = false;
				ShowTransparentPlotsInDataBox = true;
				DrawOnPricePanel = true;
				PaintPriceMarkers = false;
				IsSuspendedWhileInactive = false;
				this.SelectedTypes = new XElement("SelectedTypes");
				ArePlotsConfigurable = false;
				AreLinesConfigurable = false;
				this.Left = 5.0;
				this.Top = -1.0;
				this.NumberOfRows = 5;
				realizedProfit = 0;
				realizedLoss = 0;
				startTime = 073000;
				endTime = 120000;
				econNumber1 = 074500;
				econNumber2 = 080000;
				openTime = 0;
				tLine = 15;
				sLine = 30;
				return;
			}
			if (State == State.DataLoaded)
			{
				///Keyboard hot key listner
				ChartControl.Dispatcher.InvokeAsync(() =>
					{
						ChartControl.KeyDown += new System.Windows.Input.KeyEventHandler(ChartControl_KeyDown);
					});
			}
			if (State != (State)2)
			{
				if (State == (State)4)
				{
					try
					{
						Draw.TextFixed(this, "hftName", "HFT "+Instrument.MasterInstrument.Name.ToString()+" SLAYER", TextPosition.TopRight, Brushes.Crimson, Stitle, Brushes.Black,Brushes.Black,100);
					}
					catch
					{
						Draw.TextFixed(this, "hftName", "HFT "+Instrument.MasterInstrument.Name.ToString()+" SLAYER", TextPosition.TopRight, Brushes.Crimson, title, Brushes.Black,Brushes.Black,100);
					}
					
					#region Control Panel
					
					try
					{
						Dispatcher.InvokeAsync(delegate()
						{
							QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
							this.quantityATM = quantityUpDown.Value;
						});
					}
					catch (Exception)
					{
					}
					try
					{
						if (ChartControl != null)
						{
							if (this.Top < 0.0)
							{
								this.Top = 25.0;
							}
							Dispatcher.Invoke(delegate()
							{
								this.addedGrid = this.CreateControl();
								UserControlCollection.Add(this.addedGrid);
							});
						}
						return;
					}
					catch (Exception)
					{
						return;
					}
					#endregion
				}
				if (State == (State)8)
				{
					if (ChartControl != null)
					{
						ChartControl.Dispatcher.InvokeAsync(() =>
						{
							ChartControl.KeyDown -= ChartControl_KeyDown;
						});
					}
					#region Control Panel
					this.grid = null;
					this.tileHolder = null;
					this.moveB = null;
					this.hideB = null;
					Dispatcher.Invoke(delegate()
					{
						UserControlCollection.Remove(this.addedGrid);
						this.addedGrid = null;
					});
					try
					{
						if (this._posTimer != null)
						{
							this._posTimer.Change(-1, 0);
							this._posTimer.Dispose();
						}
						if (this._acctTimer != null)
						{
							this._acctTimer.Change(-1, 0);
							this._acctTimer.Dispose();
						}
						if (this.addedGrid != null)
						{
							UserControlCollection.Remove(this.addedGrid);
							this.addedGrid = null;
						}
						if (this.moveB != null)
						{
							this.moveB = null;
						}
						if (this.hideB != null)
						{
							this.hideB = null;
						}
						if (this.grid != null)
						{
							this.grid = null;
						}
						if (this.tileHolder != null)
						{
							this.tileHolder = null;
						}
						if (this.ARMLONGbtn != null)
						{
							this.ARMLONGbtn.Click -= this.ARMLONGbtn_Click;
							this.ARMLONGbtn = null;
						}
						if (this.ARMSHORTbtn != null)
						{
							this.ARMSHORTbtn.Click -= this.ARMSHORTbtn_Click;
							this.ARMSHORTbtn = null;
						}
						if (this.ARMOPTIONbtn != null)
						{
							this.ARMOPTIONbtn.Click -= this.ARMOPTIONbtn_Click;
							this.ARMOPTIONbtn = null;
						}
						if (this.Closebtn != null)
						{
							this.Closebtn.Click -= this.Closebtn_Click;
							this.Closebtn = null;
						}
						if (this.AUTOArmbtn != null)
						{
							this.AUTOArmbtn.Click -= this.AUTOArmbtn_Click;
							this.AUTOArmbtn = null;
						}
						if (this.resetQuantVal != null)
						{
							this.resetQuantVal.Click -= new RoutedEventHandler(this.resetQuantVal_Click);
							this.resetQuantVal = null;
						}
						if (this.increaseQuant != null)
						{
							this.increaseQuant.Click -= new RoutedEventHandler(this.increaseQuant_Click);
							this.increaseQuant = null;
						}
						if (this.decreaseQuant != null)
						{
							this.decreaseQuant.Click -= new RoutedEventHandler(this.decreaseQuant_Click);
							this.decreaseQuant = null;
						}
						if (this.atmSelector != null)
						{
							this.atmSelector.SelectionChanged -= new SelectionChangedEventHandler(this.ATMSelection_Changed);
							this.atmSelector = null;
						}
						if (this.quantityLabelVal != null)
						{
							this.quantityLabelVal.PreviewKeyDown -= this.TextBox_PreviewKeyDown;
							this.quantityLabelVal = null;
						}
						if (this.accountSelector != null)
						{
							this.accountSelector.SelectionChanged -= new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
							this.accountSelector = null;
						}
					}
					catch (Exception)
					{
					}
					#endregion
				}
				return;
			}
		}

		protected override void OnBarUpdate()
		{
			try
			{
				if (!this.subscribedToSize && ChartPanel != null)
				{
					this.subscribedToSize = true;
					ChartPanel.SizeChanged += delegate(object sender, SizeChangedEventArgs e)
					{
						if (this.grid != null && ChartPanel != null)
						{
							if (this.grid.Margin.Left + this.grid.ActualWidth > ChartPanel.ActualWidth || this.grid.Margin.Top + this.grid.ActualHeight > ChartPanel.ActualHeight)
							{
								double left = Math.Max(0.0, Math.Min(this.grid.Margin.Left, ChartPanel.ActualWidth - this.grid.ActualWidth));
								double top = Math.Max(0.0, Math.Min(this.grid.Margin.Top, ChartPanel.ActualHeight - this.grid.ActualHeight));
								this.grid.Margin = new Thickness(left, top, 0.0, 0.0);
								this.Left = left;
								this.Top = top;
							}
							return;
						}
					};
				}
				try
				{
					if(AccountName != null)
					{
						try
						{
							Account myPnL = null;
							lock (Account.All)
							{
								myPnL = Account.All.FirstOrDefault(a => a.Name == AccountName);
							}
							realizedPnL = myPnL.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar);
						}
						catch (Exception e)
						{
						}
					}
					Draw.TextFixed(this, "pnlstat", "\n\n"+"ACC PNL $"+realizedPnL.ToString("F2"), TextPosition.TopRight);
					if(realizedProfit != 0 && realizedPnL >= realizedProfit)
					{
						Draw.TextFixed(this, "PT STAT", "Stopped - Profit Target Reached"+ "   Realized P&L: "+ realizedPnL.ToString("F2"), TextPosition.Center, Brushes.LimeGreen, title, Brushes.Black,Brushes.Black,50);
						return;
					}
					if(realizedLoss !=0 && realizedPnL <= realizedLoss)
					{
						Draw.TextFixed(this, "SL STAT", "Stopped - Total Stop Loss Reached"+ "   Realized P&L: "+ realizedPnL.ToString("F2"), TextPosition.Center, Brushes.Red, title, Brushes.Black,Brushes.Black,50);
						return;
					}
					if(isReversed == false)
					{
						Draw.TextFixed(this, "Rev", "Normal"+"\n", TextPosition.BottomLeft, Brushes.LimeGreen, title2, Brushes.Transparent,Brushes.Black,0);
						Draw.TextFixed(this, "v", version.ToString(), TextPosition.BottomLeft);
					}
					if(isReversed == true)
					{
						Draw.TextFixed(this, "Rev", "Reversed"+"\n", TextPosition.BottomLeft, Brushes.LimeGreen, title2, Brushes.Transparent,Brushes.Black,0);
						Draw.TextFixed(this, "v", version.ToString(), TextPosition.BottomLeft);
					}
					
					/// Avoid Econ
					if(econNumber1 != 0 || econNumber2 != 0)
					{
						DateTime ecNumber = Time[0];
						ecNumber.AddMinutes(5);
						
						if((ToTime(Time[0]) >= econNumber1 - (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])) && ToTime(Time[0]) < econNumber1 + (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])))) // Trade Time
						{
							Draw.TextFixed(this, "Econ", "\n\n\n\n"+"No Trades Econ Data Release +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent,Brushes.Black,0);
							return;
						}
						else if((ToTime(Time[0]) >= econNumber2 - (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])) && ToTime(Time[0]) < econNumber2 + (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])))) // Trade Time
						{
							Draw.TextFixed(this, "Econ", "\n\n\n\n"+"No Trades Econ Data Release +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent,Brushes.Black,0);
							return;
						}
						else if((ToTime(Time[0]) >= openTime - (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])) && ToTime(Time[0]) < openTime + (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])))) // Trade Time
						{
							Draw.TextFixed(this, "Econ", "\n\n\n\n"+"No Trades During Market Open +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent,Brushes.Black,0);
							return;
						}
						else
						{
							Draw.TextFixed(this, "Econ", "\n\n\n\n"+"Skipping Econ @ "+econNumber1.ToString()+" and "+econNumber2.ToString(), TextPosition.TopRight, Brushes.LimeGreen, title2, Brushes.Transparent,Brushes.Black,0);
						}
					}
					///Trade Time
					if((ToTime(Time[0]) >= startTime && ToTime(Time[0]) < endTime))
					{
						Draw.TextFixed(this, "timeStat", "\n\n\n"+"Trade Time: Trading " +startTime.ToString() + " to " +endTime.ToString(), TextPosition.TopRight);
					}
					else if(startTime == 0 && endTime == 0)
					{
						Draw.TextFixed(this, "timeStat", "\n\n\n"+"Trade Time: Trading All Day", TextPosition.TopRight);
					}
					else
					{
						Draw.TextFixed(this, "timeStat", "\n\n\n"+"Trade Time: Not Trading", TextPosition.TopRight);
						return;
					}
					
				}
				catch
				{
				}
				try
				{	
					if (CurrentBars[0] < 20)
					{
						return;
					}
					if(State == State.Realtime && inPosition == false)
					{
						Draw.TextFixed(this, "pos", "\n\n\n\n\n"+"No Position", TextPosition.TopRight);
					}
					if(State == State.Realtime && inPosition == true)
					{
						Draw.TextFixed(this, "pos", "\n\n\n\n\n"+"In Position", TextPosition.TopRight);
					}
					if(CurrentBar > TriggerBar1)
					{
						BarsSince1 = CurrentBar - TriggerBar1;
						if(BarsSince1 >= 1 && IsFirstTickOfBar)
						{
							TriggerBar1 = 0;
							sigLock1 = false;
							playOnce = false;
						}
					}
					if(CurrentBar > TriggerBar2 )
					{
						BarsSince2 = CurrentBar - TriggerBar2;
						if(BarsSince2 >= 1 && IsFirstTickOfBar)
						{
							TriggerBar2 = 0;
							sigLock2 = false;
							playOnce = false;
						}
					}
					
					double stoc1 = StochasticsFast(3,9).D[0]; /// D = 3 K = 9
					double stoc2 = StochasticsFast(3,14).D[0]; /// D = 3 K = 14
					double stoc3 = StochasticsFast(4,40).D[0]; /// D = 4 K = 40
					double stoc4 = Stochastics(10,60,1).D[0];/// D = 10 K = 60 S = 1
					
					if(stoc1 < 20 && stoc2 < 20 && stoc3 < 20 && stoc4 < 20 && under20 == false && alertLock1A == false)
					{
						under20 = true;
						alertLock1A = true;
						TriggerBar1A = CurrentBar;
					}
					if(under20 == true && stoc1 >= 19.5)
					{
						under20 = false;
						Draw.Line(this, "Long Entry Line" + CurrentBar, false, 1, High[1], -1, High[1], Brushes.DeepSkyBlue, 0, 3);
						Draw.Text(this, "ArrowUP" + CurrentBar, false, "▲", 0, Low[0] - 4.0 * TickSize, 0, Brushes.LimeGreen, new SimpleFont("Arial", 20), TextAlignment.Center, Brushes.Transparent, Brushes.Transparent, 0);
						Draw.Line(this, "15 Target Line" + CurrentBar, false, 1, High[1] + tLine * TickSize, -1, High[1] + tLine * TickSize, Brushes.LimeGreen, 0, 2);
						Draw.Line(this, "30 Stop Line" + CurrentBar, false, 1, High[1] - sLine * TickSize, -1, High[1] - sLine * TickSize, Brushes.Red, 0, 2);
						if(sigLock1 == false && inPosition == false)
						{
							if(isReversed == false)
							{
								takeTrade(1);
							}
							if(isReversed == true)
							{
								takeTrade(-1);
							}
							sigLock1 = true;
							TriggerBar1 = CurrentBar;
						}
						
					}
					
					
					if(stoc1 > 80 && stoc2 > 80 && stoc3 > 80 && stoc4 > 80 && over80 == false && alertLock2A == false)
					{
						over80 = true;
						alertLock2A = true;
						TriggerBar2A = CurrentBar;
					}
						if(over80 == true && stoc1 <= 80.5)
						{
							over80 = false;
							Draw.Line(this, "Short Entry Line" + CurrentBar, false, 1, Low[1], -1, Low[1], Brushes.Magenta, 0, 3);
							Draw.Text(this, "ArrowDN1" + CurrentBar, false, "▼", 0, High[0] + 4.0 * TickSize, 0, Brushes.Red, new SimpleFont("Arial", 20), TextAlignment.Center, Brushes.Transparent, Brushes.Transparent, 0);
							Draw.Line(this, "15 Target Line" + CurrentBar, false, 1, Low[1] - tLine * TickSize, -1, Low[1] - tLine * TickSize, Brushes.LimeGreen, 0, 2);
							Draw.Line(this, "30 Stop Line" + CurrentBar, false, 1, Low[1] + sLine * TickSize, -1, Low[1] + sLine * TickSize, Brushes.Red, 0, 2);
							if(sigLock2 == false && inPosition == false)
							{
								if(isReversed == false)
								{
									takeTrade(-1);
								}
								if(isReversed == true)
								{
									takeTrade(1);
								}
								sigLock2 = true;
			  					TriggerBar2 = CurrentBar;
							}
						}
					
					
					double BarsSince1A = CurrentBar - TriggerBar1A;
					if(BarsSince1A >= 2 && alertLock1A == true)
					{
						alertLock1A = false;
						TriggerBar1A = 0;
					}
					double BarsSince2A = CurrentBar - TriggerBar2A;
					if(BarsSince2A >= 2 && alertLock2A == true)
					{
						alertLock2A = false;
						TriggerBar2A = 0;
					}
				}
				catch (Exception)
				{
				}
				
				
			}
			catch (Exception)
			{
			}
		}
		
		private void ChartControl_KeyDown(object sender, KeyEventArgs e)
		{
		    if(((Keyboard.Modifiers & ModifierKeys.Control) != 0) && Keyboard.IsKeyDown(Key.NumPad0) )
		    {
				if(isReversed == false)
				{
					isReversed = true;
					Print("Reversed");
					return;
				}
				if(isReversed == true)
				{
					isReversed = false;
					Print("Normal");
					return;
				}
		    }
		}

		private FrameworkElement CreateControl()
		{
			try
			{
				this.chartWindow = (Window.GetWindow(ChartControl.Parent) as Chart);
				this.chartTraderGrid = ((Extensions.FindFirst(this.chartWindow, "ChartWindowChartTraderControl") as ChartTrader).Content as Grid);
				if (this.chartTraderGrid != null)
				{
					try
					{
						this.chartTraderButtonsGrid = (this.chartTraderGrid.Children[0] as Grid);
						if (this.chartTraderButtonsGrid != null)
						{
							Grid grid = (Grid)this.chartTraderGrid.Children[2];
							if (grid != null)
							{
								this.atmSelector = (AtmStrategySelector)grid.Children[1];
								this.atmSelector.SelectionChanged += new SelectionChangedEventHandler(this.ATMSelection_Changed);
							}
							Grid grid2 = (Grid)this.chartTraderGrid.Children[1];
							if (grid2 != null)
							{
								ChartControl.Dispatcher.Invoke(delegate()
								{
									AccountSelector accountSelector = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlAccountSelector") as AccountSelector;
									this.chartTraderAccount = ((accountSelector != null) ? accountSelector.SelectedAccount : null);
									this.accountSelector = ((accountSelector != null) ? accountSelector : null);
								});
								if (this.accountSelector != null && !this.handlerSet)
								{
									this.handlerSet = true;
									this.accountSelector.SelectionChanged += new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
								}
								this.combo = (ComboBox)grid2.Children[4];
								foreach (Instrument instrument in Instrument.All)
								{
									if (instrument.FullName == this.combo.SelectedValue.ToString())
									{
										this.inst = instrument;
									}
								}
							}
						}
						
					}
					catch (Exception)
					{
						
					}
				}
				this._posTimer = new Timer(new TimerCallback(this.posCallback), null, 0, 200);
				this._acctTimer = new Timer(new TimerCallback(this.acctCallback), null, 0, 200);
				if (this.grid != null)
				{
					return this.grid;
				}
				this.grid = new Grid
				{
					VerticalAlignment = VerticalAlignment.Top,
					HorizontalAlignment = HorizontalAlignment.Left,
					Margin = new Thickness(this.Left, this.Top, 0.0, 0.0),
				};
				this.grid.ColumnDefinitions.Add(new ColumnDefinition
				{
					Width = default(GridLength)
				});
				this.grid.ColumnDefinitions.Add(new ColumnDefinition
				{
					Width = default(GridLength)
				});
				this.grid.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				System.Windows.Media.Brush background = (Application.Current.FindResource("BackgroundMainWindow") as System.Windows.Media.Brush) ?? Brushes.White;
				System.Windows.Media.Brush borderBrush = (Application.Current.FindResource("BorderThinBrush") as System.Windows.Media.Brush) ?? Brushes.Black;
				Grid grid3 = new Grid();
				grid3.RowDefinitions.Add(new RowDefinition
				{
					Height = new GridLength(2.0, GridUnitType.Star)
				});
				grid3.RowDefinitions.Add(new RowDefinition
				{
					Height = new GridLength(1.0, GridUnitType.Star)
				});
				grid3.RowDefinitions.Add(new RowDefinition
				{
					Height = new GridLength(2.0, GridUnitType.Star)
				});
				Grid grid4 = new Grid();
				grid4.RowDefinitions.Add(new RowDefinition
				{
					Height = new GridLength(3.0, GridUnitType.Star)
				});
				for (int i = 0; i < grid3.RowDefinitions.Count; i++)
				{
					System.Windows.Shapes.Ellipse element = new System.Windows.Shapes.Ellipse
					{
						Width = 4.0,
						Height = 4.0,
						HorizontalAlignment = HorizontalAlignment.Center,
						VerticalAlignment = VerticalAlignment.Center,
						Fill = Brushes.White
					};
					Grid.SetRow(element, i);
					grid3.Children.Add(element);
				}
				System.Windows.Shapes.Polygon element2 = new System.Windows.Shapes.Polygon
				{
					Width = 12.0,
					Height = 12.0,
					HorizontalAlignment = HorizontalAlignment.Center,
					VerticalAlignment = VerticalAlignment.Center,
					Fill = Brushes.Crimson,
					Points = new PointCollection
					{
						new System.Windows.Point(1.0, 5.0),
						new System.Windows.Point(8.0, 10.0),
						new System.Windows.Point(8.0, 0.0)
					}
				};
				Grid.SetRow(element2, 0);
				grid4.Children.Add(element2);
				this.moveB = new Border
				{
					VerticalAlignment = VerticalAlignment.Top,
					BorderThickness = new Thickness(0.0, 1.0, 1.0, 1.0),
					BorderBrush = borderBrush,
					Background = background,
					Width = 12.0,
					Height = 24.0,
					Cursor = Cursors.Hand,
					Child = grid3
				};
				this.hideB = new Border
				{
					VerticalAlignment = VerticalAlignment.Bottom,
					BorderThickness = new Thickness(0.0, 1.0, 1.0, 1.0),
					BorderBrush = borderBrush,
					Background = background,
					Width = 14.0,
					Height = 24.0,
					Cursor = Cursors.Hand,
					Child = grid4
				};
				 this.moveB.MouseDown += (MouseButtonEventHandler) ((sender, e) =>
		        {
		          this.startPoint = e.GetPosition((IInputElement) this.ChartPanel);
		          this.margin = this.grid.Margin;
		          if (e.ClickCount > 1)
		          {
		            this.moveB.ReleaseMouseCapture();
		            this.ChartControl.OnIndicatorsHotKey((object) this, (KeyEventArgs) null);
		          }
		          else
		            this.moveB.CaptureMouse();
		        });
				this.moveB.MouseUp += delegate(object sender, MouseButtonEventArgs e)
				{
					this.moveB.ReleaseMouseCapture();
				};
				this.moveB.MouseMove += delegate(object sender, MouseEventArgs e)
				{
					if (this.moveB.IsMouseCaptured && this.grid != null && ChartPanel != null)
					{
						System.Windows.Point position = e.GetPosition(ChartPanel);
						this.grid.Margin = new Thickness
						{
							Left = Math.Max(0.0, Math.Min(this.margin.Left + (position.X - this.startPoint.X), ChartPanel.ActualWidth - this.grid.ActualWidth)),
							Top = Math.Max(0.0, Math.Min(this.margin.Top + (position.Y - this.startPoint.Y), ChartPanel.ActualHeight - this.grid.ActualHeight))
						};
						this.Left = this.grid.Margin.Left;
						this.Top = this.grid.Margin.Top;
						return;
					}
				};
				Grid.SetColumn(this.moveB, 1);
				Grid.SetColumn(this.hideB, 2);
				this.grid.Children.Add(this.moveB);
				Grid grid5 = new Grid();
				grid5.Background = Brushes.Black; /// main
				grid5.ColumnDefinitions.Add(new ColumnDefinition
				{
					Width = default(GridLength)
				});
				grid5.ColumnDefinitions.Add(new ColumnDefinition
				{
					Width = default(GridLength)
				});
				grid5.ColumnDefinitions.Add(new ColumnDefinition
				{
					Width = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				Style style = Application.Current.FindResource("BasicEntryButton") as Style;
				Border border = new Border
				{
					Background = Brushes.Black,
					VerticalAlignment = VerticalAlignment.Stretch,
					HorizontalAlignment = HorizontalAlignment.Stretch
				};
				Label label = new Label
				{
					Content = string.Format("HFT "+Instrument.MasterInstrument.Name.ToString()+" SLAYER", 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center,
					FontSize = 14.0
				};
				label.Foreground = Brushes.Crimson;
				label.Background = Brushes.Black;
				label.BorderBrush = Brushes.Transparent;
				label.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(label, 3);
				border.Child = label;
				Grid.SetRow(border, 0);
				Grid.SetColumnSpan(border, 3);
				grid5.Children.Add(border);
				this.ATMLabel = new Label
				{
					Content = string.Format("ATM Strategy: ", 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.ATMLabel.Foreground = Brushes.White;
				this.ATMLabel.Background = Brushes.Transparent;
				this.ATMLabel.BorderBrush = Brushes.Transparent;
				this.ATMLabel.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(this.ATMLabel, 1);
				Grid.SetRow(this.ATMLabel, 1);
				grid5.Children.Add(this.ATMLabel);
				string format = string.Empty;
				if (this.atmSelector != null)
				{
					try
					{
						format = this.atmSelector.SelectedAtmStrategy.DisplayName;
					}
					catch (Exception)
					{
						format = "None";
					}
				}
				this.selectedATMStrat = new Label
				{
					Content = string.Format(format, 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.selectedATMStrat.Foreground = Brushes.White;
				this.selectedATMStrat.Background = Brushes.Transparent;
				this.selectedATMStrat.BorderBrush = Brushes.Transparent;
				this.selectedATMStrat.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(this.selectedATMStrat, 2);
				Grid.SetColumn(this.selectedATMStrat, 1);
				Grid.SetRow(this.selectedATMStrat, 1);
				grid5.Children.Add(this.selectedATMStrat);
				this.ACCOUNTLabel = new Label
				{
					Content = string.Format("Acc: ", 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.ACCOUNTLabel.Foreground = Brushes.White;
				this.ACCOUNTLabel.Background = Brushes.Transparent;
				this.ACCOUNTLabel.BorderBrush = Brushes.Transparent;
				this.ACCOUNTLabel.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(this.ACCOUNTLabel, 1);
				Grid.SetRow(this.ACCOUNTLabel, 2);
				grid5.Children.Add(this.ACCOUNTLabel);
				string format2 = string.Empty;
				lock (Connection.Connections)
				{
					foreach (Connection connection in Connection.Connections)
					{
						if (connection.Status == (ConnectionStatus)3)
						{
							this.connected = true;
							break;
						}
					}
				}
				if (!this.connected)
				{
					format2 = "Disconnected";
				}
				else
				{
					try
					{
						if (this.accountSelector.SelectedIndex.ToString() == string.Empty || this.accountSelector.SelectedAccount.Name == string.Empty || this.accountSelector.SelectedAccount.Name == null || this.accountSelector == null)
						{
							format2 = "Select Account";
						}
						format2 = NinjaTrader.NinjaScript.Indicators.HFT_Slayer.CensorString(this.accountSelector.SelectedAccount.DisplayName);
					}
					catch (Exception)
					{
						format2 = "Select Account";
					}
				}
				this.accountSelected = new Label
				{
					Content = string.Format(format2, 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.accountSelected.Foreground = Brushes.White;
				this.accountSelected.Background = Brushes.Transparent;
				this.accountSelected.BorderBrush = Brushes.Transparent;
				this.accountSelected.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(this.accountSelected, 2);
				Grid.SetColumn(this.accountSelected, 1);
				Grid.SetRow(this.accountSelected, 2);
				grid5.Children.Add(this.accountSelected);
				this.quantityLabel = new Label
				{
					Content = string.Format("QTY", 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.quantityLabel.Foreground = Brushes.White;
				this.quantityLabel.Background = Brushes.Transparent;
				this.quantityLabel.BorderBrush = Brushes.Transparent;
				this.quantityLabel.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(this.quantityLabel, 3);
				Grid.SetRow(this.quantityLabel, 3);
				//grid5.Children.Add(this.quantityLabel);
				this.decreaseQuant = new Button
				{
					Content = string.Format("-", 1),
					Name = "decreaseQuantity",
					Height = 25.0,
					Width = 25.0,
					Margin = new Thickness(0.0, 0.0, 25.0, 0.0),
					Style = style
				};
				this.decreaseQuant.Background = Brushes.Red;
				this.decreaseQuant.BorderBrush = Brushes.DimGray;
				this.decreaseQuant.Foreground = Brushes.White;
				this.decreaseQuant.HorizontalAlignment = HorizontalAlignment.Right;
				this.decreaseQuant.Click += new RoutedEventHandler(this.decreaseQuant_Click);
				Grid.SetColumn(this.decreaseQuant, 0);
				Grid.SetRow(this.decreaseQuant, 4);
				//grid5.Children.Add(this.decreaseQuant);
				this.increaseQuant = new Button
				{
					Content = string.Format("+", 1),
					Name = "increaseQuantity",
					Height = 25.0,
					Width = 25.0,
					Margin = new Thickness(25.0, 0.0, 0.0, 0.0),
					Style = style
				};
				this.increaseQuant.Background = Brushes.Green;
				this.increaseQuant.BorderBrush = Brushes.DimGray;
				this.increaseQuant.Foreground = Brushes.White;
				this.increaseQuant.HorizontalAlignment = HorizontalAlignment.Left;
				this.increaseQuant.Click += new RoutedEventHandler(this.increaseQuant_Click);
				Grid.SetColumn(this.increaseQuant, 2);
				Grid.SetRow(this.increaseQuant, 4);
				//grid5.Children.Add(this.increaseQuant);
				this.quantityLabelVal = new TextBox
				{
					Text = string.Format(this.quantityValue.ToString(), 0),
					Height = 20.0,
					Width = 60.0,
					FontSize = 14.0,
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.quantityLabelVal.Foreground = Brushes.White;
				this.quantityLabelVal.Background = Brushes.Transparent;
				this.quantityLabelVal.BorderBrush = Brushes.Transparent;
				this.quantityLabelVal.HorizontalAlignment = HorizontalAlignment.Center;
				this.quantityLabelVal.VerticalAlignment = VerticalAlignment.Center;
				this.quantityLabelVal.TextAlignment = TextAlignment.Center;
				Grid.SetColumnSpan(this.quantityLabelVal, 3);
				Grid.SetRow(this.quantityLabelVal, 4);
				this.quantityLabelVal.PreviewKeyDown += this.TextBox_PreviewKeyDown;
				this.quantityLabelVal.LostFocus += new RoutedEventHandler(this.TextBox_LostFocus);
				this.quantityLabelVal.LostMouseCapture += new MouseEventHandler(this.TextBox_LostFocus);
				//grid5.Children.Add(this.quantityLabelVal);
				this.resetQuantVal = new Button
				{
					Content = string.Format("Normal", 1),
					Name = "resetQuantVal",
					Height = 20.0,
					Width = 60.0,
					FontSize = 12.0,
					Margin = new Thickness(0.0, 4.0, 0.0, 4.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 0.0),
					Style = style
				};
				this.resetQuantVal.Background = Brushes.Gray;
				this.resetQuantVal.BorderBrush = Brushes.DimGray;
				this.resetQuantVal.Foreground = Brushes.White;
				this.resetQuantVal.HorizontalAlignment = HorizontalAlignment.Center;
				this.resetQuantVal.Click += new RoutedEventHandler(this.resetQuantVal_Click);
				Grid.SetColumnSpan(this.resetQuantVal, 3);
				Grid.SetRow(this.resetQuantVal, 5);
				///grid5.Children.Add(this.resetQuantVal);
				this.ARMLONGbtn = new Button
				{
					Content = string.Format("Arm Long", 1),
					Name = "LongArmButton",
					Height = 30.0,
					Width = 125.0,
					Margin = new Thickness(4.0, 4.0, 0.0, 0.0),
					Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
					Style = style
				};
				this.ARMLONGbtn.Background = Brushes.Gray;
				this.ARMLONGbtn.BorderBrush = Brushes.DimGray;
				this.ARMLONGbtn.Foreground = Brushes.White;
				this.ARMLONGbtn.Click += this.ARMLONGbtn_Click;
				Grid.SetColumn(this.ARMLONGbtn, 0);
				Grid.SetRow(this.ARMLONGbtn, 6);
				grid5.Children.Add(this.ARMLONGbtn);
				this.ARMSHORTbtn = new Button
				{
					Content = string.Format("Arm Short", 1),
					Name = "ShortArmButton",
					Height = 30.0,
					Width = 125.0,
					Margin = new Thickness(0.0, 4.0, 4.0, 0.0),
					Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
					Style = style
				};
				this.ARMSHORTbtn.Background = Brushes.Gray;
				this.ARMSHORTbtn.BorderBrush = Brushes.DimGray;
				this.ARMSHORTbtn.Foreground = Brushes.White;
				this.ARMSHORTbtn.Click += this.ARMSHORTbtn_Click;
				Grid.SetColumn(this.ARMSHORTbtn, 2);
				Grid.SetRow(this.ARMSHORTbtn, 6);
				grid5.Children.Add(this.ARMSHORTbtn);
				this.ARMOPTIONbtn = new Button
				{
					Content = string.Format("Semi Auto", 1),
					Name = "ARMOptionButton",
					Height = 30.0,
					Width = 125.0,
					Margin = new Thickness(4.0, 4.0, 0.0, 0.0),
					Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
					Style = style
				};
				this.ARMOPTIONbtn.Background = Brushes.Gray;
				this.ARMOPTIONbtn.BorderBrush = Brushes.DimGray;
				this.ARMOPTIONbtn.Foreground = Brushes.White;
				this.ARMOPTIONbtn.Click += this.ARMOPTIONbtn_Click;
				Grid.SetColumn(this.ARMOPTIONbtn, 0);
				Grid.SetRow(this.ARMOPTIONbtn, 7);
				grid5.Children.Add(this.ARMOPTIONbtn);
				this.AUTOArmbtn = new Button
				{
					Content = string.Format("Full Auto", 1),
					Name = "Continuous",
					Height = 30.0,
					Width = 125.0,
					Margin = new Thickness(0.0, 4.0, 4.0, 0.0),
					Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
					Style = style
				};
				this.AUTOArmbtn.Background = Brushes.Gray;
				this.AUTOArmbtn.BorderBrush = Brushes.DimGray;
				this.AUTOArmbtn.Foreground = Brushes.White;
				this.AUTOArmbtn.Click += this.AUTOArmbtn_Click;
				Grid.SetColumn(this.AUTOArmbtn, 2);
				Grid.SetRow(this.AUTOArmbtn, 7);
				grid5.Children.Add(this.AUTOArmbtn);
				this.Closebtn = new Button
				{
					Content = string.Format("Flatten", 1),
					Name = "Flatten",
					Height = 30.0,
					Margin = new Thickness(4.0, 4.0, 4.0, 0.0),
					Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
					Style = style
				};
				this.Closebtn.Background = Brushes.Red;
				this.Closebtn.BorderBrush = Brushes.DimGray;
				this.Closebtn.Foreground = Brushes.White;
				this.Closebtn.Click += this.Closebtn_Click;
				this.Closebtn.PreviewMouseDown += new MouseButtonEventHandler(this.Closebtn_MouseDown);
				this.Closebtn.PreviewMouseUp += new MouseButtonEventHandler(this.Closebtn_MouseUp);
				this.Closebtn.MouseLeave += new MouseEventHandler(this.Closebtn_MouseLeave);
				Grid.SetColumnSpan(this.Closebtn, 3);
				Grid.SetRow(this.Closebtn, 9);
				grid5.Children.Add(this.Closebtn);
				this.tileHolder = new Border
				{
					Cursor = Cursors.Arrow,
					Background = (Application.Current.FindResource("BackgroundMainWindow") as System.Windows.Media.Brush),
					BorderThickness = new Thickness((double)(Application.Current.FindResource("BorderThinThickness") ?? 1)),
					BorderBrush = (Application.Current.FindResource("BorderThinBrush") as System.Windows.Media.Brush),
					Child = grid5
				};
				this.grid.Children.Add(this.tileHolder);
				this.hideB.MouseUp += delegate(object sender, MouseButtonEventArgs e)
				{
					if (this.ARMOPTIONbtn.Visibility == Visibility.Visible)
					{
						this.ARMOPTIONbtn.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.ARMOPTIONbtn.Visibility = Visibility.Visible;
					}
					if (this.ARMSHORTbtn.Visibility == Visibility.Visible)
					{
						this.ARMSHORTbtn.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.ARMSHORTbtn.Visibility = Visibility.Visible;
					}
					if (this.ARMLONGbtn.Visibility == Visibility.Visible)
					{
						this.ARMLONGbtn.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.ARMLONGbtn.Visibility = Visibility.Visible;
					}
					if (this.Closebtn.Visibility == Visibility.Visible)
					{
						this.Closebtn.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.Closebtn.Visibility = Visibility.Visible;
					}
					if (this.AUTOArmbtn.Visibility == Visibility.Visible)
					{
						this.AUTOArmbtn.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.AUTOArmbtn.Visibility = Visibility.Visible;
					}
					if (this.selectedATMStrat.Visibility == Visibility.Visible)
					{
						this.selectedATMStrat.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.selectedATMStrat.Visibility = Visibility.Visible;
					}
					if (this.ATMLabel.Visibility == Visibility.Visible)
					{
						this.ATMLabel.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.ATMLabel.Visibility = Visibility.Visible;
					}
					if (this.accountSelected.Visibility == Visibility.Visible)
					{
						this.accountSelected.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.accountSelected.Visibility = Visibility.Visible;
					}
					if (this.ACCOUNTLabel.Visibility == Visibility.Visible)
					{
						this.ACCOUNTLabel.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.ACCOUNTLabel.Visibility = Visibility.Visible;
					}
					if (this.quantityLabel.Visibility == Visibility.Visible)
					{
						this.quantityLabel.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.quantityLabel.Visibility = Visibility.Visible;
					}
					if (this.quantityLabelVal.Visibility == Visibility.Visible)
					{
						this.quantityLabelVal.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.quantityLabelVal.Visibility = Visibility.Visible;
					}
					if (this.increaseQuant.Visibility == Visibility.Visible)
					{
						this.increaseQuant.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.increaseQuant.Visibility = Visibility.Visible;
					}
					if (this.decreaseQuant.Visibility == Visibility.Visible)
					{
						this.decreaseQuant.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.decreaseQuant.Visibility = Visibility.Visible;
					}
					if (this.moveB.Visibility == Visibility.Visible)
					{
						this.moveB.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.moveB.Visibility = Visibility.Visible;
					}
					if (this.resetQuantVal.Visibility == Visibility.Visible)
					{
						this.resetQuantVal.Visibility = Visibility.Collapsed;
						return;
					}
					this.resetQuantVal.Visibility = Visibility.Visible;
				};
				this.grid.Children.Add(this.hideB);
				if (this.IsVisibleOnlyFocused)
				{
					Binding binding = new Binding("IsActive")
					{
						Source = ChartControl.OwnerChart,
						Converter = (Application.Current.FindResource("BoolToVisConverter") as IValueConverter)
					};
					this.grid.SetBinding(UIElement.VisibilityProperty, binding);
					return this.grid;
				}
			}
			catch (Exception)
			{
			}
			return this.grid;
		}

		private static string CensorString(string input)
		{
			if (input != null && input.Length >= 3)
			{
				if (input.Length > 10)
				{
					input = input.Substring(0, Math.Min(input.Length, 10));
				}
				else
				{
					input = input.PadRight(10);
				}
				int count = input.Length - 2;
				string str = new string('*', count);
				return input.Substring(0, 2) + str;
			}
			return input;
		}

		private void resetQuantVal_Click(object sender, EventArgs e)
		{
			if(isReversed == false)
			{
				isReversed = true;
				Print("Reversed");
				resetQuantVal.Background = Brushes.Green;
				resetQuantVal.Foreground = Brushes.White;
				resetQuantVal.Content = "Trend";
				return;
			}
			if(isReversed == true)
			{
				isReversed = false;
				Print("Normal");
				resetQuantVal.Background = Brushes.Gray;
				resetQuantVal.Foreground = Brushes.White;
				resetQuantVal.Content = "Normal";
				return;
			}
			/*int num = 1;
			this.quantityLabelVal.Text = num.ToString();
			this.quantityValue = num;
			this.armOptionBtnToggle = false;
			this.ARMOPTIONbtn.Background = Brushes.Gray;
			this.ARMOPTIONbtn.Foreground = Brushes.White;
			this.ARMOPTIONbtn.Content = "Semi Auto";
			this.autoArmBtnToggle = false;
			this.AUTOArmbtn.Background = Brushes.Gray;
			this.AUTOArmbtn.Foreground = Brushes.White;
			this.AUTOArmbtn.Content = "Full Auto";
			this.armShortBtnToggle = false;
			this.ARMSHORTbtn.Background = Brushes.Gray;
			this.ARMSHORTbtn.Foreground = Brushes.White;
			this.armLongBtnToggle = false;
			this.ARMLONGbtn.Background = Brushes.Gray;
			this.ARMLONGbtn.Foreground = Brushes.White;*/
		}

		private void increaseQuant_Click(object sender, EventArgs e)
		{
			int num;
			if ((num = this.quantityValue + 1) < 1)
			{
				num = 1;
			}
			else if (num > 50)
			{
				num = 50;
			}
			this.quantityLabelVal.Text = num.ToString();
			this.quantityValue = num;
		}

		private void decreaseQuant_Click(object sender, EventArgs e)
		{
			int num;
			if ((num = this.quantityValue - 1) < 1)
			{
				num = 1;
			}
			else if (num > 50)
			{
				num = 50;
			}
			this.quantityLabelVal.Text = num.ToString();
			this.quantityValue = num;
		}

		private void ACCOUNTSelection_Changed(object sender, EventArgs e)
		{
			bool flag = false;
			lock (Connection.Connections)
			{
				foreach (Connection connection in Connection.Connections)
				{
					if (connection.Status == (ConnectionStatus)3)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				this.accountSelected.Content = "Disconnected";
				return;
			}
			if (this.accountSelector != null)
			{
				if (this.accountSelector.SelectedIndex.ToString() == string.Empty || this.accountSelector.SelectedAccount.Name == string.Empty || this.accountSelector.SelectedAccount.Name == null || this.accountSelector == null)
				{
					this.accountSelected.Content = "Select Account";
				}
				this.accountSelected.Content = NinjaTrader.NinjaScript.Indicators.HFT_Slayer.CensorString(this.accountSelector.SelectedAccount.DisplayName);
			}
		}

		private void TextBox_PreviewKeyDown(object sender, KeyEventArgs e)
		{
			TextBox textBox = sender as TextBox;
			if (textBox != null)
			{
				if ((e.Key >= Key.D0 && e.Key <= Key.D9) || (e.Key >= Key.NumPad0 && e.Key <= Key.NumPad9))
				{
					int num = (e.Key >= Key.NumPad0) ? (e.Key - Key.NumPad0) : (e.Key - Key.D0);
					textBox.Text += num.ToString();
					e.Handled = true;
					return;
				}
				if (e.Key != Key.Back && e.Key != Key.Delete)
				{
					if (e.Key != Key.Tab)
					{
						if (e.Key == Key.Return)
						{
							textBox.Text = textBox.Text;
							this.quantityValue = int.Parse(textBox.Text);
							e.Handled = false;
							return;
						}
						e.Handled = true;
						return;
					}
				}
				e.Handled = false;
				return;
			}
		}

		private void TextBox_LostFocus(object sender, EventArgs e)
		{
			TextBox textBox = sender as TextBox;
			if (textBox != null)
			{
				textBox.Text = textBox.Text;
				this.quantityValue = int.Parse(textBox.Text);
			}
		}

		private void ATMSelection_Changed(object sender, EventArgs e)
		{
			if (this.selectedATMStrat == null || this.atmSelector.SelectedAtmStrategy == null)
			{
				this.selectedATMStrat.Content = "None";
				return;
			}
			if (!(this.atmSelector.SelectedItem.ToString() != "None"))
			{
				this.selectedATMStrat.Content = "None";
				return;
			}
			Dispatcher.InvokeAsync(delegate()
			{
				QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
				this.quantityATM = quantityUpDown.Value;
			});
			if (this.atmSelector.SelectedAtmStrategy.DisplayName.Contains("-"))
			{
				this.selectedATMStrat.Content = this.atmSelector.SelectedAtmStrategy.DisplayName;
				return;
			}
			this.selectedATMStrat.Content = this.atmSelector.SelectedAtmStrategy.DisplayName;
		}
		
		private void ARMLONGbtn_Click(object sender, RoutedEventArgs e)
		{
			if (!this.armLongBtnToggle)
			{
				this.armLongBtnToggle = true;
				this.onceTriggered = false;
				this.ARMLONGbtn.Background = Brushes.LimeGreen;
				this.ARMLONGbtn.Foreground = Brushes.Black;
				return;
			}
			this.armLongBtnToggle = false;
			this.ARMLONGbtn.Background = Brushes.Gray;
			this.ARMLONGbtn.Foreground = Brushes.White;
		}

		private void onceTriggeredARMLONGbtn()
		{
			this.armLongBtnToggle = false;
			this.ARMLONGbtn.Background = Brushes.Gray;
			this.ARMLONGbtn.Foreground = Brushes.White;
		}

		private void ARMSHORTbtn_Click(object sender, RoutedEventArgs e)
		{
			if (!this.armShortBtnToggle)
			{
				this.armShortBtnToggle = true;
				this.onceTriggered = false;
				this.ARMSHORTbtn.Background = Brushes.LimeGreen;
				this.ARMSHORTbtn.Foreground = Brushes.Black;
				return;
			}
			this.armShortBtnToggle = false;
			this.ARMSHORTbtn.Background = Brushes.Gray;
			this.ARMSHORTbtn.Foreground = Brushes.White;
		}

		private void potentialAUTOLong()
		{
			this.ARMLONGbtn.Background = Brushes.Yellow;
			this.ARMLONGbtn.Foreground = Brushes.Black;
		}

		private void potentialAUTOShort()
		{
			this.ARMSHORTbtn.Background = Brushes.Yellow;
			this.ARMSHORTbtn.Foreground = Brushes.Black;
		}

		private void onceTriggeredARMSHORTbtn()
		{
			this.armShortBtnToggle = false;
			this.ARMSHORTbtn.Background = Brushes.Gray;
			this.ARMSHORTbtn.Foreground = Brushes.White;
		}

		private void ARMOPTIONbtn_Click(object sender, RoutedEventArgs e)
		{
			if (!this.armOptionBtnToggle)
			{
				this.armOptionBtnToggle = true;
				this.ARMOPTIONbtn.Background = Brushes.DodgerBlue;
				this.ARMOPTIONbtn.Foreground = Brushes.White;
				this.ARMOPTIONbtn.Content = "Semi Auto - On";
				this.autoArmBtnToggle = false;
				this.AUTOArmbtn.Background = Brushes.Gray;
				this.AUTOArmbtn.Foreground = Brushes.White;
				this.AUTOArmbtn.Content = "Full Auto";
				return;
			}
			this.armOptionBtnToggle = false;
			this.ARMOPTIONbtn.Background = Brushes.Gray;
			this.ARMOPTIONbtn.Foreground = Brushes.White;
			this.ARMOPTIONbtn.Content = "Semi Auto";
		}

		private void Closebtn_Click(object sender, RoutedEventArgs e)
		{
			this.CloseTrades(true);
			this.autoArmBtnToggle = false;
			this.AUTOArmbtn.Background = Brushes.Gray;
			this.AUTOArmbtn.Foreground = Brushes.White;
			this.AUTOArmbtn.Content = "Full Auto";
			this.armOptionBtnToggle = false;
			this.ARMOPTIONbtn.Background = Brushes.Gray;
			this.ARMOPTIONbtn.Foreground = Brushes.White;
			this.ARMOPTIONbtn.Content = "Semi Auto";
			this.armShortBtnToggle = false;
			this.ARMSHORTbtn.Background = Brushes.Gray;
			this.ARMSHORTbtn.Foreground = Brushes.White;
			this.armLongBtnToggle = false;
			this.ARMLONGbtn.Background = Brushes.Gray;
			this.ARMLONGbtn.Foreground = Brushes.White;
		}
		private void Closebtn_MouseDown(object sender, RoutedEventArgs e)
		{
			if (this.Closebtn.IsMouseOver)
			{
				this.Closebtn.Background = Brushes.Maroon;
			}
			this.Closebtn.Background = Brushes.Maroon;
			this.Closebtn.FontStyle = FontStyles.Oblique;
		}

		private void Closebtn_MouseUp(object sender, RoutedEventArgs e)
		{
			this.Closebtn.Background = Brushes.Red;
			this.Closebtn.FontStyle = FontStyles.Normal;
		}

		private void Closebtn_MouseLeave(object sender, RoutedEventArgs e)
		{
			this.Closebtn.Background = Brushes.Red;
		}

		private void AUTOArmbtn_Click(object sender, RoutedEventArgs e)
		{
			if (!this.autoArmBtnToggle)
			{
				this.autoArmBtnToggle = true;
				this.AUTOArmbtn.Background = Brushes.DodgerBlue;
				this.AUTOArmbtn.Foreground = Brushes.White;
				this.AUTOArmbtn.Content = "Full Auto - On";
				this.armOptionBtnToggle = false;
				this.ARMOPTIONbtn.Background = Brushes.Gray;
				this.ARMOPTIONbtn.Foreground = Brushes.White;
				this.ARMOPTIONbtn.Content = "Semi Auto";
				return;
			}
			this.autoArmBtnToggle = false;
			this.AUTOArmbtn.Background = Brushes.Gray;
			this.AUTOArmbtn.Foreground = Brushes.White;
			this.AUTOArmbtn.Content = "Full Auto";
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
		{
		}

		public override void OnRenderTargetChanged()
		{
		}

		 private void CloseTrades(bool yn)
	    {
	     if (yn)
			{
				List<Instrument> instrumentNames = new List<Instrument>();
				Dispatcher.BeginInvoke(new Action(delegate()
	        {
	          try
	          {
	            if (this.chartTraderAccount.Positions.Count == 0)
	              return;
	            foreach (Position position in this.chartTraderAccount.Positions)
	            {
	              Instrument instrument = position.Instrument;
	              if (!instrumentNames.Contains(instrument))
	                instrumentNames.Add(instrument);
	            }
	            this.chartTraderAccount.Flatten((ICollection<Instrument>) instrumentNames);
	            Thread.Sleep(250);
	          }
	          catch (Exception ex)
	          {
	          }
	        }));
	      }
	      else
	      {
	        if (this.inPosition && this.posDirection == -1)
	        {
	          int quantity = this.positions.Quantity;
	          int num = 0;
	          this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	          {
	            this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 1, (OrderType) 1, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "Entry", (CustomOrder) null)
	          });
	          foreach (Order order in this.chartTraderAccount.Orders)
	          {
	            if (order.Instrument == this.inst && order.OrderType == null && order.OrderState == (OrderState)10 && num < quantity)
	            {
	              ++num;
	              this.chartTraderAccount.Cancel((IEnumerable<Order>) new Order[1]
	              {
	                order
	              });
	            }
	          }
	        }
	        if (!this.inPosition || this.posDirection != 1)
	          return;
	        int quantity1 = this.positions.Quantity;
	        int num1 = 0;
	        this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	        {
	          this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (TimeInForce) 1, quantity1, 0.0, 0.0, string.Empty, "Entry", (CustomOrder) null)
	        });
	        foreach (Order order in this.chartTraderAccount.Orders)
	        {
	          if (order.Instrument == this.inst && order.OrderType == null && order.OrderState == (OrderState)10 && num1 < quantity1)
	          {
	            ++num1;
	            this.chartTraderAccount.Cancel((IEnumerable<Order>) new Order[1]
	            {
	              order
	            });
	          }
	        }
	      }
	    }

		private void takeTrade(int direction)
	    {
			if (State != State.Realtime || !connected || this.getInstrumentPosition() != null)
	        return;
	      if (!this.armLongBtnToggle)
	      {
	        if (!this.armShortBtnToggle)
	          return;
	      }
	      try
				{
					AtmStrategy atmStrategy = null;
					object atmSelChoice = null;
					ChartControl.Dispatcher.Invoke(delegate()
					{
						AtmStrategySelector atmStrategySelector = Extensions.FindFirst(Window.GetWindow(this.ChartControl.Parent), "ChartTraderControlATMStrategySelector") as AtmStrategySelector;
						atmSelChoice = ((atmStrategySelector != null) ? atmStrategySelector.SelectedItem : null);
					});
					ChartControl.Dispatcher.Invoke(delegate()
					{
						QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
						this.quantityATM = quantityUpDown.Value;
					});
	        int quantity = this.quantityValue;
	        this.Dispatcher.InvokeAsync((Action) (() => quantity = this.quantityValue));
	        if (this.chartTraderAccount == null || atmSelChoice == null)
	          return;
	        if (atmSelChoice.ToString() != "None")
	          atmStrategy = (NinjaTrader.NinjaScript.AtmStrategy) atmSelChoice;
	        if (!this.armOptionBtnToggle && this.autoArmBtnToggle && (this.armLongBtnToggle || this.armShortBtnToggle))
	        {
	          if (!this.inPosition)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	            else if (direction < 0 && this.armShortBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	          }
	          if (this.inPosition && this.posDirection == -1)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              this.CloseTrades(false);
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	            else if (this.armShortBtnToggle && direction < 0)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	          }
	          if (!this.inPosition || this.posDirection != 1)
	            return;
	          if (direction < 0 && this.armShortBtnToggle)
	          {
	            this.CloseTrades(false);
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                try
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                catch (Exception ex)
	                {
	                }
	              }
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	            }
	          }
	          else
	          {
	            if (!this.armLongBtnToggle || direction <= 0)
	              return;
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	              }
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	            }
	          }
	        }
	        else
	        {
	          if (this.autoArmBtnToggle || !this.armOptionBtnToggle || this.onceTriggered || !this.armLongBtnToggle && !this.armShortBtnToggle)
	            return;
	          if (!this.inPosition)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	               ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	            else if (direction < 0 && this.armShortBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	          }
	          if (this.inPosition && this.posDirection == -1)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              this.CloseTrades(false);
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	               ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	            else if (this.armShortBtnToggle && direction < 0)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	          }
	          if (!this.inPosition || this.posDirection != 1)
	            return;
	          if (direction < 0 && this.armShortBtnToggle)
	          {
	            this.CloseTrades(false);
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                try
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                catch (Exception ex)
	                {
	                }
	              }
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	          }
	          else
	          {
	            if (!this.armLongBtnToggle || direction <= 0)
	              return;
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	              }
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	          }
	        }
	      }
	      catch (Exception ex)
	      {
	      }
	    }

		private Position getInstrumentPosition()
		{
			long instrumentId = this.inst.Id;
			Position pos = null;
			Account myAccount = null;
			try
			{
				ChartControl.Dispatcher.Invoke(delegate()
				{
					lock (Account.All)
					{
						///myAccount = Account.All.FirstOrDefault((Account a) => a.Name == this.accountSelector.SelectedAccount.DisplayName);
						myAccount = Account.All.FirstOrDefault((Account a) => a.Name == AccountName);
					}
					pos = myAccount.GetPosition(instrumentId);
					realizedPnL = myAccount.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar); /// Added
				});
				/*if (myAccount == null)
				{
					return null;
				}*/
				if (pos == null) /// changed from acc
				{
					return null;
				}
				if (pos != null)
				{
					return pos;
				}
			}
			catch (Exception)
			{
			}
			return pos;
		}
		
		private void acctCallback(object o)
		{
			try
			{
				ChartControl.Dispatcher.Invoke(delegate()
				{
					AccountSelector accountSelector = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlAccountSelector") as AccountSelector;
					this.chartTraderAccount = ((accountSelector != null) ? accountSelector.SelectedAccount : null);
					this.accountSelector = ((accountSelector != null) ? accountSelector : null);
				});
				if (this.chartTraderAccount != null && !this.handlerSet)
				{
					this.handlerSet = true;
					this.accountSelector.SelectionChanged += new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
				}
			}
			catch (Exception)
			{
			}
		}

		private void posCallback(object o)
		{
			long id = this.inst.Id;
			Position position = null;
			Account account = null;
			try
			{
				lock (Account.All)
				{
					///account = Account.All.FirstOrDefault((Account a) => a.Name == this.chartTraderAccount.DisplayName);
					account = Account.All.FirstOrDefault((Account a) => a.Name == AccountName);
				}
				position = account.GetPosition(id);
				realizedPnL = account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar); /// Added
			}
			catch (Exception e)
			{
			}
			if (account == null)
			{
				this.inPosition = false;
				this.posDirection = 0;
				this.positions = null;
				return;
			}
			if (position == null)
			{
				this.inPosition = false;
				this.posDirection = 0;
				this.positions = null;
				return;
			}
			if (position != null)
			{
				this.inPosition = true;
				this.positions = position;
				if (position.MarketPosition == null)
				{
					this.posDirection = 1;
					return;
				}
				if (position.MarketPosition == (MarketPosition)1)
				{
					this.posDirection = -1;
				}
			}
		}

		private void UpdateRect(ref RectangleF updateRectangle, float x, float y, float width, float height)
		{
			updateRectangle.X = x;
			updateRectangle.Y = y;
			updateRectangle.Width = width;
			updateRectangle.Height = height;
		}

		private void UpdateRect(ref RectangleF rectangle, int x, int y, int width, int height)
		{
			this.UpdateRect(ref rectangle, (float)x, (float)y, (float)width, (float)height);
		}

		[Browsable(false)]
		public double Top { get; set; }

		[Browsable(false)]
		public double Left { get; set; }

		[Display(ResourceType = typeof(Resource), Name = "NinjaScriptIsVisibleOnlyFocused", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 499)]
		[Browsable(false)]
		public bool IsVisibleOnlyFocused { get; set; }

		[Browsable(false)]
		public XElement SelectedTypes { get; set; }

		[Display(ResourceType = typeof(Resource), Name = "NinjaScriptNumberOfRows", GroupName = "NinjaScriptParameters", Order = 0)]
		[Range(1, 2147483647)]
		[Browsable(false)]
		public int NumberOfRows { get; set; }
		
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Profit Target", GroupName = "Total Strategy Profit Target / StopLoss", Order = 0)]
		public int realizedProfit
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "StopLoss (Negative Number)", GroupName = "Total Strategy Profit Target / StopLoss", Order = 0)]
		public int realizedLoss
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Start Time", GroupName = "Time Settings HHMMSS Format", Order = 2)]
		public int startTime
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "End Time", GroupName = "Time Settings HHMMSS Format", Order = 3)]
		public int endTime
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Econ1 Time", GroupName = "Time Settings HHMMSS Format", Order = 6)]
		public int econNumber1
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Econ2 Time", GroupName = "Time Settings HHMMSS Format", Order = 7)]
		public int econNumber2
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Market Open Time", GroupName = "Time Settings HHMMSS Format", Order = 1)]
		public int openTime
		{ get; set; }
		[Display(Name = "Set Account For PNL Tracking", GroupName = "Performance", Order = 1)]
		[TypeConverter(typeof(NinjaTrader.NinjaScript.AccountNameConverter))]
		public string AccountName { get; set; }
		
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Target Line", GroupName = "Visuals For Target/Stop", Order = 1)]
		public int tLine
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Stop Loss Line", GroupName = "Visuals For Target/Stop", Order = 2)]
		public int sLine
		{ get; set; }
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private HFT_Slayer[] cacheHFT_Slayer;
		public HFT_Slayer HFT_Slayer(int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine)
		{
			return HFT_Slayer(Input, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, tLine, sLine);
		}

		public HFT_Slayer HFT_Slayer(ISeries<double> input, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine)
		{
			if (cacheHFT_Slayer != null)
				for (int idx = 0; idx < cacheHFT_Slayer.Length; idx++)
					if (cacheHFT_Slayer[idx] != null && cacheHFT_Slayer[idx].realizedProfit == realizedProfit && cacheHFT_Slayer[idx].realizedLoss == realizedLoss && cacheHFT_Slayer[idx].startTime == startTime && cacheHFT_Slayer[idx].endTime == endTime && cacheHFT_Slayer[idx].econNumber1 == econNumber1 && cacheHFT_Slayer[idx].econNumber2 == econNumber2 && cacheHFT_Slayer[idx].openTime == openTime && cacheHFT_Slayer[idx].tLine == tLine && cacheHFT_Slayer[idx].sLine == sLine && cacheHFT_Slayer[idx].EqualsInput(input))
						return cacheHFT_Slayer[idx];
			return CacheIndicator<HFT_Slayer>(new HFT_Slayer(){ realizedProfit = realizedProfit, realizedLoss = realizedLoss, startTime = startTime, endTime = endTime, econNumber1 = econNumber1, econNumber2 = econNumber2, openTime = openTime, tLine = tLine, sLine = sLine }, input, ref cacheHFT_Slayer);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.HFT_Slayer HFT_Slayer(int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine)
		{
			return indicator.HFT_Slayer(Input, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, tLine, sLine);
		}

		public Indicators.HFT_Slayer HFT_Slayer(ISeries<double> input , int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine)
		{
			return indicator.HFT_Slayer(input, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, tLine, sLine);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.HFT_Slayer HFT_Slayer(int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine)
		{
			return indicator.HFT_Slayer(Input, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, tLine, sLine);
		}

		public Indicators.HFT_Slayer HFT_Slayer(ISeries<double> input , int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine)
		{
			return indicator.HFT_Slayer(input, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, tLine, sLine);
		}
	}
}

#endregion


#########################

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Media;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
using System.Xml.Linq;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Core;
using NinjaTrader.Custom;
using NinjaTrader.Data;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.NinjaScript.AtmStrategy;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript.DrawingTools;
using SharpDX;
using SharpDX.Direct2D1;
using System.Diagnostics;

namespace NinjaTrader.NinjaScript.Indicators
{
	public class HFT_Slayer2 : Indicator
	{
		NinjaTrader.Gui.Tools.SimpleFont title = 
		new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 20, Bold = true };
		NinjaTrader.Gui.Tools.SimpleFont title2 = 
		new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 15, Bold = true };
		NinjaTrader.Gui.Tools.SimpleFont TextFont = 
		new NinjaTrader.Gui.Tools.SimpleFont("Agency Fb", 16) { Size = 15, Bold = false };
		
		NinjaTrader.Gui.Tools.SimpleFont Stitle = 
		new NinjaTrader.Gui.Tools.SimpleFont("Slaytanic", 16) { Size = 30, Bold = true };
		
		double realizedPnL = 0;
		double TriggerBar1 = 0;
		double BarsSince1 = 0;
		double TriggerBar2 = 0;
		double BarsSince2 = 0;
		bool sigLock1 = false;
		bool sigLock2 = false;
		bool playOnce = false;
		bool isReversed = false;
		string version = "V2";
		
		bool alertLock1A = false;
		bool alertLock2A = false;
		int TriggerBar1A = 0;
		int TriggerBar2A = 0;
		bool under20 = false;
		bool over80 = false;
		
		private int lookBackPeriod = 512;
		private int prevSignal;
		bool UseHighLow = true;
		double DeviationValue = 0.6;
		
		private Series<double> IndValue;

		int sTrigger1 = 0;
		int sTrigger2 = 0;
		
		bool striggerOnce1 = false;
		bool striggerOnce2 = false;
		bool shortOK = false;
		bool longOK = false;
		int threshold = 1;
		
		private SimpleFont textFont = new SimpleFont("Arial", 10)
		{
			Bold = true
		};
		
		#region Box Vars
		private Border moveB;
		private Border hideB;
		private Border tileHolder;
		private Grid grid;
		private Thickness margin;
		private bool subscribedToSize;
		private System.Windows.Point startPoint;
		private Button ARMLONGbtn;
		private Button ARMSHORTbtn;
		private Button ARMOPTIONbtn;
		private Button Closebtn;
		private Button AUTOArmbtn;
		private Button resetQuantVal;
		private Button increaseQuant;
		private Button decreaseQuant;
		private Label ATMLabel;
		private Label ACCOUNTLabel;
		private Label selectedATMStrat;
		private Label accountSelected;
		private Label quantityLabel;
		private TextBox quantityLabelVal;
		private ComboBox combo;
		private bool armLongBtnToggle;
		private bool armShortBtnToggle;
		private bool armOptionBtnToggle;
		private bool autoArmBtnToggle;
		private int quantityValue = 1;
		private int quantityATM = 1;
		private bool closeRunning;
		private bool handlerSet;
		private Chart chartWindow;
		private Grid chartTraderGrid;
		private Grid chartTraderButtonsGrid;
		private Grid lowerButtonsGrid;
		private Grid upperButtonsGrid;
		private AtmStrategySelector atmSelector;
		private AccountSelector accountSelector;
		private bool connected;
		private Instrument inst;
		private bool onceTriggered;
		private bool inPosition;
		private int posDirection;
		private Account chartTraderAccount;
		private Position positions;
		private Timer _posTimer;
		private Timer _acctTimer;
		private FrameworkElement addedGrid;
		#endregion
		
		protected override void OnStateChange()
		{
			if (State == (State)1)
			{
				Description = "Custom Visualization for Strategy Execution Operations via HFT ALGO.";
				Name = "HFT_Slayer2";
				Calculate = Calculate.OnEachTick;
				BarsRequiredToPlot = 100;
				IsOverlay = true;
				DisplayInDataBox = false;
				ShowTransparentPlotsInDataBox = true;
				DrawOnPricePanel = true;
				PaintPriceMarkers = false;
				IsSuspendedWhileInactive = false;
				this.SelectedTypes = new XElement("SelectedTypes");
				ArePlotsConfigurable = false;
				AreLinesConfigurable = false;
				this.Left = 5.0;
				this.Top = -1.0;
				this.NumberOfRows = 5;
				realizedProfit = 0;
				realizedLoss = 0;
				startTime = 073000;
				endTime = 120000;
				econNumber1 = 074500;
				econNumber2 = 080000;
				openTime = 0;
				tLine = 15;
				sLine = 30;
				useRSIFilter = false;
				useDiv = false;
				return;
			}
			if (State == State.Configure)
			{
				IndValue = new Series<double>(this);
			}
			if (State == State.DataLoaded)
			{
				///Keyboard hot key listner
				ChartControl.Dispatcher.InvokeAsync(() =>
					{
						ChartControl.KeyDown += new System.Windows.Input.KeyEventHandler(ChartControl_KeyDown);
					});
			}
			if (State != (State)2)
			{
				if (State == (State)4)
				{
					try
					{
						Draw.TextFixed(this, "hftName", "HFT "+Instrument.MasterInstrument.Name.ToString()+" SLAYER", TextPosition.TopRight, Brushes.Crimson, Stitle, Brushes.Black,Brushes.Black,100);
					}
					catch
					{
						Draw.TextFixed(this, "hftName", "HFT "+Instrument.MasterInstrument.Name.ToString()+" SLAYER", TextPosition.TopRight, Brushes.Crimson, title, Brushes.Black,Brushes.Black,100);
					}
					
					#region Control Panel
					
					try
					{
						Dispatcher.InvokeAsync(delegate()
						{
							QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
							this.quantityATM = quantityUpDown.Value;
						});
					}
					catch (Exception)
					{
					}
					try
					{
						if (ChartControl != null)
						{
							if (this.Top < 0.0)
							{
								this.Top = 25.0;
							}
							Dispatcher.Invoke(delegate()
							{
								this.addedGrid = this.CreateControl();
								UserControlCollection.Add(this.addedGrid);
							});
						}
						return;
					}
					catch (Exception)
					{
						return;
					}
					#endregion
				}
				if (State == (State)8)
				{
					if (ChartControl != null)
					{
						ChartControl.Dispatcher.InvokeAsync(() =>
						{
							ChartControl.KeyDown -= ChartControl_KeyDown;
						});
					}
					#region Control Panel
					this.grid = null;
					this.tileHolder = null;
					this.moveB = null;
					this.hideB = null;
					Dispatcher.Invoke(delegate()
					{
						UserControlCollection.Remove(this.addedGrid);
						this.addedGrid = null;
					});
					try
					{
						if (this._posTimer != null)
						{
							this._posTimer.Change(-1, 0);
							this._posTimer.Dispose();
						}
						if (this._acctTimer != null)
						{
							this._acctTimer.Change(-1, 0);
							this._acctTimer.Dispose();
						}
						if (this.addedGrid != null)
						{
							UserControlCollection.Remove(this.addedGrid);
							this.addedGrid = null;
						}
						if (this.moveB != null)
						{
							this.moveB = null;
						}
						if (this.hideB != null)
						{
							this.hideB = null;
						}
						if (this.grid != null)
						{
							this.grid = null;
						}
						if (this.tileHolder != null)
						{
							this.tileHolder = null;
						}
						if (this.ARMLONGbtn != null)
						{
							this.ARMLONGbtn.Click -= this.ARMLONGbtn_Click;
							this.ARMLONGbtn = null;
						}
						if (this.ARMSHORTbtn != null)
						{
							this.ARMSHORTbtn.Click -= this.ARMSHORTbtn_Click;
							this.ARMSHORTbtn = null;
						}
						if (this.ARMOPTIONbtn != null)
						{
							this.ARMOPTIONbtn.Click -= this.ARMOPTIONbtn_Click;
							this.ARMOPTIONbtn = null;
						}
						if (this.Closebtn != null)
						{
							this.Closebtn.Click -= this.Closebtn_Click;
							this.Closebtn = null;
						}
						if (this.AUTOArmbtn != null)
						{
							this.AUTOArmbtn.Click -= this.AUTOArmbtn_Click;
							this.AUTOArmbtn = null;
						}
						if (this.resetQuantVal != null)
						{
							this.resetQuantVal.Click -= new RoutedEventHandler(this.resetQuantVal_Click);
							this.resetQuantVal = null;
						}
						if (this.increaseQuant != null)
						{
							this.increaseQuant.Click -= new RoutedEventHandler(this.increaseQuant_Click);
							this.increaseQuant = null;
						}
						if (this.decreaseQuant != null)
						{
							this.decreaseQuant.Click -= new RoutedEventHandler(this.decreaseQuant_Click);
							this.decreaseQuant = null;
						}
						if (this.atmSelector != null)
						{
							this.atmSelector.SelectionChanged -= new SelectionChangedEventHandler(this.ATMSelection_Changed);
							this.atmSelector = null;
						}
						if (this.quantityLabelVal != null)
						{
							this.quantityLabelVal.PreviewKeyDown -= this.TextBox_PreviewKeyDown;
							this.quantityLabelVal = null;
						}
						if (this.accountSelector != null)
						{
							this.accountSelector.SelectionChanged -= new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
							this.accountSelector = null;
						}
					}
					catch (Exception)
					{
					}
					#endregion
				}
				return;
			}
		}

		protected override void OnBarUpdate()
		{
			try
			{
				if (!this.subscribedToSize && ChartPanel != null)
				{
					this.subscribedToSize = true;
					ChartPanel.SizeChanged += delegate(object sender, SizeChangedEventArgs e)
					{
						if (this.grid != null && ChartPanel != null)
						{
							if (this.grid.Margin.Left + this.grid.ActualWidth > ChartPanel.ActualWidth || this.grid.Margin.Top + this.grid.ActualHeight > ChartPanel.ActualHeight)
							{
								double left = Math.Max(0.0, Math.Min(this.grid.Margin.Left, ChartPanel.ActualWidth - this.grid.ActualWidth));
								double top = Math.Max(0.0, Math.Min(this.grid.Margin.Top, ChartPanel.ActualHeight - this.grid.ActualHeight));
								this.grid.Margin = new Thickness(left, top, 0.0, 0.0);
								this.Left = left;
								this.Top = top;
							}
							return;
						}
					};
				}
				try
				{
					if(AccountName != null)
					{
						try
						{
							Account myPnL = null;
							lock (Account.All)
							{
								myPnL = Account.All.FirstOrDefault(a => a.Name == AccountName);
							}
							realizedPnL = myPnL.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar);
						}
						catch (Exception e)
						{
						}
					}
					Draw.TextFixed(this, "pnlstat", "\n\n"+"ACC PNL $"+realizedPnL.ToString("F2"), TextPosition.TopRight);
					if(realizedProfit != 0 && realizedPnL >= realizedProfit)
					{
						Draw.TextFixed(this, "PT STAT", "Stopped - Profit Target Reached"+ "   Realized P&L: "+ realizedPnL.ToString("F2"), TextPosition.Center, Brushes.LimeGreen, title, Brushes.Black,Brushes.Black,50);
						return;
					}
					if(realizedLoss !=0 && realizedPnL <= realizedLoss)
					{
						Draw.TextFixed(this, "SL STAT", "Stopped - Total Stop Loss Reached"+ "   Realized P&L: "+ realizedPnL.ToString("F2"), TextPosition.Center, Brushes.Red, title, Brushes.Black,Brushes.Black,50);
						return;
					}
					if(isReversed == false)
					{
						Draw.TextFixed(this, "Rev", "Normal"+"\n", TextPosition.BottomLeft, Brushes.LimeGreen, title2, Brushes.Transparent,Brushes.Black,0);
						Draw.TextFixed(this, "v", version.ToString(), TextPosition.BottomLeft);
					}
					if(isReversed == true)
					{
						Draw.TextFixed(this, "Rev", "Reversed"+"\n", TextPosition.BottomLeft, Brushes.LimeGreen, title2, Brushes.Transparent,Brushes.Black,0);
						Draw.TextFixed(this, "v", version.ToString(), TextPosition.BottomLeft);
					}
					if(useRSIFilter == false)
					{
						Draw.TextFixed(this, "Rsi", "RSI Filter OFF"+"\n\n", TextPosition.BottomLeft, Brushes.Crimson, title2, Brushes.Transparent,Brushes.Black,0);
					}
					if(useRSIFilter == true)
					{
						Draw.TextFixed(this, "Rsi", "RSI Filter ON"+"\n\n", TextPosition.BottomLeft, Brushes.LimeGreen, title2, Brushes.Transparent,Brushes.Black,0);
					}
					if(useDiv == false)
					{
						Draw.TextFixed(this, "Div", "Div Filter OFF"+"\n\n\n", TextPosition.BottomLeft, Brushes.Crimson, title2, Brushes.Transparent,Brushes.Black,0);
					}
					if(useDiv == true)
					{
						Draw.TextFixed(this, "Div", "Div Filter ON"+"\n\n\n", TextPosition.BottomLeft, Brushes.LimeGreen, title2, Brushes.Transparent,Brushes.Black,0);
					}
					/// Avoid Econ
					if(econNumber1 != 0 || econNumber2 != 0)
					{
						DateTime ecNumber = Time[0];
						ecNumber.AddMinutes(5);
						
						if((ToTime(Time[0]) >= econNumber1 - (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])) && ToTime(Time[0]) < econNumber1 + (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])))) // Trade Time
						{
							Draw.TextFixed(this, "Econ", "\n\n\n\n"+"No Trades Econ Data Release +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent,Brushes.Black,0);
							return;
						}
						else if((ToTime(Time[0]) >= econNumber2 - (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])) && ToTime(Time[0]) < econNumber2 + (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])))) // Trade Time
						{
							Draw.TextFixed(this, "Econ", "\n\n\n\n"+"No Trades Econ Data Release +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent,Brushes.Black,0);
							return;
						}
						else if((ToTime(Time[0]) >= openTime - (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])) && ToTime(Time[0]) < openTime + (ToTime(ecNumber.AddMinutes(5))-ToTime(Time[0])))) // Trade Time
						{
							Draw.TextFixed(this, "Econ", "\n\n\n\n"+"No Trades During Market Open +- 5min", TextPosition.TopRight, Brushes.Red, title2, Brushes.Transparent,Brushes.Black,0);
							return;
						}
						else
						{
							Draw.TextFixed(this, "Econ", "\n\n\n\n"+"Skipping Econ @ "+econNumber1.ToString()+" and "+econNumber2.ToString(), TextPosition.TopRight, Brushes.LimeGreen, title2, Brushes.Transparent,Brushes.Black,0);
						}
					}
					///Trade Time
					if((ToTime(Time[0]) >= startTime && ToTime(Time[0]) < endTime))
					{
						Draw.TextFixed(this, "timeStat", "\n\n\n"+"Trade Time: Trading " +startTime.ToString() + " to " +endTime.ToString(), TextPosition.TopRight);
					}
					else if(startTime == 0 && endTime == 0)
					{
						Draw.TextFixed(this, "timeStat", "\n\n\n"+"Trade Time: Trading All Day", TextPosition.TopRight);
					}
					else
					{
						Draw.TextFixed(this, "timeStat", "\n\n\n"+"Trade Time: Not Trading", TextPosition.TopRight);
						return;
					}
					
				}
				catch
				{
				}
				try
				{	
					if (CurrentBars[0] < 20)
					{
						return;
					}
					if(State == State.Realtime && inPosition == false)
					{
						Draw.TextFixed(this, "pos", "\n\n\n\n\n"+"No Position", TextPosition.TopRight);
					}
					if(State == State.Realtime && inPosition == true)
					{
						Draw.TextFixed(this, "pos", "\n\n\n\n\n"+"In Position", TextPosition.TopRight);
					}
					if(CurrentBar > TriggerBar1)
					{
						BarsSince1 = CurrentBar - TriggerBar1;
						if(BarsSince1 >= 1 && IsFirstTickOfBar)
						{
							TriggerBar1 = 0;
							sigLock1 = false;
							playOnce = false;
						}
					}
					if(CurrentBar > TriggerBar2 )
					{
						BarsSince2 = CurrentBar - TriggerBar2;
						if(BarsSince2 >= 1 && IsFirstTickOfBar)
						{
							TriggerBar2 = 0;
							sigLock2 = false;
							playOnce = false;
						}
					}
					double stoc1 = StochasticsFast(3,9).D[0]; /// D = 3 K = 9
					double stoc2 = StochasticsFast(3,14).D[0]; /// D = 3 K = 14
					double stoc3 = StochasticsFast(4,40).D[0]; /// D = 4 K = 40
					double stoc4 = Stochastics(10,60,1).D[0];/// D = 10 K = 60 S = 1
					
					IndValue[0] = Volume[0];//VOL()[0];
					int Z1 = ZigZag(DeviationType.Points, DeviationValue, UseHighLow).HighBar(0, 1, lookBackPeriod);
					int Z2 = ZigZag(DeviationType.Points, DeviationValue, UseHighLow).HighBar(0, 2, lookBackPeriod);
					int Z3 = ZigZag(DeviationType.Points, DeviationValue, UseHighLow).LowBar(0, 1, lookBackPeriod);
					int Z4 = ZigZag(DeviationType.Points, DeviationValue, UseHighLow).LowBar(0, 2, lookBackPeriod);
					double sig = 0.0;
					bool flag = Z1 < Z3;
					if (Z1 > -1 && Z2 > -1 && flag)
					{
						if (High[Z1] > High[Z2] && IndValue[Z1] < IndValue[Z2])
						{
							sig = -1.0;
						}
						if (High[Z1] < High[Z2] && IndValue[Z1] > IndValue[Z2])
						{
							sig = -0.5;
						}
					}
					if (Z3 > -1 && Z4 > -1 && !flag)
					{
						if (Low[Z3] < Low[Z4] && IndValue[Z3] > IndValue[Z4])
						{
							sig = 1.0;
						}
						if (Low[Z3] > Low[Z4] && IndValue[Z3] < IndValue[Z4])
						{
							sig = 0.5;
						}
					}
					if (prevSignal != Convert.ToInt32(2.0 * sig))
					{
						prevSignal = Convert.ToInt32(2.0 * sig);
						if (sig < 0.0)
						{
							if (prevSignal == -2 && (Z2 - Z1) >= threshold)
							{
								shortOK = true;
								Draw.Line(this, "PU" + (CurrentBar - Z2).ToString(), IsAutoScale, Z1, High[Z1] + (double)1 * TickSize, Z2, High[Z2] + (double)1 * TickSize, Brushes.Red, DashStyleHelper.Solid, 2, true);
								//Draw.Text(this, "DivLenght"+ (CurrentBar - Z2).ToString(), false, (Z2-Z1).ToString(), 0, High[Z1] + (double)1 * TickSize, 0, Brushes.BlueViolet, new SimpleFont("Arial", 10), TextAlignment.Center, Brushes.Transparent, Brushes.Black, 100);
								if(striggerOnce1 == false)
								{
									sTrigger1 = CurrentBar;
									striggerOnce1 = true;
								}
							}
							else
							{
								shortOK = false;
							}
						}
						if (sig > 0.0)
						{
							if (prevSignal == 2 && (Z4 - Z3) >= threshold)
							{
								longOK = true;
								Draw.Line(this, "PD" + (CurrentBar - Z4).ToString(), IsAutoScale, Z3, Low[Z3] - (double)1 * TickSize, Z4, Low[Z4] - (double)1 * TickSize, Brushes.LimeGreen, DashStyleHelper.Solid, 2, true);
								//Draw.Text(this, "DivLenght"+ (CurrentBar - Z4).ToString(), false, (Z4 - Z3).ToString() , 0, Low[Z3] - (double)1 * TickSize, 0, Brushes.BlueViolet, new SimpleFont("Arial", 12), TextAlignment.Center, Brushes.Transparent, Brushes.Black, 100);
								if(striggerOnce2 == false)
								{
									sTrigger2 = CurrentBar;
									striggerOnce2 = true;
								}
							}
							else
							{
								longOK = false;
							}
						}
					}
					
					if(stoc1 < 20 && stoc2 < 20 && stoc3 < 20 && stoc4 < 20 && under20 == false && alertLock1A == false)/// Long
					{
						under20 = true;
						alertLock1A = true;
						TriggerBar1A = CurrentBar;
					}
					if(under20 == true && stoc1 >= 19.5 && Low[1] < Close[1] && Close[1] > Open[1] && Close[2] < Open[2] && Close[2] == Low[2])
					{
						under20 = false;
						Draw.Line(this, "Long Entry Line" + CurrentBar, false, 1, High[1], -1, High[1], Brushes.DeepSkyBlue, 0, 3);
						Draw.Text(this, "ArrowUP" + CurrentBar, false, "▲", 0, Low[0] - 4.0 * TickSize, 0, Brushes.LimeGreen, new SimpleFont("Arial", 20), TextAlignment.Center, Brushes.Transparent, Brushes.Transparent, 0);
						Draw.Line(this, "15 Target Line" + CurrentBar, false, 1, High[1] + tLine * TickSize, -1, High[1] + tLine * TickSize, Brushes.LimeGreen, 0, 2);
						Draw.Line(this, "30 Stop Line" + CurrentBar, false, 1, High[1] - sLine * TickSize, -1, High[1] - sLine * TickSize, Brushes.Red, 0, 2);
						if(sigLock1 == false && inPosition == false && ((useRSIFilter == false) || (useRSIFilter == true && RSI(2,3)[0] >= 50)) && ((useDiv == false) || (useDiv == true && CountIf(() => longOK == true, 2) >= 1)))
						{
							if(isReversed == false)
							{
								takeTrade(1);
							}
							if(isReversed == true)
							{
								takeTrade(-1);
							}
							sigLock1 = true;
							TriggerBar1 = CurrentBar;
						}
						
					}
					
					if(stoc1 > 80 && stoc2 > 80 && stoc3 > 80 && stoc4 > 80 && over80 == false && alertLock2A == false)/// Short
					{
						over80 = true;
						alertLock2A = true;
						TriggerBar2A = CurrentBar;
					}
					if(over80 == true && stoc1 <= 80.5 && High[1] > Close[1] && Close[1] < Open[1] && Close[2] > Open[2] && Close[2] == High[2])
					{
						over80 = false;
						Draw.Line(this, "Short Entry Line" + CurrentBar, false, 1, Low[1], -1, Low[1], Brushes.Magenta, 0, 3);
						Draw.Text(this, "ArrowDN1" + CurrentBar, false, "▼", 0, High[0] + 4.0 * TickSize, 0, Brushes.Red, new SimpleFont("Arial", 20), TextAlignment.Center, Brushes.Transparent, Brushes.Transparent, 0);
						Draw.Line(this, "15 Target Line" + CurrentBar, false, 1, Low[1] - tLine * TickSize, -1, Low[1] - tLine * TickSize, Brushes.LimeGreen, 0, 2);
						Draw.Line(this, "30 Stop Line" + CurrentBar, false, 1, Low[1] + sLine * TickSize, -1, Low[1] + sLine * TickSize, Brushes.Red, 0, 2);
						if(sigLock2 == false && inPosition == false && ((useRSIFilter == false) || (useRSIFilter == true && RSI(2,3)[0] <= 50)) && ((useDiv == false) || (useDiv == true && CountIf(() => shortOK == true, 2) >= 1)))
						{
								if(isReversed == false)
								{
									takeTrade(-1);
								}
								if(isReversed == true)
								{
									takeTrade(1);
								}
								sigLock2 = true;
			  					TriggerBar2 = CurrentBar;
						}
					}
					
					
					double BarsSince1A = CurrentBar - TriggerBar1A;
					if(BarsSince1A >= 2 && alertLock1A == true)
					{
						alertLock1A = false;
						TriggerBar1A = 0;
					}
					double BarsSince2A = CurrentBar - TriggerBar2A;
					if(BarsSince2A >= 2 && alertLock2A == true)
					{
						alertLock2A = false;
						TriggerBar2A = 0;
					}
				}
				catch (Exception)
				{
				}
				
				
			}
			catch (Exception)
			{
			}
		}
		private void ChartControl_KeyDown(object sender, KeyEventArgs e)
		{
		    if(((Keyboard.Modifiers & ModifierKeys.Control) != 0) && Keyboard.IsKeyDown(Key.NumPad0) )
		    {
				if(isReversed == false)
				{
					isReversed = true;
					Print("Reversed");
					return;
				}
				if(isReversed == true)
				{
					isReversed = false;
					Print("Normal");
					return;
				}
		    }
		}

		private FrameworkElement CreateControl()
		{
			try
			{
				this.chartWindow = (Window.GetWindow(ChartControl.Parent) as Chart);
				this.chartTraderGrid = ((Extensions.FindFirst(this.chartWindow, "ChartWindowChartTraderControl") as ChartTrader).Content as Grid);
				if (this.chartTraderGrid != null)
				{
					try
					{
						this.chartTraderButtonsGrid = (this.chartTraderGrid.Children[0] as Grid);
						if (this.chartTraderButtonsGrid != null)
						{
							Grid grid = (Grid)this.chartTraderGrid.Children[2];
							if (grid != null)
							{
								this.atmSelector = (AtmStrategySelector)grid.Children[1];
								this.atmSelector.SelectionChanged += new SelectionChangedEventHandler(this.ATMSelection_Changed);
							}
							Grid grid2 = (Grid)this.chartTraderGrid.Children[1];
							if (grid2 != null)
							{
								ChartControl.Dispatcher.Invoke(delegate()
								{
									AccountSelector accountSelector = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlAccountSelector") as AccountSelector;
									this.chartTraderAccount = ((accountSelector != null) ? accountSelector.SelectedAccount : null);
									this.accountSelector = ((accountSelector != null) ? accountSelector : null);
								});
								if (this.accountSelector != null && !this.handlerSet)
								{
									this.handlerSet = true;
									this.accountSelector.SelectionChanged += new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
								}
								this.combo = (ComboBox)grid2.Children[4];
								foreach (Instrument instrument in Instrument.All)
								{
									if (instrument.FullName == this.combo.SelectedValue.ToString())
									{
										this.inst = instrument;
									}
								}
							}
						}
						
					}
					catch (Exception)
					{
						
					}
				}
				this._posTimer = new Timer(new TimerCallback(this.posCallback), null, 0, 200);
				this._acctTimer = new Timer(new TimerCallback(this.acctCallback), null, 0, 200);
				if (this.grid != null)
				{
					return this.grid;
				}
				this.grid = new Grid
				{
					VerticalAlignment = VerticalAlignment.Top,
					HorizontalAlignment = HorizontalAlignment.Left,
					Margin = new Thickness(this.Left, this.Top, 0.0, 0.0),
				};
				this.grid.ColumnDefinitions.Add(new ColumnDefinition
				{
					Width = default(GridLength)
				});
				this.grid.ColumnDefinitions.Add(new ColumnDefinition
				{
					Width = default(GridLength)
				});
				this.grid.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				System.Windows.Media.Brush background = (Application.Current.FindResource("BackgroundMainWindow") as System.Windows.Media.Brush) ?? Brushes.White;
				System.Windows.Media.Brush borderBrush = (Application.Current.FindResource("BorderThinBrush") as System.Windows.Media.Brush) ?? Brushes.Black;
				Grid grid3 = new Grid();
				grid3.RowDefinitions.Add(new RowDefinition
				{
					Height = new GridLength(2.0, GridUnitType.Star)
				});
				grid3.RowDefinitions.Add(new RowDefinition
				{
					Height = new GridLength(1.0, GridUnitType.Star)
				});
				grid3.RowDefinitions.Add(new RowDefinition
				{
					Height = new GridLength(2.0, GridUnitType.Star)
				});
				Grid grid4 = new Grid();
				grid4.RowDefinitions.Add(new RowDefinition
				{
					Height = new GridLength(3.0, GridUnitType.Star)
				});
				for (int i = 0; i < grid3.RowDefinitions.Count; i++)
				{
					System.Windows.Shapes.Ellipse element = new System.Windows.Shapes.Ellipse
					{
						Width = 4.0,
						Height = 4.0,
						HorizontalAlignment = HorizontalAlignment.Center,
						VerticalAlignment = VerticalAlignment.Center,
						Fill = Brushes.White
					};
					Grid.SetRow(element, i);
					grid3.Children.Add(element);
				}
				System.Windows.Shapes.Polygon element2 = new System.Windows.Shapes.Polygon
				{
					Width = 12.0,
					Height = 12.0,
					HorizontalAlignment = HorizontalAlignment.Center,
					VerticalAlignment = VerticalAlignment.Center,
					Fill = Brushes.Crimson,
					Points = new PointCollection
					{
						new System.Windows.Point(1.0, 5.0),
						new System.Windows.Point(8.0, 10.0),
						new System.Windows.Point(8.0, 0.0)
					}
				};
				Grid.SetRow(element2, 0);
				grid4.Children.Add(element2);
				this.moveB = new Border
				{
					VerticalAlignment = VerticalAlignment.Top,
					BorderThickness = new Thickness(0.0, 1.0, 1.0, 1.0),
					BorderBrush = borderBrush,
					Background = background,
					Width = 12.0,
					Height = 24.0,
					Cursor = Cursors.Hand,
					Child = grid3
				};
				this.hideB = new Border
				{
					VerticalAlignment = VerticalAlignment.Bottom,
					BorderThickness = new Thickness(0.0, 1.0, 1.0, 1.0),
					BorderBrush = borderBrush,
					Background = background,
					Width = 14.0,
					Height = 24.0,
					Cursor = Cursors.Hand,
					Child = grid4
				};
				 this.moveB.MouseDown += (MouseButtonEventHandler) ((sender, e) =>
		        {
		          this.startPoint = e.GetPosition((IInputElement) this.ChartPanel);
		          this.margin = this.grid.Margin;
		          if (e.ClickCount > 1)
		          {
		            this.moveB.ReleaseMouseCapture();
		            this.ChartControl.OnIndicatorsHotKey((object) this, (KeyEventArgs) null);
		          }
		          else
		            this.moveB.CaptureMouse();
		        });
				this.moveB.MouseUp += delegate(object sender, MouseButtonEventArgs e)
				{
					this.moveB.ReleaseMouseCapture();
				};
				this.moveB.MouseMove += delegate(object sender, MouseEventArgs e)
				{
					if (this.moveB.IsMouseCaptured && this.grid != null && ChartPanel != null)
					{
						System.Windows.Point position = e.GetPosition(ChartPanel);
						this.grid.Margin = new Thickness
						{
							Left = Math.Max(0.0, Math.Min(this.margin.Left + (position.X - this.startPoint.X), ChartPanel.ActualWidth - this.grid.ActualWidth)),
							Top = Math.Max(0.0, Math.Min(this.margin.Top + (position.Y - this.startPoint.Y), ChartPanel.ActualHeight - this.grid.ActualHeight))
						};
						this.Left = this.grid.Margin.Left;
						this.Top = this.grid.Margin.Top;
						return;
					}
				};
				Grid.SetColumn(this.moveB, 1);
				Grid.SetColumn(this.hideB, 2);
				this.grid.Children.Add(this.moveB);
				Grid grid5 = new Grid();
				grid5.Background = Brushes.Black; /// main
				grid5.ColumnDefinitions.Add(new ColumnDefinition
				{
					Width = default(GridLength)
				});
				grid5.ColumnDefinitions.Add(new ColumnDefinition
				{
					Width = default(GridLength)
				});
				grid5.ColumnDefinitions.Add(new ColumnDefinition
				{
					Width = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				grid5.RowDefinitions.Add(new RowDefinition
				{
					Height = default(GridLength)
				});
				Style style = Application.Current.FindResource("BasicEntryButton") as Style;
				Border border = new Border
				{
					Background = Brushes.Black,
					VerticalAlignment = VerticalAlignment.Stretch,
					HorizontalAlignment = HorizontalAlignment.Stretch
				};
				Label label = new Label
				{
					Content = string.Format("HFT "+Instrument.MasterInstrument.Name.ToString()+" SLAYER", 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center,
					FontSize = 14.0
				};
				label.Foreground = Brushes.Crimson;
				label.Background = Brushes.Black;
				label.BorderBrush = Brushes.Transparent;
				label.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(label, 3);
				border.Child = label;
				Grid.SetRow(border, 0);
				Grid.SetColumnSpan(border, 3);
				grid5.Children.Add(border);
				this.ATMLabel = new Label
				{
					Content = string.Format("ATM Strategy: ", 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.ATMLabel.Foreground = Brushes.White;
				this.ATMLabel.Background = Brushes.Transparent;
				this.ATMLabel.BorderBrush = Brushes.Transparent;
				this.ATMLabel.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(this.ATMLabel, 1);
				Grid.SetRow(this.ATMLabel, 1);
				grid5.Children.Add(this.ATMLabel);
				string format = string.Empty;
				if (this.atmSelector != null)
				{
					try
					{
						format = this.atmSelector.SelectedAtmStrategy.DisplayName;
					}
					catch (Exception)
					{
						format = "None";
					}
				}
				this.selectedATMStrat = new Label
				{
					Content = string.Format(format, 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.selectedATMStrat.Foreground = Brushes.White;
				this.selectedATMStrat.Background = Brushes.Transparent;
				this.selectedATMStrat.BorderBrush = Brushes.Transparent;
				this.selectedATMStrat.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(this.selectedATMStrat, 2);
				Grid.SetColumn(this.selectedATMStrat, 1);
				Grid.SetRow(this.selectedATMStrat, 1);
				grid5.Children.Add(this.selectedATMStrat);
				this.ACCOUNTLabel = new Label
				{
					Content = string.Format("Acc: ", 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.ACCOUNTLabel.Foreground = Brushes.White;
				this.ACCOUNTLabel.Background = Brushes.Transparent;
				this.ACCOUNTLabel.BorderBrush = Brushes.Transparent;
				this.ACCOUNTLabel.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(this.ACCOUNTLabel, 1);
				Grid.SetRow(this.ACCOUNTLabel, 2);
				grid5.Children.Add(this.ACCOUNTLabel);
				string format2 = string.Empty;
				lock (Connection.Connections)
				{
					foreach (Connection connection in Connection.Connections)
					{
						if (connection.Status == (ConnectionStatus)3)
						{
							this.connected = true;
							break;
						}
					}
				}
				if (!this.connected)
				{
					format2 = "Disconnected";
				}
				else
				{
					try
					{
						if (this.accountSelector.SelectedIndex.ToString() == string.Empty || this.accountSelector.SelectedAccount.Name == string.Empty || this.accountSelector.SelectedAccount.Name == null || this.accountSelector == null)
						{
							format2 = "Select Account";
						}
						format2 = NinjaTrader.NinjaScript.Indicators.HFT_Slayer2.CensorString(this.accountSelector.SelectedAccount.DisplayName);
					}
					catch (Exception)
					{
						format2 = "Select Account";
					}
				}
				this.accountSelected = new Label
				{
					Content = string.Format(format2, 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.accountSelected.Foreground = Brushes.White;
				this.accountSelected.Background = Brushes.Transparent;
				this.accountSelected.BorderBrush = Brushes.Transparent;
				this.accountSelected.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(this.accountSelected, 2);
				Grid.SetColumn(this.accountSelected, 1);
				Grid.SetRow(this.accountSelected, 2);
				grid5.Children.Add(this.accountSelected);
				this.quantityLabel = new Label
				{
					Content = string.Format("QTY", 0),
					Height = 20.0,
					Margin = new Thickness(4.0, 0.0, 4.0, 0.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 2.0),
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.quantityLabel.Foreground = Brushes.White;
				this.quantityLabel.Background = Brushes.Transparent;
				this.quantityLabel.BorderBrush = Brushes.Transparent;
				this.quantityLabel.HorizontalAlignment = HorizontalAlignment.Center;
				Grid.SetColumnSpan(this.quantityLabel, 3);
				Grid.SetRow(this.quantityLabel, 3);
				//grid5.Children.Add(this.quantityLabel);
				this.decreaseQuant = new Button
				{
					Content = string.Format("-", 1),
					Name = "decreaseQuantity",
					Height = 25.0,
					Width = 25.0,
					Margin = new Thickness(0.0, 0.0, 25.0, 0.0),
					Style = style
				};
				this.decreaseQuant.Background = Brushes.Red;
				this.decreaseQuant.BorderBrush = Brushes.DimGray;
				this.decreaseQuant.Foreground = Brushes.White;
				this.decreaseQuant.HorizontalAlignment = HorizontalAlignment.Right;
				this.decreaseQuant.Click += new RoutedEventHandler(this.decreaseQuant_Click);
				Grid.SetColumn(this.decreaseQuant, 0);
				Grid.SetRow(this.decreaseQuant, 4);
				//grid5.Children.Add(this.decreaseQuant);
				this.increaseQuant = new Button
				{
					Content = string.Format("+", 1),
					Name = "increaseQuantity",
					Height = 25.0,
					Width = 25.0,
					Margin = new Thickness(25.0, 0.0, 0.0, 0.0),
					Style = style
				};
				this.increaseQuant.Background = Brushes.Green;
				this.increaseQuant.BorderBrush = Brushes.DimGray;
				this.increaseQuant.Foreground = Brushes.White;
				this.increaseQuant.HorizontalAlignment = HorizontalAlignment.Left;
				this.increaseQuant.Click += new RoutedEventHandler(this.increaseQuant_Click);
				Grid.SetColumn(this.increaseQuant, 2);
				Grid.SetRow(this.increaseQuant, 4);
				//grid5.Children.Add(this.increaseQuant);
				this.quantityLabelVal = new TextBox
				{
					Text = string.Format(this.quantityValue.ToString(), 0),
					Height = 20.0,
					Width = 60.0,
					FontSize = 14.0,
					HorizontalAlignment = HorizontalAlignment.Center
				};
				this.quantityLabelVal.Foreground = Brushes.White;
				this.quantityLabelVal.Background = Brushes.Transparent;
				this.quantityLabelVal.BorderBrush = Brushes.Transparent;
				this.quantityLabelVal.HorizontalAlignment = HorizontalAlignment.Center;
				this.quantityLabelVal.VerticalAlignment = VerticalAlignment.Center;
				this.quantityLabelVal.TextAlignment = TextAlignment.Center;
				Grid.SetColumnSpan(this.quantityLabelVal, 3);
				Grid.SetRow(this.quantityLabelVal, 4);
				this.quantityLabelVal.PreviewKeyDown += this.TextBox_PreviewKeyDown;
				this.quantityLabelVal.LostFocus += new RoutedEventHandler(this.TextBox_LostFocus);
				this.quantityLabelVal.LostMouseCapture += new MouseEventHandler(this.TextBox_LostFocus);
				//grid5.Children.Add(this.quantityLabelVal);
				this.resetQuantVal = new Button
				{
					Content = string.Format("Reset", 1),
					Name = "resetQuantVal",
					Height = 20.0,
					Width = 60.0,
					FontSize = 12.0,
					Margin = new Thickness(0.0, 4.0, 0.0, 4.0),
					Padding = new Thickness(0.0, 2.0, 0.0, 0.0),
					Style = style
				};
				this.resetQuantVal.Background = Brushes.Gray;
				this.resetQuantVal.BorderBrush = Brushes.DimGray;
				this.resetQuantVal.Foreground = Brushes.White;
				this.resetQuantVal.HorizontalAlignment = HorizontalAlignment.Center;
				this.resetQuantVal.Click += new RoutedEventHandler(this.resetQuantVal_Click);
				Grid.SetColumnSpan(this.resetQuantVal, 3);
				Grid.SetRow(this.resetQuantVal, 5);
				//grid5.Children.Add(this.resetQuantVal);
				this.ARMLONGbtn = new Button
				{
					Content = string.Format("Arm Long", 1),
					Name = "LongArmButton",
					Height = 30.0,
					Width = 125.0,
					Margin = new Thickness(4.0, 4.0, 0.0, 0.0),
					Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
					Style = style
				};
				this.ARMLONGbtn.Background = Brushes.Gray;
				this.ARMLONGbtn.BorderBrush = Brushes.DimGray;
				this.ARMLONGbtn.Foreground = Brushes.White;
				this.ARMLONGbtn.Click += this.ARMLONGbtn_Click;
				Grid.SetColumn(this.ARMLONGbtn, 0);
				Grid.SetRow(this.ARMLONGbtn, 6);
				grid5.Children.Add(this.ARMLONGbtn);
				this.ARMSHORTbtn = new Button
				{
					Content = string.Format("Arm Short", 1),
					Name = "ShortArmButton",
					Height = 30.0,
					Width = 125.0,
					Margin = new Thickness(0.0, 4.0, 4.0, 0.0),
					Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
					Style = style
				};
				this.ARMSHORTbtn.Background = Brushes.Gray;
				this.ARMSHORTbtn.BorderBrush = Brushes.DimGray;
				this.ARMSHORTbtn.Foreground = Brushes.White;
				this.ARMSHORTbtn.Click += this.ARMSHORTbtn_Click;
				Grid.SetColumn(this.ARMSHORTbtn, 2);
				Grid.SetRow(this.ARMSHORTbtn, 6);
				grid5.Children.Add(this.ARMSHORTbtn);
				this.ARMOPTIONbtn = new Button
				{
					Content = string.Format("Semi Auto", 1),
					Name = "ARMOptionButton",
					Height = 30.0,
					Width = 125.0,
					Margin = new Thickness(4.0, 4.0, 0.0, 0.0),
					Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
					Style = style
				};
				this.ARMOPTIONbtn.Background = Brushes.Gray;
				this.ARMOPTIONbtn.BorderBrush = Brushes.DimGray;
				this.ARMOPTIONbtn.Foreground = Brushes.White;
				this.ARMOPTIONbtn.Click += this.ARMOPTIONbtn_Click;
				Grid.SetColumn(this.ARMOPTIONbtn, 0);
				Grid.SetRow(this.ARMOPTIONbtn, 7);
				grid5.Children.Add(this.ARMOPTIONbtn);
				this.AUTOArmbtn = new Button
				{
					Content = string.Format("Full Auto", 1),
					Name = "Continuous",
					Height = 30.0,
					Width = 125.0,
					Margin = new Thickness(0.0, 4.0, 4.0, 0.0),
					Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
					Style = style
				};
				this.AUTOArmbtn.Background = Brushes.Gray;
				this.AUTOArmbtn.BorderBrush = Brushes.DimGray;
				this.AUTOArmbtn.Foreground = Brushes.White;
				this.AUTOArmbtn.Click += this.AUTOArmbtn_Click;
				Grid.SetColumn(this.AUTOArmbtn, 2);
				Grid.SetRow(this.AUTOArmbtn, 7);
				grid5.Children.Add(this.AUTOArmbtn);
				this.Closebtn = new Button
				{
					Content = string.Format("Flatten", 1),
					Name = "Flatten",
					Height = 30.0,
					Margin = new Thickness(4.0, 4.0, 4.0, 0.0),
					Padding = new Thickness(4.0, 0.0, 4.0, 0.0),
					Style = style
				};
				this.Closebtn.Background = Brushes.Red;
				this.Closebtn.BorderBrush = Brushes.DimGray;
				this.Closebtn.Foreground = Brushes.White;
				this.Closebtn.Click += this.Closebtn_Click;
				this.Closebtn.PreviewMouseDown += new MouseButtonEventHandler(this.Closebtn_MouseDown);
				this.Closebtn.PreviewMouseUp += new MouseButtonEventHandler(this.Closebtn_MouseUp);
				this.Closebtn.MouseLeave += new MouseEventHandler(this.Closebtn_MouseLeave);
				Grid.SetColumnSpan(this.Closebtn, 3);
				Grid.SetRow(this.Closebtn, 9);
				grid5.Children.Add(this.Closebtn);
				this.tileHolder = new Border
				{
					Cursor = Cursors.Arrow,
					Background = (Application.Current.FindResource("BackgroundMainWindow") as System.Windows.Media.Brush),
					BorderThickness = new Thickness((double)(Application.Current.FindResource("BorderThinThickness") ?? 1)),
					BorderBrush = (Application.Current.FindResource("BorderThinBrush") as System.Windows.Media.Brush),
					Child = grid5
				};
				this.grid.Children.Add(this.tileHolder);
				this.hideB.MouseUp += delegate(object sender, MouseButtonEventArgs e)
				{
					if (this.ARMOPTIONbtn.Visibility == Visibility.Visible)
					{
						this.ARMOPTIONbtn.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.ARMOPTIONbtn.Visibility = Visibility.Visible;
					}
					if (this.ARMSHORTbtn.Visibility == Visibility.Visible)
					{
						this.ARMSHORTbtn.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.ARMSHORTbtn.Visibility = Visibility.Visible;
					}
					if (this.ARMLONGbtn.Visibility == Visibility.Visible)
					{
						this.ARMLONGbtn.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.ARMLONGbtn.Visibility = Visibility.Visible;
					}
					if (this.Closebtn.Visibility == Visibility.Visible)
					{
						this.Closebtn.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.Closebtn.Visibility = Visibility.Visible;
					}
					if (this.AUTOArmbtn.Visibility == Visibility.Visible)
					{
						this.AUTOArmbtn.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.AUTOArmbtn.Visibility = Visibility.Visible;
					}
					if (this.selectedATMStrat.Visibility == Visibility.Visible)
					{
						this.selectedATMStrat.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.selectedATMStrat.Visibility = Visibility.Visible;
					}
					if (this.ATMLabel.Visibility == Visibility.Visible)
					{
						this.ATMLabel.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.ATMLabel.Visibility = Visibility.Visible;
					}
					if (this.accountSelected.Visibility == Visibility.Visible)
					{
						this.accountSelected.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.accountSelected.Visibility = Visibility.Visible;
					}
					if (this.ACCOUNTLabel.Visibility == Visibility.Visible)
					{
						this.ACCOUNTLabel.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.ACCOUNTLabel.Visibility = Visibility.Visible;
					}
					if (this.quantityLabel.Visibility == Visibility.Visible)
					{
						this.quantityLabel.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.quantityLabel.Visibility = Visibility.Visible;
					}
					if (this.quantityLabelVal.Visibility == Visibility.Visible)
					{
						this.quantityLabelVal.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.quantityLabelVal.Visibility = Visibility.Visible;
					}
					if (this.increaseQuant.Visibility == Visibility.Visible)
					{
						this.increaseQuant.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.increaseQuant.Visibility = Visibility.Visible;
					}
					if (this.decreaseQuant.Visibility == Visibility.Visible)
					{
						this.decreaseQuant.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.decreaseQuant.Visibility = Visibility.Visible;
					}
					if (this.moveB.Visibility == Visibility.Visible)
					{
						this.moveB.Visibility = Visibility.Collapsed;
					}
					else
					{
						this.moveB.Visibility = Visibility.Visible;
					}
					if (this.resetQuantVal.Visibility == Visibility.Visible)
					{
						this.resetQuantVal.Visibility = Visibility.Collapsed;
						return;
					}
					this.resetQuantVal.Visibility = Visibility.Visible;
				};
				this.grid.Children.Add(this.hideB);
				if (this.IsVisibleOnlyFocused)
				{
					Binding binding = new Binding("IsActive")
					{
						Source = ChartControl.OwnerChart,
						Converter = (Application.Current.FindResource("BoolToVisConverter") as IValueConverter)
					};
					this.grid.SetBinding(UIElement.VisibilityProperty, binding);
					return this.grid;
				}
			}
			catch (Exception)
			{
			}
			return this.grid;
		}

		private static string CensorString(string input)
		{
			if (input != null && input.Length >= 3)
			{
				if (input.Length > 10)
				{
					input = input.Substring(0, Math.Min(input.Length, 10));
				}
				else
				{
					input = input.PadRight(10);
				}
				int count = input.Length - 2;
				string str = new string('*', count);
				return input.Substring(0, 2) + str;
			}
			return input;
		}

		private void resetQuantVal_Click(object sender, EventArgs e)
		{
			int num = 1;
			this.quantityLabelVal.Text = num.ToString();
			this.quantityValue = num;
			this.armOptionBtnToggle = false;
			this.ARMOPTIONbtn.Background = Brushes.Gray;
			this.ARMOPTIONbtn.Foreground = Brushes.White;
			this.ARMOPTIONbtn.Content = "Semi Auto";
			this.autoArmBtnToggle = false;
			this.AUTOArmbtn.Background = Brushes.Gray;
			this.AUTOArmbtn.Foreground = Brushes.White;
			this.AUTOArmbtn.Content = "Full Auto";
			this.armShortBtnToggle = false;
			this.ARMSHORTbtn.Background = Brushes.Gray;
			this.ARMSHORTbtn.Foreground = Brushes.White;
			this.armLongBtnToggle = false;
			this.ARMLONGbtn.Background = Brushes.Gray;
			this.ARMLONGbtn.Foreground = Brushes.White;
		}

		private void increaseQuant_Click(object sender, EventArgs e)
		{
			int num;
			if ((num = this.quantityValue + 1) < 1)
			{
				num = 1;
			}
			else if (num > 50)
			{
				num = 50;
			}
			this.quantityLabelVal.Text = num.ToString();
			this.quantityValue = num;
		}

		private void decreaseQuant_Click(object sender, EventArgs e)
		{
			int num;
			if ((num = this.quantityValue - 1) < 1)
			{
				num = 1;
			}
			else if (num > 50)
			{
				num = 50;
			}
			this.quantityLabelVal.Text = num.ToString();
			this.quantityValue = num;
		}

		private void ACCOUNTSelection_Changed(object sender, EventArgs e)
		{
			bool flag = false;
			lock (Connection.Connections)
			{
				foreach (Connection connection in Connection.Connections)
				{
					if (connection.Status == (ConnectionStatus)3)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				this.accountSelected.Content = "Disconnected";
				return;
			}
			if (this.accountSelector != null)
			{
				if (this.accountSelector.SelectedIndex.ToString() == string.Empty || this.accountSelector.SelectedAccount.Name == string.Empty || this.accountSelector.SelectedAccount.Name == null || this.accountSelector == null)
				{
					this.accountSelected.Content = "Select Account";
				}
				this.accountSelected.Content = NinjaTrader.NinjaScript.Indicators.HFT_Slayer2.CensorString(this.accountSelector.SelectedAccount.DisplayName);
			}
		}

		private void TextBox_PreviewKeyDown(object sender, KeyEventArgs e)
		{
			TextBox textBox = sender as TextBox;
			if (textBox != null)
			{
				if ((e.Key >= Key.D0 && e.Key <= Key.D9) || (e.Key >= Key.NumPad0 && e.Key <= Key.NumPad9))
				{
					int num = (e.Key >= Key.NumPad0) ? (e.Key - Key.NumPad0) : (e.Key - Key.D0);
					textBox.Text += num.ToString();
					e.Handled = true;
					return;
				}
				if (e.Key != Key.Back && e.Key != Key.Delete)
				{
					if (e.Key != Key.Tab)
					{
						if (e.Key == Key.Return)
						{
							textBox.Text = textBox.Text;
							this.quantityValue = int.Parse(textBox.Text);
							e.Handled = false;
							return;
						}
						e.Handled = true;
						return;
					}
				}
				e.Handled = false;
				return;
			}
		}

		private void TextBox_LostFocus(object sender, EventArgs e)
		{
			TextBox textBox = sender as TextBox;
			if (textBox != null)
			{
				textBox.Text = textBox.Text;
				this.quantityValue = int.Parse(textBox.Text);
			}
		}

		private void ATMSelection_Changed(object sender, EventArgs e)
		{
			if (this.selectedATMStrat == null || this.atmSelector.SelectedAtmStrategy == null)
			{
				this.selectedATMStrat.Content = "None";
				return;
			}
			if (!(this.atmSelector.SelectedItem.ToString() != "None"))
			{
				this.selectedATMStrat.Content = "None";
				return;
			}
			Dispatcher.InvokeAsync(delegate()
			{
				QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
				this.quantityATM = quantityUpDown.Value;
			});
			if (this.atmSelector.SelectedAtmStrategy.DisplayName.Contains("-"))
			{
				this.selectedATMStrat.Content = this.atmSelector.SelectedAtmStrategy.DisplayName;
				return;
			}
			this.selectedATMStrat.Content = this.atmSelector.SelectedAtmStrategy.DisplayName;
		}
		
		private void ARMLONGbtn_Click(object sender, RoutedEventArgs e)
		{
			if (!this.armLongBtnToggle)
			{
				this.armLongBtnToggle = true;
				this.onceTriggered = false;
				this.ARMLONGbtn.Background = Brushes.LimeGreen;
				this.ARMLONGbtn.Foreground = Brushes.Black;
				return;
			}
			this.armLongBtnToggle = false;
			this.ARMLONGbtn.Background = Brushes.Gray;
			this.ARMLONGbtn.Foreground = Brushes.White;
		}

		private void onceTriggeredARMLONGbtn()
		{
			this.armLongBtnToggle = false;
			this.ARMLONGbtn.Background = Brushes.Gray;
			this.ARMLONGbtn.Foreground = Brushes.White;
		}

		private void ARMSHORTbtn_Click(object sender, RoutedEventArgs e)
		{
			if (!this.armShortBtnToggle)
			{
				this.armShortBtnToggle = true;
				this.onceTriggered = false;
				this.ARMSHORTbtn.Background = Brushes.LimeGreen;
				this.ARMSHORTbtn.Foreground = Brushes.Black;
				return;
			}
			this.armShortBtnToggle = false;
			this.ARMSHORTbtn.Background = Brushes.Gray;
			this.ARMSHORTbtn.Foreground = Brushes.White;
		}

		private void potentialAUTOLong()
		{
			this.ARMLONGbtn.Background = Brushes.Yellow;
			this.ARMLONGbtn.Foreground = Brushes.Black;
		}

		private void potentialAUTOShort()
		{
			this.ARMSHORTbtn.Background = Brushes.Yellow;
			this.ARMSHORTbtn.Foreground = Brushes.Black;
		}

		private void onceTriggeredARMSHORTbtn()
		{
			this.armShortBtnToggle = false;
			this.ARMSHORTbtn.Background = Brushes.Gray;
			this.ARMSHORTbtn.Foreground = Brushes.White;
		}

		private void ARMOPTIONbtn_Click(object sender, RoutedEventArgs e)
		{
			if (!this.armOptionBtnToggle)
			{
				this.armOptionBtnToggle = true;
				this.ARMOPTIONbtn.Background = Brushes.DodgerBlue;
				this.ARMOPTIONbtn.Foreground = Brushes.White;
				this.ARMOPTIONbtn.Content = "Semi Auto - On";
				this.autoArmBtnToggle = false;
				this.AUTOArmbtn.Background = Brushes.Gray;
				this.AUTOArmbtn.Foreground = Brushes.White;
				this.AUTOArmbtn.Content = "Full Auto";
				return;
			}
			this.armOptionBtnToggle = false;
			this.ARMOPTIONbtn.Background = Brushes.Gray;
			this.ARMOPTIONbtn.Foreground = Brushes.White;
			this.ARMOPTIONbtn.Content = "Semi Auto";
		}

		private void Closebtn_Click(object sender, RoutedEventArgs e)
		{
			this.CloseTrades(true);
			this.autoArmBtnToggle = false;
			this.AUTOArmbtn.Background = Brushes.Gray;
			this.AUTOArmbtn.Foreground = Brushes.White;
			this.AUTOArmbtn.Content = "Full Auto";
			this.armOptionBtnToggle = false;
			this.ARMOPTIONbtn.Background = Brushes.Gray;
			this.ARMOPTIONbtn.Foreground = Brushes.White;
			this.ARMOPTIONbtn.Content = "Semi Auto";
			this.armShortBtnToggle = false;
			this.ARMSHORTbtn.Background = Brushes.Gray;
			this.ARMSHORTbtn.Foreground = Brushes.White;
			this.armLongBtnToggle = false;
			this.ARMLONGbtn.Background = Brushes.Gray;
			this.ARMLONGbtn.Foreground = Brushes.White;
		}
		private void Closebtn_MouseDown(object sender, RoutedEventArgs e)
		{
			if (this.Closebtn.IsMouseOver)
			{
				this.Closebtn.Background = Brushes.Maroon;
			}
			this.Closebtn.Background = Brushes.Maroon;
			this.Closebtn.FontStyle = FontStyles.Oblique;
		}

		private void Closebtn_MouseUp(object sender, RoutedEventArgs e)
		{
			this.Closebtn.Background = Brushes.Red;
			this.Closebtn.FontStyle = FontStyles.Normal;
		}

		private void Closebtn_MouseLeave(object sender, RoutedEventArgs e)
		{
			this.Closebtn.Background = Brushes.Red;
		}

		private void AUTOArmbtn_Click(object sender, RoutedEventArgs e)
		{
			if (!this.autoArmBtnToggle)
			{
				this.autoArmBtnToggle = true;
				this.AUTOArmbtn.Background = Brushes.DodgerBlue;
				this.AUTOArmbtn.Foreground = Brushes.White;
				this.AUTOArmbtn.Content = "Full Auto - On";
				this.armOptionBtnToggle = false;
				this.ARMOPTIONbtn.Background = Brushes.Gray;
				this.ARMOPTIONbtn.Foreground = Brushes.White;
				this.ARMOPTIONbtn.Content = "Semi Auto";
				return;
			}
			this.autoArmBtnToggle = false;
			this.AUTOArmbtn.Background = Brushes.Gray;
			this.AUTOArmbtn.Foreground = Brushes.White;
			this.AUTOArmbtn.Content = "Full Auto";
		}

		protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
		{
		}

		public override void OnRenderTargetChanged()
		{
		}

		 private void CloseTrades(bool yn)
	    {
	     if (yn)
			{
				List<Instrument> instrumentNames = new List<Instrument>();
				Dispatcher.BeginInvoke(new Action(delegate()
	        {
	          try
	          {
	            if (this.chartTraderAccount.Positions.Count == 0)
	              return;
	            foreach (Position position in this.chartTraderAccount.Positions)
	            {
	              Instrument instrument = position.Instrument;
	              if (!instrumentNames.Contains(instrument))
	                instrumentNames.Add(instrument);
	            }
	            this.chartTraderAccount.Flatten((ICollection<Instrument>) instrumentNames);
	            Thread.Sleep(250);
	          }
	          catch (Exception ex)
	          {
	          }
	        }));
	      }
	      else
	      {
	        if (this.inPosition && this.posDirection == -1)
	        {
	          int quantity = this.positions.Quantity;
	          int num = 0;
	          this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	          {
	            this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 1, (OrderType) 1, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "Entry", (CustomOrder) null)
	          });
	          foreach (Order order in this.chartTraderAccount.Orders)
	          {
	            if (order.Instrument == this.inst && order.OrderType == null && order.OrderState == (OrderState)10 && num < quantity)
	            {
	              ++num;
	              this.chartTraderAccount.Cancel((IEnumerable<Order>) new Order[1]
	              {
	                order
	              });
	            }
	          }
	        }
	        if (!this.inPosition || this.posDirection != 1)
	          return;
	        int quantity1 = this.positions.Quantity;
	        int num1 = 0;
	        this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	        {
	          this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (TimeInForce) 1, quantity1, 0.0, 0.0, string.Empty, "Entry", (CustomOrder) null)
	        });
	        foreach (Order order in this.chartTraderAccount.Orders)
	        {
	          if (order.Instrument == this.inst && order.OrderType == null && order.OrderState == (OrderState)10 && num1 < quantity1)
	          {
	            ++num1;
	            this.chartTraderAccount.Cancel((IEnumerable<Order>) new Order[1]
	            {
	              order
	            });
	          }
	        }
	      }
	    }

		private void takeTrade(int direction)
	    {
			if (State != State.Realtime || !connected || this.getInstrumentPosition() != null)
	        return;
	      if (!this.armLongBtnToggle)
	      {
	        if (!this.armShortBtnToggle)
	          return;
	      }
	      try
				{
					AtmStrategy atmStrategy = null;
					object atmSelChoice = null;
					ChartControl.Dispatcher.Invoke(delegate()
					{
						AtmStrategySelector atmStrategySelector = Extensions.FindFirst(Window.GetWindow(this.ChartControl.Parent), "ChartTraderControlATMStrategySelector") as AtmStrategySelector;
						atmSelChoice = ((atmStrategySelector != null) ? atmStrategySelector.SelectedItem : null);
					});
					ChartControl.Dispatcher.Invoke(delegate()
					{
						QuantityUpDown quantityUpDown = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlQuantitySelector") as QuantityUpDown;
						this.quantityATM = quantityUpDown.Value;
					});
	        int quantity = this.quantityValue;
	        this.Dispatcher.InvokeAsync((Action) (() => quantity = this.quantityValue));
	        if (this.chartTraderAccount == null || atmSelChoice == null)
	          return;
	        if (atmSelChoice.ToString() != "None")
	          atmStrategy = (NinjaTrader.NinjaScript.AtmStrategy) atmSelChoice;
	        if (!this.armOptionBtnToggle && this.autoArmBtnToggle && (this.armLongBtnToggle || this.armShortBtnToggle))
	        {
	          if (!this.inPosition)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	            else if (direction < 0 && this.armShortBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	          }
	          if (this.inPosition && this.posDirection == -1)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              this.CloseTrades(false);
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	            else if (this.armShortBtnToggle && direction < 0)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                return;
	              }
	            }
	          }
	          if (!this.inPosition || this.posDirection != 1)
	            return;
	          if (direction < 0 && this.armShortBtnToggle)
	          {
	            this.CloseTrades(false);
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                try
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                catch (Exception ex)
	                {
	                }
	              }
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	            }
	          }
	          else
	          {
	            if (!this.armLongBtnToggle || direction <= 0)
	              return;
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	              }
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	            }
	          }
	        }
	        else
	        {
	          if (this.autoArmBtnToggle || !this.armOptionBtnToggle || this.onceTriggered || !this.armLongBtnToggle && !this.armShortBtnToggle)
	            return;
	          if (!this.inPosition)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	               ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	            else if (direction < 0 && this.armShortBtnToggle)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	          }
	          if (this.inPosition && this.posDirection == -1)
	          {
	            if (direction > 0 && this.armLongBtnToggle)
	            {
	              this.CloseTrades(false);
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  try
	                  {
	                    Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                    NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                  }
	                  catch (Exception ex)
	                  {
	                  }
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	               ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	            else if (this.armShortBtnToggle && direction < 0)
	            {
	              if (atmStrategy != null && atmSelChoice.ToString() != "None")
	              {
	                for (int index = 0; index < quantity; ++index)
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	              if (atmSelChoice.ToString() == "None" && atmStrategy == null)
	              {
	                this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	                {
	                  this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	                });
	                ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	                return;
	              }
	            }
	          }
	          if (!this.inPosition || this.posDirection != 1)
	            return;
	          if (direction < 0 && this.armShortBtnToggle)
	          {
	            this.CloseTrades(false);
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                try
	                {
	                  Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                  NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	                }
	                catch (Exception ex)
	                {
	                }
	              }
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 2, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	          }
	          else
	          {
	            if (!this.armLongBtnToggle || direction <= 0)
	              return;
	            if (atmStrategy != null && atmSelChoice.ToString() != "None")
	            {
	              for (int index = 0; index < quantity; ++index)
	              {
	                Order order = this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, this.quantityATM, 0.0, 0.0, string.Empty, "Entry", Globals.MaxDate, (CustomOrder) null);
	                NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategy, order);
	              }
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	            else
	            {
	              if (!(atmSelChoice.ToString() == "None") || atmStrategy != null)
	                return;
	              this.chartTraderAccount.Submit((IEnumerable<Order>) new Order[1]
	              {
	                this.chartTraderAccount.CreateOrder(this.inst, (OrderAction) 0, (OrderType) 1, (OrderEntry) 0, (TimeInForce) 1, quantity, 0.0, 0.0, string.Empty, "EntryNaked", Globals.MaxDate, (CustomOrder) null)
	              });
	              ChartControl.Dispatcher.InvokeAsync(delegate()
											{
												this.onceTriggeredARMLONGbtn();
												this.onceTriggeredARMSHORTbtn();
												this.onceTriggered = true;
											});
	            }
	          }
	        }
	      }
	      catch (Exception ex)
	      {
	      }
	    }

		private Position getInstrumentPosition()
		{
			long instrumentId = this.inst.Id;
			Position pos = null;
			Account myAccount = null;
			try
			{
				ChartControl.Dispatcher.Invoke(delegate()
				{
					lock (Account.All)
					{
						///myAccount = Account.All.FirstOrDefault((Account a) => a.Name == this.accountSelector.SelectedAccount.DisplayName);
						myAccount = Account.All.FirstOrDefault((Account a) => a.Name == AccountName);
					}
					pos = myAccount.GetPosition(instrumentId);
					realizedPnL = myAccount.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar); /// Added
				});
				/*if (myAccount == null)
				{
					return null;
				}*/
				if (pos == null) /// changed from acc
				{
					return null;
				}
				if (pos != null)
				{
					return pos;
				}
			}
			catch (Exception)
			{
			}
			return pos;
		}
		
		private void acctCallback(object o)
		{
			try
			{
				ChartControl.Dispatcher.Invoke(delegate()
				{
					AccountSelector accountSelector = Extensions.FindFirst(Window.GetWindow(ChartControl.Parent), "ChartTraderControlAccountSelector") as AccountSelector;
					this.chartTraderAccount = ((accountSelector != null) ? accountSelector.SelectedAccount : null);
					this.accountSelector = ((accountSelector != null) ? accountSelector : null);
				});
				if (this.chartTraderAccount != null && !this.handlerSet)
				{
					this.handlerSet = true;
					this.accountSelector.SelectionChanged += new SelectionChangedEventHandler(this.ACCOUNTSelection_Changed);
				}
			}
			catch (Exception)
			{
			}
		}

		private void posCallback(object o)
		{
			long id = this.inst.Id;
			Position position = null;
			Account account = null;
			try
			{
				lock (Account.All)
				{
					///account = Account.All.FirstOrDefault((Account a) => a.Name == this.chartTraderAccount.DisplayName);
					account = Account.All.FirstOrDefault((Account a) => a.Name == AccountName);
				}
				position = account.GetPosition(id);
				realizedPnL = account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar); /// Added
			}
			catch (Exception e)
			{
			}
			if (account == null)
			{
				this.inPosition = false;
				this.posDirection = 0;
				this.positions = null;
				return;
			}
			if (position == null)
			{
				this.inPosition = false;
				this.posDirection = 0;
				this.positions = null;
				return;
			}
			if (position != null)
			{
				this.inPosition = true;
				this.positions = position;
				if (position.MarketPosition == null)
				{
					this.posDirection = 1;
					return;
				}
				if (position.MarketPosition == (MarketPosition)1)
				{
					this.posDirection = -1;
				}
			}
		}

		private void UpdateRect(ref RectangleF updateRectangle, float x, float y, float width, float height)
		{
			updateRectangle.X = x;
			updateRectangle.Y = y;
			updateRectangle.Width = width;
			updateRectangle.Height = height;
		}

		private void UpdateRect(ref RectangleF rectangle, int x, int y, int width, int height)
		{
			this.UpdateRect(ref rectangle, (float)x, (float)y, (float)width, (float)height);
		}

		[Browsable(false)]
		public double Top { get; set; }

		[Browsable(false)]
		public double Left { get; set; }

		[Display(ResourceType = typeof(Resource), Name = "NinjaScriptIsVisibleOnlyFocused", GroupName = "NinjaScriptIndicatorVisualGroup", Order = 499)]
		[Browsable(false)]
		public bool IsVisibleOnlyFocused { get; set; }

		[Browsable(false)]
		public XElement SelectedTypes { get; set; }

		[Display(ResourceType = typeof(Resource), Name = "NinjaScriptNumberOfRows", GroupName = "NinjaScriptParameters", Order = 0)]
		[Range(1, 2147483647)]
		[Browsable(false)]
		public int NumberOfRows { get; set; }
		
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Profit Target", GroupName = "Total Strategy Profit Target / StopLoss", Order = 0)]
		public int realizedProfit
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "StopLoss (Negative Number)", GroupName = "Total Strategy Profit Target / StopLoss", Order = 0)]
		public int realizedLoss
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Start Time", GroupName = "Time Settings HHMMSS Format", Order = 2)]
		public int startTime
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "End Time", GroupName = "Time Settings HHMMSS Format", Order = 3)]
		public int endTime
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Econ1 Time", GroupName = "Time Settings HHMMSS Format", Order = 6)]
		public int econNumber1
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Econ2 Time", GroupName = "Time Settings HHMMSS Format", Order = 7)]
		public int econNumber2
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Market Open Time", GroupName = "Time Settings HHMMSS Format", Order = 1)]
		public int openTime
		{ get; set; }
		[Display(Name = "Set Account For PNL Tracking", GroupName = "Performance", Order = 1)]
		[TypeConverter(typeof(NinjaTrader.NinjaScript.AccountNameConverter))]
		public string AccountName { get; set; }
		
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Target Line", GroupName = "Visuals For Target/Stop", Order = 1)]
		public int tLine
		{ get; set; }
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Stop Loss Line", GroupName = "Visuals For Target/Stop", Order = 2)]
		public int sLine
		{ get; set; }
		
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "RSI Filter ON/OFF", GroupName = "RSI Filter", Order = 2)]
		public bool useRSIFilter
		{ get; set; }
		
		[NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Divergence Filter ON/OFF", GroupName = "Divergence Filter", Order = 1)]
		public bool useDiv
		{ get; set; }
		
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private HFT_Slayer2[] cacheHFT_Slayer2;
		public HFT_Slayer2 HFT_Slayer2(int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine, bool useRSIFilter, bool useDiv)
		{
			return HFT_Slayer2(Input, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, tLine, sLine, useRSIFilter, useDiv);
		}

		public HFT_Slayer2 HFT_Slayer2(ISeries<double> input, int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine, bool useRSIFilter, bool useDiv)
		{
			if (cacheHFT_Slayer2 != null)
				for (int idx = 0; idx < cacheHFT_Slayer2.Length; idx++)
					if (cacheHFT_Slayer2[idx] != null && cacheHFT_Slayer2[idx].realizedProfit == realizedProfit && cacheHFT_Slayer2[idx].realizedLoss == realizedLoss && cacheHFT_Slayer2[idx].startTime == startTime && cacheHFT_Slayer2[idx].endTime == endTime && cacheHFT_Slayer2[idx].econNumber1 == econNumber1 && cacheHFT_Slayer2[idx].econNumber2 == econNumber2 && cacheHFT_Slayer2[idx].openTime == openTime && cacheHFT_Slayer2[idx].tLine == tLine && cacheHFT_Slayer2[idx].sLine == sLine && cacheHFT_Slayer2[idx].useRSIFilter == useRSIFilter && cacheHFT_Slayer2[idx].useDiv == useDiv && cacheHFT_Slayer2[idx].EqualsInput(input))
						return cacheHFT_Slayer2[idx];
			return CacheIndicator<HFT_Slayer2>(new HFT_Slayer2(){ realizedProfit = realizedProfit, realizedLoss = realizedLoss, startTime = startTime, endTime = endTime, econNumber1 = econNumber1, econNumber2 = econNumber2, openTime = openTime, tLine = tLine, sLine = sLine, useRSIFilter = useRSIFilter, useDiv = useDiv }, input, ref cacheHFT_Slayer2);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.HFT_Slayer2 HFT_Slayer2(int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine, bool useRSIFilter, bool useDiv)
		{
			return indicator.HFT_Slayer2(Input, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, tLine, sLine, useRSIFilter, useDiv);
		}

		public Indicators.HFT_Slayer2 HFT_Slayer2(ISeries<double> input , int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine, bool useRSIFilter, bool useDiv)
		{
			return indicator.HFT_Slayer2(input, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, tLine, sLine, useRSIFilter, useDiv);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.HFT_Slayer2 HFT_Slayer2(int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine, bool useRSIFilter, bool useDiv)
		{
			return indicator.HFT_Slayer2(Input, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, tLine, sLine, useRSIFilter, useDiv);
		}

		public Indicators.HFT_Slayer2 HFT_Slayer2(ISeries<double> input , int realizedProfit, int realizedLoss, int startTime, int endTime, int econNumber1, int econNumber2, int openTime, int tLine, int sLine, bool useRSIFilter, bool useDiv)
		{
			return indicator.HFT_Slayer2(input, realizedProfit, realizedLoss, startTime, endTime, econNumber1, econNumber2, openTime, tLine, sLine, useRSIFilter, useDiv);
		}
	}
}

#endregion


#########################

#region Using declarations
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Xml.Serialization;
using NinjaTrader.Gui;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.Indicators;
#endregion

// This indicator identifies the current market regime as either "Trending" or "Flat" based on ADX and MA slope.
namespace NinjaTrader.NinjaScript.Indicators
{
    public class MarketRegimeDetector : Indicator
    {
        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name="ADX Period", Description="Period for ADX calculation.", Order=1, GroupName="Parameters")]
        public int AdxPeriod
        { get; set; } = 14;

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name="EMA Period", Description="Period for the EMA used to determine slope.", Order=2, GroupName="Parameters")]
        public int EmaPeriod
        { get; set; } = 50;

        [NinjaScriptProperty]
        [Display(Name="ADX Threshold", Description="ADX threshold above which market is considered trending.", Order=3, GroupName="Parameters")]
        public double AdxThreshold
        { get; set; } = 25.0;

        [NinjaScriptProperty]
        [Display(Name="Slope Threshold", Description="Minimum slope of EMA to consider market as trending.", Order=4, GroupName="Parameters")]
        public double SlopeThreshold
        { get; set; } = 0.0001;

        private ADX adxIndicator;
        private EMA emaIndicator;

        // Plot: 
        // Value = 1 when trending
        // Value = 0 when flat
        [Browsable(false)]
        [XmlIgnore]
        public Series<double> RegimePlot
        {
            get { return Values[0]; }
        }

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Description = "Detects if the market is trending or flat using ADX and EMA slope.";
                Name = "MarketRegimeDetector";
                Calculate = Calculate.OnBarClose;
                IsOverlay = false;
                DisplayInDataBox = true;
                DrawOnPricePanel = false;
                PaintPriceMarkers = true;
                IsSuspendedWhileInactive = true;

                AddPlot(new Stroke(System.Windows.Media.Brushes.DodgerBlue), PlotStyle.Bar, "Regime");
            }
            else if (State == State.DataLoaded)
            {
                adxIndicator = ADX(AdxPeriod);
                emaIndicator = EMA(EmaPeriod);
            }
        }

        protected override void OnBarUpdate()
        {
            if (CurrentBar < EmaPeriod || CurrentBar < AdxPeriod) 
            {
                // Not enough data for calculations
                RegimePlot[0] = 0;
                return;
            }

            double currentAdx = adxIndicator[0];
            double currentEma = emaIndicator[0];
            double prevEma = emaIndicator[1];

            double slope = currentEma - prevEma;

            bool isTrending = (currentAdx > AdxThreshold) && (Math.Abs(slope) > SlopeThreshold);

            RegimePlot[0] = isTrending ? 1 : 0;
        }
    }
}


#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MarketRegimeDetector[] cacheMarketRegimeDetector;
		public MarketRegimeDetector MarketRegimeDetector(int adxPeriod, int emaPeriod, double adxThreshold, double slopeThreshold)
		{
			return MarketRegimeDetector(Input, adxPeriod, emaPeriod, adxThreshold, slopeThreshold);
		}

		public MarketRegimeDetector MarketRegimeDetector(ISeries<double> input, int adxPeriod, int emaPeriod, double adxThreshold, double slopeThreshold)
		{
			if (cacheMarketRegimeDetector != null)
				for (int idx = 0; idx < cacheMarketRegimeDetector.Length; idx++)
					if (cacheMarketRegimeDetector[idx] != null && cacheMarketRegimeDetector[idx].AdxPeriod == adxPeriod && cacheMarketRegimeDetector[idx].EmaPeriod == emaPeriod && cacheMarketRegimeDetector[idx].AdxThreshold == adxThreshold && cacheMarketRegimeDetector[idx].SlopeThreshold == slopeThreshold && cacheMarketRegimeDetector[idx].EqualsInput(input))
						return cacheMarketRegimeDetector[idx];
			return CacheIndicator<MarketRegimeDetector>(new MarketRegimeDetector(){ AdxPeriod = adxPeriod, EmaPeriod = emaPeriod, AdxThreshold = adxThreshold, SlopeThreshold = slopeThreshold }, input, ref cacheMarketRegimeDetector);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MarketRegimeDetector MarketRegimeDetector(int adxPeriod, int emaPeriod, double adxThreshold, double slopeThreshold)
		{
			return indicator.MarketRegimeDetector(Input, adxPeriod, emaPeriod, adxThreshold, slopeThreshold);
		}

		public Indicators.MarketRegimeDetector MarketRegimeDetector(ISeries<double> input , int adxPeriod, int emaPeriod, double adxThreshold, double slopeThreshold)
		{
			return indicator.MarketRegimeDetector(input, adxPeriod, emaPeriod, adxThreshold, slopeThreshold);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MarketRegimeDetector MarketRegimeDetector(int adxPeriod, int emaPeriod, double adxThreshold, double slopeThreshold)
		{
			return indicator.MarketRegimeDetector(Input, adxPeriod, emaPeriod, adxThreshold, slopeThreshold);
		}

		public Indicators.MarketRegimeDetector MarketRegimeDetector(ISeries<double> input , int adxPeriod, int emaPeriod, double adxThreshold, double slopeThreshold)
		{
			return indicator.MarketRegimeDetector(input, adxPeriod, emaPeriod, adxThreshold, slopeThreshold);
		}
	}
}

#endregion


#########################



#########################

